<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>H4CK3R C0NS0L3 // 31337 OPS</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&display=swap');

  :root {
    --green: #00ff41;
    --dark-green: #003b00;
    --cyan: #00ffff;
    --red: #ff0040;
    --amber: #ffbf00;
    --purple: #bf00ff;
    --blue: #0080ff;
    --bg: #0a0a0a;
    --panel-bg: rgba(0, 20, 0, 0.85);
    --border: #004400;
    --glow: 0 0 10px rgba(0, 255, 65, 0.5);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--green);
    font-family: 'Share Tech Mono', monospace;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    cursor: crosshair;
  }

  /* SCANLINE OVERLAY */
  body::after {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: repeating-linear-gradient(
      0deg,
      rgba(0, 0, 0, 0.15) 0px,
      rgba(0, 0, 0, 0.15) 1px,
      transparent 1px,
      transparent 2px
    );
    pointer-events: none;
    z-index: 10000;
  }

  /* GLOBAL FLICKER */
  @keyframes flicker {
    0%, 97%, 100% { opacity: 1; }
    98% { opacity: 0.85; }
    99% { opacity: 0.92; }
  }

  #main-container {
    width: 100vw;
    height: 100vh;
    animation: flicker 4s infinite;
    display: flex;
    flex-direction: column;
  }

  /* TOP BAR */
  #top-bar {
    height: 36px;
    background: linear-gradient(180deg, #001a00, #000d00);
    border-bottom: 1px solid var(--green);
    display: flex;
    align-items: center;
    padding: 0 10px;
    gap: 20px;
    flex-shrink: 0;
    box-shadow: 0 2px 10px rgba(0, 255, 65, 0.2);
    z-index: 100;
  }

  #top-bar .logo {
    font-family: 'Orbitron', sans-serif;
    font-weight: 900;
    font-size: 14px;
    color: var(--green);
    text-shadow: var(--glow);
    letter-spacing: 3px;
  }

  .top-menu {
    display: flex;
    gap: 2px;
  }

  .top-menu-item {
    padding: 4px 12px;
    font-size: 11px;
    cursor: pointer;
    color: var(--green);
    transition: all 0.1s;
    position: relative;
  }

  .top-menu-item:hover {
    background: var(--green);
    color: #000;
  }

  .dropdown-menu {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    background: #001a00;
    border: 1px solid var(--green);
    min-width: 180px;
    z-index: 9999;
  }

  .top-menu-item:hover .dropdown-menu {
    display: block;
  }

  .dropdown-item {
    padding: 6px 14px;
    font-size: 11px;
    cursor: pointer;
    white-space: nowrap;
    color: var(--green);
  }

  .dropdown-item:hover {
    background: var(--green);
    color: #000;
  }

  .top-bar-status {
    margin-left: auto;
    display: flex;
    gap: 15px;
    align-items: center;
    font-size: 10px;
  }

  .status-indicator {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .status-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    animation: pulse-dot 2s infinite;
  }

  @keyframes pulse-dot {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  .dot-green { background: var(--green); box-shadow: 0 0 6px var(--green); }
  .dot-red { background: var(--red); box-shadow: 0 0 6px var(--red); }
  .dot-amber { background: var(--amber); box-shadow: 0 0 6px var(--amber); }
  .dot-cyan { background: var(--cyan); box-shadow: 0 0 6px var(--cyan); }

  /* WORKSPACE */
  #workspace {
    flex: 1;
    position: relative;
    overflow: hidden;
  }

  /* PANELS */
  .panel {
    position: absolute;
    background: var(--panel-bg);
    border: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 0 0 15px rgba(0, 255, 65, 0.1), inset 0 0 30px rgba(0, 0, 0, 0.5);
  }

  .panel.focused {
    border-color: var(--green);
    box-shadow: 0 0 20px rgba(0, 255, 65, 0.3), inset 0 0 30px rgba(0, 0, 0, 0.5);
    z-index: 50;
  }

  .panel-header {
    height: 24px;
    background: linear-gradient(90deg, #002200, #001100);
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    padding: 0 8px;
    cursor: move;
    flex-shrink: 0;
    user-select: none;
  }

  .panel-header .title {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    flex: 1;
  }

  .panel-header .controls {
    display: flex;
    gap: 4px;
  }

  .panel-header .ctrl-btn {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    cursor: pointer;
  }

  .ctrl-close { background: var(--red); }
  .ctrl-min { background: var(--amber); }
  .ctrl-max { background: var(--green); }

  .panel-body {
    flex: 1;
    overflow: hidden;
    padding: 6px;
    position: relative;
  }

  /* RESIZE HANDLE */
  .resize-handle {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 14px;
    height: 14px;
    cursor: nwse-resize;
    z-index: 10;
  }

  .resize-handle::after {
    content: '⋱';
    position: absolute;
    right: 2px;
    bottom: -2px;
    font-size: 10px;
    color: var(--green);
    opacity: 0.5;
  }

  /* TERMINAL */
  .terminal-output {
    height: 100%;
    overflow-y: auto;
    font-size: 11px;
    line-height: 1.4;
    scrollbar-width: thin;
    scrollbar-color: var(--green) transparent;
  }

  .terminal-output::-webkit-scrollbar { width: 4px; }
  .terminal-output::-webkit-scrollbar-thumb { background: var(--dark-green); }

  .term-line { margin-bottom: 1px; white-space: pre-wrap; word-break: break-all; }
  .term-prompt { color: var(--cyan); }
  .term-error { color: var(--red); }
  .term-warn { color: var(--amber); }
  .term-info { color: var(--green); }
  .term-purple { color: var(--purple); }
  .term-blue { color: var(--blue); }

  .term-input-line {
    display: flex;
    align-items: center;
    margin-top: 4px;
  }

  .term-input-line span { color: var(--cyan); font-size: 11px; }

  .term-input {
    background: transparent;
    border: none;
    color: var(--green);
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    outline: none;
    flex: 1;
    caret-color: var(--green);
  }

  /* GRAPH CANVAS */
  .graph-canvas {
    width: 100%;
    height: 100%;
  }

  /* MATRIX RAIN BG */
  #matrix-bg {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    opacity: 0.55;
  }

  /* EQ BARS */
  /* EQ styles removed — now WebGL */

  /* WORLD MAP */
  .world-map-container {
    width: 100%;
    height: 100%;
    position: relative;
  }

  /* HEX DUMP */
  .hex-dump {
    font-size: 9px;
    line-height: 1.5;
    color: var(--green);
    opacity: 0.9;
    overflow-y: auto;
    height: 100%;
  }

  /* SELECTION BOX */
  .selection-box {
    position: fixed;
    border: 1px dashed var(--cyan);
    background: rgba(0, 255, 255, 0.05);
    pointer-events: none;
    z-index: 9998;
    display: none;
  }

  /* VIDEO FEED */
  .video-feed {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    background: #000;
  }

  .video-feed canvas {
    width: 100%;
    height: 100%;
  }

  .video-overlay {
    position: absolute;
    top: 4px;
    left: 4px;
    font-size: 9px;
    color: var(--red);
    text-shadow: 0 0 5px var(--red);
  }

  .video-overlay.rec::before {
    content: '● ';
    animation: pulse-dot 1s infinite;
  }

  /* BOTTOM BAR */
  #bottom-bar {
    height: 22px;
    background: linear-gradient(180deg, #000d00, #001a00);
    border-top: 1px solid var(--border);
    display: flex;
    align-items: center;
    padding: 0 10px;
    font-size: 9px;
    gap: 20px;
    flex-shrink: 0;
    z-index: 100;
  }

  #bottom-bar .section {
    display: flex;
    gap: 6px;
    align-items: center;
  }

  /* PROGRESS BARS */
  .mini-progress {
    width: 60px;
    height: 4px;
    background: #001100;
    border: 1px solid var(--border);
    overflow: hidden;
  }

  .mini-progress-fill {
    height: 100%;
    transition: width 0.3s;
  }

  /* CONTEXT MENU */
  .context-menu {
    display: none;
    position: fixed;
    background: #001a00;
    border: 1px solid var(--green);
    min-width: 160px;
    z-index: 99999;
    box-shadow: 0 0 15px rgba(0, 255, 65, 0.3);
  }

  .context-menu-item {
    padding: 6px 14px;
    font-size: 11px;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
  }

  .context-menu-item:hover {
    background: var(--green);
    color: #000;
  }

  .context-menu-sep {
    height: 1px;
    background: var(--border);
    margin: 2px 0;
  }

  .ctx-shortcut { opacity: 0.6; font-size: 9px; }

  /* TOOLTIP */
  .tooltip {
    position: fixed;
    background: #001a00;
    border: 1px solid var(--green);
    padding: 4px 8px;
    font-size: 9px;
    pointer-events: none;
    z-index: 99999;
    display: none;
    max-width: 200px;
    box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
  }

  /* NOTIFICATION */
  .notification {
    position: fixed;
    top: 42px;
    right: 10px;
    background: #001a00;
    border: 1px solid var(--green);
    padding: 10px 16px;
    font-size: 11px;
    z-index: 99999;
    animation: slideIn 0.3s ease, fadeOut 0.5s ease 3s forwards;
    box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
  }

  .notification.error { border-color: var(--red); color: var(--red); box-shadow: 0 0 20px rgba(255, 0, 64, 0.3); }
  .notification.warn { border-color: var(--amber); color: var(--amber); }

  @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
  @keyframes fadeOut { to { opacity: 0; transform: translateY(-10px); } }

  /* BOOT SCREEN */
  #boot-screen {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    background: #000;
    z-index: 100000;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-family: 'Share Tech Mono', monospace;
  }

  #boot-text {
    max-width: 700px;
    font-size: 13px;
    line-height: 1.6;
    color: var(--green);
    text-shadow: var(--glow);
  }

  #boot-text .blink-cursor::after {
    content: '█';
    animation: blink 0.5s infinite;
  }

  @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

  /* DATA TABLE */
  .data-table {
    width: 100%;
    font-size: 9px;
    border-collapse: collapse;
  }

  .data-table th {
    background: rgba(0, 255, 65, 0.1);
    padding: 3px 6px;
    text-align: left;
    border-bottom: 1px solid var(--border);
    color: var(--cyan);
  }

  .data-table td {
    padding: 2px 6px;
    border-bottom: 1px solid rgba(0, 68, 0, 0.3);
  }

  .data-table tr:hover td {
    background: rgba(0, 255, 65, 0.05);
  }

  /* RADAR */
  .radar-container {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* NODE GRAPH */
  .node-graph { width: 100%; height: 100%; }

  /* TABS */
  .panel-tabs {
    display: flex;
    background: rgba(0, 17, 0, 0.5);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }

  .panel-tab {
    padding: 3px 10px;
    font-size: 9px;
    cursor: pointer;
    border-right: 1px solid var(--border);
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .panel-tab.active {
    background: rgba(0, 255, 65, 0.1);
    color: var(--cyan);
  }

  .panel-tab:hover { background: rgba(0, 255, 65, 0.05); }

  /* GLITCH EFFECT */
  @keyframes glitch {
    0%, 90%, 100% { transform: translate(0); }
    92% { transform: translate(-2px, 1px); filter: hue-rotate(90deg); }
    94% { transform: translate(2px, -1px); }
    96% { transform: translate(-1px, -1px); filter: hue-rotate(180deg); }
    98% { transform: translate(1px, 2px); }
  }

  .glitch-text {
    animation: glitch 8s infinite;
  }

  /* TYPING CURSOR */
  @keyframes typing-cursor {
    0%, 100% { border-right-color: var(--green); }
    50% { border-right-color: transparent; }
  }

  /* AUDIO WAVE */
  .audio-wave {
    width: 100%;
    height: 100%;
  }

  /* SPECTRUM */
  .spectrum-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    gap: 2px;
    padding: 4px;
  }

  .spectrum-row {
    display: flex;
    gap: 1px;
    flex: 1;
  }

  .spectrum-cell {
    flex: 1;
    transition: background 0.15s;
    border-radius: 1px;
  }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson-client@3.1.0/dist/topojson-client.min.js"></script>
</head>
<body>
<canvas id="matrix-bg"></canvas>

<div id="boot-screen">
  <div id="boot-text"></div>
</div>

<div id="main-container" style="display:none;">
  <!-- TOP BAR -->
  <div id="top-bar">
    <div class="logo glitch-text">◆ N3XUS-C0R3 v6.66</div>
    <div class="top-menu">
      <div class="top-menu-item">FILE
        <div class="dropdown-menu">
          <div class="dropdown-item" onclick="notify('Importing neural dataset...')">Import Dataset</div>
          <div class="dropdown-item" onclick="notify('Exporting encrypted payload...')">Export Payload</div>
          <div class="dropdown-item" onclick="notify('Quantum tunnel established')">New Tunnel</div>
          <div class="dropdown-item" onclick="notify('Session archived to /dev/null')">Archive Session</div>
        </div>
      </div>
      <div class="top-menu-item">SCAN
        <div class="dropdown-menu">
          <div class="dropdown-item" onclick="runNetScan()">Network Sweep</div>
          <div class="dropdown-item" onclick="notify('Vulnerability scan initiated...')">Vuln Scanner</div>
          <div class="dropdown-item" onclick="notify('Port enumeration: 65535 ports...')">Port Enum</div>
          <div class="dropdown-item" onclick="notify('DNS recon in progress...')">DNS Recon</div>
        </div>
      </div>
      <div class="top-menu-item">TOOLS
        <div class="dropdown-menu">
          <div class="dropdown-item" onclick="notify('Packet sniffer active on eth0')">Packet Sniffer</div>
          <div class="dropdown-item" onclick="notify('Crypto miner deployed (jk)')">Hash Cracker</div>
          <div class="dropdown-item" onclick="notify('Decompiler loaded')">Decompiler</div>
          <div class="dropdown-item" onclick="spawnFloatingTerminal()">New Terminal</div>
        </div>
      </div>
      <div class="top-menu-item">VIEW
        <div class="dropdown-menu">
          <div class="dropdown-item" onclick="toggleNightVision()">Night Vision</div>
          <div class="dropdown-item" onclick="triggerGlitch()">Glitch Mode</div>
          <div class="dropdown-item" onclick="notify('Wireframe overlay active')">Wireframe</div>
          <div class="dropdown-item" onclick="resetLayout()">Reset Layout</div>
        </div>
      </div>
      <div class="top-menu-item">HACK
        <div class="dropdown-menu">
          <div class="dropdown-item" onclick="notify('ACCESS GRANTED', 'warn')">Bypass Auth</div>
          <div class="dropdown-item" onclick="notify('Injecting shellcode...', 'error')">Inject Payload</div>
          <div class="dropdown-item" onclick="notify('Firewall rules: iptables -F')">Drop Firewall</div>
          <div class="dropdown-item" onclick="hackTheGibson()">Hack The Gibson</div>
        </div>
      </div>
    </div>
    <div style="display:flex;align-items:center;gap:4px;font-size:9px;color:#00ff41;border-left:1px solid #003300;padding-left:10px;margin-left:2px;">
      <span style="color:#00ffff;letter-spacing:1px;font-size:8px;">RAIN</span>
      <input type="range" id="matrix-density" min="5" max="100" value="55" title="Column density / frequency"
        style="width:52px;accent-color:#00ff41;height:2px;cursor:pointer;-webkit-appearance:none;
        background:linear-gradient(90deg,#002200,#00ff41);border-radius:2px;outline:none;">
      <span id="matrix-density-val" style="min-width:20px;color:#00ffff;font-size:8px;">55%</span>
    </div>
    <div style="display:flex;align-items:center;gap:4px;font-size:9px;color:#00ff41;border-left:1px solid #001a00;padding-left:6px;">
      <span style="color:#00ffff;letter-spacing:1px;font-size:8px;">SIZE</span>
      <input type="range" id="matrix-fontscale" min="5" max="100" value="45" title="Glyph size"
        style="width:52px;accent-color:#00ff41;height:2px;cursor:pointer;-webkit-appearance:none;
        background:linear-gradient(90deg,#002200,#00ff41);border-radius:2px;outline:none;">
      <span id="matrix-fontscale-val" style="min-width:20px;color:#00ffff;font-size:8px;">45%</span>
    </div>
    <div class="top-bar-status">
      <div class="status-indicator"><div class="status-dot dot-green"></div>UPLINK</div>
      <div class="status-indicator"><div class="status-dot dot-cyan"></div>TOR x3</div>
      <div class="status-indicator"><div class="status-dot dot-amber"></div>PROXY</div>
      <div class="status-indicator"><div class="status-dot dot-red" style="animation-delay:0.5s"></div>ENCRYPT</div>
      <div id="clock" style="font-family:'Orbitron',sans-serif;font-size:11px;color:var(--cyan);"></div>
    </div>
  </div>

  <!-- WORKSPACE -->
  <div id="workspace">
    <!-- All panels injected by JS -->
  </div>

  <!-- BOTTOM BAR -->
  <div id="bottom-bar">
    <div class="section">
      <span style="color:var(--cyan)">CPU:</span>
      <div class="mini-progress"><div class="mini-progress-fill" id="cpu-bar" style="width:45%;background:var(--green);"></div></div>
      <span id="cpu-val">45%</span>
    </div>
    <div class="section">
      <span style="color:var(--cyan)">MEM:</span>
      <div class="mini-progress"><div class="mini-progress-fill" id="mem-bar" style="width:62%;background:var(--amber);"></div></div>
      <span id="mem-val">62%</span>
    </div>
    <div class="section">
      <span style="color:var(--cyan)">NET:</span>
      <span id="net-val" style="color:var(--green);">↑ 2.4MB/s ↓ 14.7MB/s</span>
    </div>
    <div class="section">
      <span style="color:var(--cyan)">NODES:</span>
      <span id="node-count">47</span>
    </div>
    <div class="section">
      <span style="color:var(--cyan)">THREADS:</span>
      <span id="thread-count">256</span>
    </div>
    <div class="section" style="margin-left:auto;">
      <span style="color:var(--purple)">▶ OPERATION BLACKOUT</span>
    </div>
    <div class="section">
      <span style="color:#004400;cursor:pointer;" onclick="toggleHelpOverlay()" title="Keyboard shortcuts">[?] KEYS</span>
    </div>
    <div class="section">
      <span id="uptime" style="color:var(--green);">00:00:00</span>
    </div>
  </div>
</div>

<!-- CONTEXT MENU -->
<div class="context-menu" id="context-menu">
  <div class="context-menu-item" onclick="notify('Trace route initiated')">Trace Route <span class="ctx-shortcut">Ctrl+T</span></div>
  <div class="context-menu-item" onclick="notify('Packet captured')">Capture Packet <span class="ctx-shortcut">Ctrl+P</span></div>
  <div class="context-menu-sep"></div>
  <div class="context-menu-item" onclick="notify('Encrypting selection...')">Encrypt Selection <span class="ctx-shortcut">Ctrl+E</span></div>
  <div class="context-menu-item" onclick="notify('Decrypting...')">Decrypt <span class="ctx-shortcut">Ctrl+D</span></div>
  <div class="context-menu-sep"></div>
  <div class="context-menu-item" onclick="notify('Memory dump saved')">Dump Memory <span class="ctx-shortcut">Ctrl+M</span></div>
  <div class="context-menu-item" onclick="notify('Injecting...')">Inject Code <span class="ctx-shortcut">Ctrl+I</span></div>
  <div class="context-menu-sep"></div>
  <div class="context-menu-item" onclick="spawnFloatingTerminal()">New Terminal <span class="ctx-shortcut">Ctrl+N</span></div>
  <div class="context-menu-item" onclick="triggerGlitch()">Glitch <span class="ctx-shortcut">Ctrl+G</span></div>
</div>

<!-- SELECTION BOX -->
<div class="selection-box" id="selection-box"></div>

<!-- TOOLTIP -->
<div class="tooltip" id="tooltip"></div>

<script>
// ============================================================
// H4CK3R C0NS0L3 - THE MOST RIDICULOUS HOLLYWOOD THING EVER
// ============================================================

// --- UTILITY ---
const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);
const rand = (a, b) => Math.random() * (b - a) + a;
const randInt = (a, b) => Math.floor(rand(a, b));
const pick = arr => arr[randInt(0, arr.length)];
const hex = () => randInt(0, 256).toString(16).padStart(2, '0');
const hexWord = () => randInt(0, 65536).toString(16).padStart(4, '0');
const ipAddr = () => `${randInt(1,255)}.${randInt(0,255)}.${randInt(0,255)}.${randInt(1,255)}`;
const macAddr = () => Array.from({length:6}, () => hex()).join(':');
const uuid = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
  const r = Math.random() * 16 | 0; return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
});

// --- BOOT SEQUENCE ---
const bootLines = [
  'BIOS v3.31337 (C) N3XUS CORP 2025',
  'Checking quantum entanglement pairs... OK',
  'Neural coprocessor: ONLINE [8 cores @ 4.7THz]',
  'Initializing holographic RAM... 128PB detected',
  'Loading kernel: nexus-core-6.66.0-quantum-amd64',
  '  [  OK  ] Started Quantum Entropy Daemon',
  '  [  OK  ] Started Neural Network Inference Engine',
  '  [  OK  ] Started Dark Web Relay Service',
  '  [  OK  ] Started Encrypted Mesh Network',
  '  [  OK  ] Started AI Threat Detection Module',
  '  [ WARN ] Intrusion Detection: 47 probes blocked',
  '  [  OK  ] Started Zero-Day Exploit Scanner',
  'Establishing TOR circuit... 3 relays connected',
  'Proxy chain: SOCKS5 → VPN → TOR → SATELLITE',
  'Encryption: AES-4096-GCM + Quantum Key Exchange',
  '///////////////////////////////////////////\\\\',
  '  N 3 X U S - C 0 R 3    v 6 . 6 6',
  '  "There is no spoon."',
  '///////////////////////////////////////////\\\\',
  '',
  'SYSTEM READY. ACCESS LEVEL: ROOT [31337]',
  'Type "help" for command list.',
  ''
];

async function bootSequence() {
  const bootText = $('#boot-text');
  const bootScreen = $('#boot-screen');

  for (let i = 0; i < bootLines.length; i++) {
    const line = bootLines[i];
    const div = document.createElement('div');
    div.style.color = line.includes('WARN') ? 'var(--amber)' : line.includes('///') ? 'var(--cyan)' : 'var(--green)';
    div.style.textShadow = 'var(--glow)';
    bootText.appendChild(div);

    for (let j = 0; j < line.length; j++) {
      div.textContent += line[j];
      if (Math.random() > 0.85) await sleep(10);
    }
    div.textContent = line;

    if (i === bootLines.length - 1) {
      const cursor = document.createElement('span');
      cursor.className = 'blink-cursor';
      div.appendChild(cursor);
    }

    bootText.scrollTop = bootText.scrollHeight;
    await sleep(rand(20, 80));
  }

  await sleep(800);
  bootScreen.style.transition = 'opacity 0.8s';
  bootScreen.style.opacity = '0';
  await sleep(800);
  bootScreen.style.display = 'none';
  $('#main-container').style.display = 'flex';
  initAll();
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// --- MATRIX RAIN BACKGROUND ---
function initMatrix() {
  const canvas = $('#matrix-bg');

  // --- WebGL setup ---
  const gl = canvas.getContext('webgl', { alpha: true, premultipliedAlpha: false }) ||
             canvas.getContext('experimental-webgl', { alpha: true, premultipliedAlpha: false });
  if (!gl) { console.warn('WebGL not available for matrix rain'); return; }

  // --- Build glyph atlas texture from canvas ---
  // Render katakana + half-width kana + digits into a sprite sheet
  const GLYPH_CHARS = 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲンABCDEF0123456789ﾊﾐﾋｰｳｼﾅﾓﾆｻﾜﾂｵﾘｱﾎﾃﾏｹﾒｴｶｷﾑﾕﾗｾﾈｽ';
  const GLYPH_SIZE = 32;
  const ATLAS_COLS = 16;
  const ATLAS_ROWS = Math.ceil(GLYPH_CHARS.length / ATLAS_COLS);
  const atlasCanvas = document.createElement('canvas');
  atlasCanvas.width = ATLAS_COLS * GLYPH_SIZE;
  atlasCanvas.height = ATLAS_ROWS * GLYPH_SIZE;
  const actx = atlasCanvas.getContext('2d');
  actx.fillStyle = '#000';
  actx.fillRect(0, 0, atlasCanvas.width, atlasCanvas.height);
  actx.fillStyle = '#fff';
  actx.font = `${GLYPH_SIZE * 0.75}px monospace`;
  actx.textAlign = 'center';
  actx.textBaseline = 'middle';
  for (let i = 0; i < GLYPH_CHARS.length; i++) {
    const col = i % ATLAS_COLS;
    const row = Math.floor(i / ATLAS_COLS);
    actx.fillText(GLYPH_CHARS[i], col * GLYPH_SIZE + GLYPH_SIZE / 2, row * GLYPH_SIZE + GLYPH_SIZE / 2);
  }

  // Upload atlas as WebGL texture
  const atlasTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, atlasTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, atlasCanvas);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  // --- Create column data texture ---
  // Each column gets: speed, offset, brightness variation, character cycling speed
  const NUM_COLS = 128;
  const colData = new Float32Array(NUM_COLS * 4);
  for (let i = 0; i < NUM_COLS; i++) {
    colData[i * 4 + 0] = 0.3 + Math.random() * 1.2;   // speed
    colData[i * 4 + 1] = Math.random() * 100.0;        // time offset (randomizes start)
    colData[i * 4 + 2] = 0.4 + Math.random() * 0.6;   // brightness multiplier
    colData[i * 4 + 3] = 0.5 + Math.random() * 2.0;   // char cycle speed
  }

  // Pack into a texture (NUM_COLS x 1, RGBA float via UNSIGNED_BYTE encoding)
  // We'll pass as a uniform array instead for simplicity
  // Actually, let's use the shader's built-in hash for per-column randomness - more elegant

  // --- Shaders ---
  const vertSrc = `
    attribute vec2 aPosition;
    varying vec2 vUv;
    void main() {
      vUv = aPosition * 0.5 + 0.5;
      gl_Position = vec4(aPosition, 0.0, 1.0);
    }
  `;

  const fragSrc = `
    precision highp float;
    varying vec2 vUv;
    uniform float uTime;
    uniform vec2 uResolution;
    uniform sampler2D uAtlas;
    uniform float uAtlasCols;
    uniform float uAtlasRows;
    uniform float uNumGlyphs;
    uniform float uDensity;
    uniform float uFontScale;

    // Hash functions for pseudo-random per-column values
    float hash(float n) { return fract(sin(n) * 43758.5453123); }
    float hash2(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }

    void main() {
      // --- Font size: independent control ---
      // uFontScale 0.0..1.0 → cellSize 6..24 pixels
      float cellSize = mix(6.0, 24.0, uFontScale);
      vec2 pixelPos = vUv * uResolution;

      float col = floor(pixelPos.x / cellSize);
      float totalCols = floor(uResolution.x / cellSize);
      float totalRows = floor(uResolution.y / cellSize);
      // Flip row so row 0 is at the TOP (WebGL UV y=0 is bottom)
      float row = totalRows - floor(pixelPos.y / cellSize);

      // --- Column frequency: layered streams ---
      // More layers = more overlapping streams at each column.
      // Layer count: 1 at low density, up to 4 at max density.
      int numLayers = 1;
      if (uDensity > 0.35) numLayers = 2;
      if (uDensity > 0.60) numLayers = 3;
      if (uDensity > 0.80) numLayers = 4;

      // Also skip columns at low densities for sparseness
      float skipThreshold = smoothstep(0.0, 0.4, uDensity);

      float finalAlpha = 0.0;
      vec3 finalColor = vec3(0.0);

      for (int layer = 0; layer < 4; layer++) {
        if (layer >= numLayers) break;

        float layerF = float(layer);

        // Each layer offsets the column seed so streams are independent
        float colSeed = col + 0.5 + layerF * 137.0;

        // Column skip check (different per layer so layers don't all share gaps)
        float colActive = hash(colSeed * 7.77 + layerF * 3.33);
        if (colActive > skipThreshold) continue;

        float speed      = 0.3 + hash(colSeed * 1.17) * 1.4;
        float offset     = hash(colSeed * 2.31) * 80.0;
        float brightness = 0.7 + hash(colSeed * 3.47) * 0.3;
        float cycleSpeed = 1.0 + hash(colSeed * 4.59) * 3.0;
        float trailLen   = 15.0 + hash(colSeed * 5.73) * 25.0;
        float depth      = 0.5 + hash(colSeed * 6.11) * 0.5;

        // Deeper layers are slightly dimmer
        float layerDim = 1.0 - layerF * 0.15;

        float headPos = mod(uTime * speed + offset, totalRows + trailLen + 8.0);
        float distFromHead = headPos - row;

        // Trail fade
        float trail = 0.0;
        if (distFromHead >= 0.0 && distFromHead < trailLen) {
          trail = 1.0 - (distFromHead / trailLen);
          trail = pow(trail, 1.5);
        }

        // Head glow
        float headGlow = 0.0;
        if (distFromHead >= 0.0 && distFromHead < 2.5) {
          headGlow = 1.0 - distFromHead / 2.5;
          headGlow = headGlow * headGlow;
        }

        if (trail <= 0.0 && headGlow <= 0.0) continue;

        // Character selection: unique per layer
        float charIndex = mod(
          floor(hash2(vec2(colSeed, row)) * uNumGlyphs + uTime * cycleSpeed),
          uNumGlyphs
        );
        // Head chars change faster for that "decoding" effect
        if (distFromHead >= 0.0 && distFromHead < 3.0) {
          charIndex = mod(floor(hash(colSeed * 17.0 + row * 31.0 + uTime * 12.0) * uNumGlyphs), uNumGlyphs);
        }

        // UV into the glyph atlas
        float glyphCol = mod(charIndex, uAtlasCols);
        float glyphRow = floor(charIndex / uAtlasCols);

        vec2 cellUv = fract(pixelPos / cellSize);
        cellUv.y = 1.0 - cellUv.y;
        cellUv = cellUv * 0.85 + 0.075;

        vec2 atlasUv = vec2(
          (glyphCol + cellUv.x) / uAtlasCols,
          (glyphRow + cellUv.y) / uAtlasRows
        );

        float glyphAlpha = texture2D(uAtlas, atlasUv).r;

        // Combine: trail × glyph × brightness × depth × layer dimming
        float alpha = trail * glyphAlpha * brightness * depth * layerDim;

        // Color: rich deep green base, whiter/brighter at the head
        vec3 green = vec3(0.05, 0.85, 0.15);
        vec3 brightGreen = vec3(0.2, 1.0, 0.3);
        vec3 white = vec3(0.75, 1.0, 0.85);
        vec3 color = mix(green, brightGreen, trail * 0.5);
        color = mix(color, white, headGlow * 0.9);

        alpha += headGlow * glyphAlpha * 1.0 * layerDim;

        // Flash
        float flashPhase = sin(uTime * 0.3 + colSeed * 0.7);
        if (flashPhase > 0.95) {
          alpha *= 1.8;
          color = mix(color, white, 0.4);
        }

        // Composite layer using additive-ish blend (screen-like)
        finalColor = finalColor + color * alpha * (1.0 - finalAlpha);
        finalAlpha = finalAlpha + alpha * (1.0 - finalAlpha);

      } // end layer loop

      // Subtle scanline darkening on even rows
      float scanline = 0.92 + 0.08 * mod(row, 2.0);
      finalAlpha *= scanline;
      finalColor *= scanline;

      // Final boost
      finalAlpha *= 1.4;
      finalColor *= 1.4;

      gl_FragColor = vec4(finalColor, finalAlpha);
    }
  `;

  // --- Compile shaders ---
  function compileShader(src, type) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      console.error('Shader compile error:', gl.getShaderInfoLog(s));
      return null;
    }
    return s;
  }

  const vertShader = compileShader(vertSrc, gl.VERTEX_SHADER);
  const fragShader = compileShader(fragSrc, gl.FRAGMENT_SHADER);
  const program = gl.createProgram();
  gl.attachShader(program, vertShader);
  gl.attachShader(program, fragShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
    return;
  }
  gl.useProgram(program);

  // --- Full-screen quad ---
  const quad = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
  const aPos = gl.getAttribLocation(program, 'aPosition');
  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

  // --- Uniforms ---
  const uTime = gl.getUniformLocation(program, 'uTime');
  const uRes = gl.getUniformLocation(program, 'uResolution');
  const uAtlas = gl.getUniformLocation(program, 'uAtlas');
  const uAtlasCols = gl.getUniformLocation(program, 'uAtlasCols');
  const uAtlasRows = gl.getUniformLocation(program, 'uAtlasRows');
  const uNumGlyphs = gl.getUniformLocation(program, 'uNumGlyphs');
  const uDensityLoc = gl.getUniformLocation(program, 'uDensity');
  const uFontScaleLoc = gl.getUniformLocation(program, 'uFontScale');

  gl.uniform1i(uAtlas, 0);
  gl.uniform1f(uAtlasCols, ATLAS_COLS);
  gl.uniform1f(uAtlasRows, ATLAS_ROWS);
  gl.uniform1f(uNumGlyphs, GLYPH_CHARS.length);

  // Density: 0.0 = sparse, 1.0 = max streams (4 layers, all columns)
  let matrixDensity = 0.55;
  // Font scale: 0.0 = tiny (6px), 1.0 = large (24px)
  let matrixFontScale = 0.45;
  gl.uniform1f(uDensityLoc, matrixDensity);
  gl.uniform1f(uFontScaleLoc, matrixFontScale);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, atlasTexture);

  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

  // --- Resize handling ---
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
  }
  resize();
  window.addEventListener('resize', resize);

  // Expose setters for the UI sliders
  window.setMatrixDensity = function(v) { matrixDensity = v; };
  window.setMatrixFontScale = function(v) { matrixFontScale = v; };

  // --- Render loop ---
  const startTime = Date.now();
  function draw() {
    const t = (Date.now() - startTime) / 1000.0;
    gl.uniform1f(uTime, t);
    gl.uniform1f(uDensityLoc, matrixDensity);
    gl.uniform1f(uFontScaleLoc, matrixFontScale);
    gl.uniform2f(uRes, canvas.width, canvas.height);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(draw);
  }
  draw();
}

// --- PANEL MANAGEMENT ---
let panelZIndex = 10;
let panels = [];

function createPanel(config) {
  const panel = document.createElement('div');
  panel.className = 'panel';
  panel.id = config.id || 'panel-' + Date.now();
  panel.style.left = config.x + 'px';
  panel.style.top = config.y + 'px';
  panel.style.width = config.w + 'px';
  panel.style.height = config.h + 'px';

  const header = document.createElement('div');
  header.className = 'panel-header';
  header.innerHTML = `
    <span class="title">${config.title}</span>
    <div class="controls">
      <div class="ctrl-btn ctrl-min"></div>
      <div class="ctrl-btn ctrl-max"></div>
      <div class="ctrl-btn ctrl-close"></div>
    </div>
  `;

  let tabs = '';
  if (config.tabs) {
    const tabsDiv = document.createElement('div');
    tabsDiv.className = 'panel-tabs';
    config.tabs.forEach((t, i) => {
      const tab = document.createElement('div');
      tab.className = 'panel-tab' + (i === 0 ? ' active' : '');
      tab.textContent = t;
      tab.onclick = (e) => {
        tabsDiv.querySelectorAll('.panel-tab').forEach(x => x.classList.remove('active'));
        tab.classList.add('active');
        notify(`Switched to ${t}`);
      };
      tabsDiv.appendChild(tab);
    });
    tabs = tabsDiv;
  }

  const body = document.createElement('div');
  body.className = 'panel-body';

  const resize = document.createElement('div');
  resize.className = 'resize-handle';

  panel.appendChild(header);
  if (tabs) panel.appendChild(tabs);
  panel.appendChild(body);
  panel.appendChild(resize);

  // Drag
  let isDragging = false, dragX, dragY;
  header.addEventListener('mousedown', e => {
    if (e.target.classList.contains('ctrl-btn')) return;
    isDragging = true;
    dragX = e.clientX - panel.offsetLeft;
    dragY = e.clientY - panel.offsetTop;
    panel.style.zIndex = ++panelZIndex;
    panels.forEach(p => p.el.classList.remove('focused'));
    panel.classList.add('focused');
  });

  document.addEventListener('mousemove', e => {
    if (!isDragging) return;
    panel.style.left = (e.clientX - dragX) + 'px';
    panel.style.top = (e.clientY - dragY) + 'px';
  });

  document.addEventListener('mouseup', () => { isDragging = false; });

  // Resize
  let isResizing = false, rStartX, rStartY, rStartW, rStartH;
  resize.addEventListener('mousedown', e => {
    isResizing = true;
    rStartX = e.clientX;
    rStartY = e.clientY;
    rStartW = panel.offsetWidth;
    rStartH = panel.offsetHeight;
    e.stopPropagation();
  });

  document.addEventListener('mousemove', e => {
    if (!isResizing) return;
    panel.style.width = Math.max(150, rStartW + e.clientX - rStartX) + 'px';
    panel.style.height = Math.max(100, rStartH + e.clientY - rStartY) + 'px';
  });

  document.addEventListener('mouseup', () => { isResizing = false; });

  // Focus on click
  panel.addEventListener('mousedown', () => {
    panel.style.zIndex = ++panelZIndex;
    panels.forEach(p => p.el.classList.remove('focused'));
    panel.classList.add('focused');
  });

  // Close
  header.querySelector('.ctrl-close').addEventListener('click', () => {
    panel.style.transition = 'opacity 0.3s, transform 0.3s';
    panel.style.opacity = '0';
    panel.style.transform = 'scale(0.9)';
    setTimeout(() => panel.remove(), 300);
  });

  // Maximize
  let isMaximized = false, prevBounds;
  header.querySelector('.ctrl-max').addEventListener('click', () => {
    if (!isMaximized) {
      prevBounds = { left: panel.style.left, top: panel.style.top, width: panel.style.width, height: panel.style.height };
      const ws = $('#workspace');
      panel.style.left = '0px'; panel.style.top = '0px';
      panel.style.width = ws.offsetWidth + 'px';
      panel.style.height = ws.offsetHeight + 'px';
    } else {
      Object.assign(panel.style, prevBounds);
    }
    isMaximized = !isMaximized;
  });

  // Minimize
  header.querySelector('.ctrl-min').addEventListener('click', () => {
    body.style.display = body.style.display === 'none' ? '' : 'none';
    if (tabs) tabs.style.display = tabs.style.display === 'none' ? '' : 'none';
    resize.style.display = resize.style.display === 'none' ? '' : 'none';
    if (body.style.display === 'none') {
      panel.style.height = '24px';
    } else {
      panel.style.height = config.h + 'px';
    }
  });

  $('#workspace').appendChild(panel);
  const pObj = { el: panel, body, config, id: panel.id };
  panels.push(pObj);
  return pObj;
}

// --- TERMINAL ---
const terminalCommands = {
  help: () => [
    { text: 'Available commands:', cls: 'term-cyan' },
    { text: '  help          - Show this message', cls: 'term-info' },
    { text: '  scan <target> - Scan target system', cls: 'term-info' },
    { text: '  exploit       - Run exploit framework', cls: 'term-info' },
    { text: '  decrypt       - Decrypt intercepted data', cls: 'term-info' },
    { text: '  trace         - Trace network route', cls: 'term-info' },
    { text: '  dump          - Dump memory contents', cls: 'term-info' },
    { text: '  connect       - Connect to remote node', cls: 'term-info' },
    { text: '  status        - System status', cls: 'term-info' },
    { text: '  hack          - You know what this does', cls: 'term-purple' },
    { text: '  clear         - Clear terminal', cls: 'term-info' },
  ],
  scan: () => {
    const results = [];
    results.push({ text: `Scanning subnet ${randInt(10,192)}.${randInt(0,255)}.${randInt(0,255)}.0/24...`, cls: 'term-info' });
    const count = randInt(5, 15);
    for (let i = 0; i < count; i++) {
      const ports = Array.from({length: randInt(1,5)}, () => pick([22,80,443,3306,5432,8080,8443,27017,6379,9200]));
      results.push({ text: `  [+] ${ipAddr()} - Ports: ${ports.join(', ')} - ${pick(['Linux','Windows','FreeBSD','RouterOS'])}`, cls: Math.random()>0.7 ? 'term-warn' : 'term-info' });
    }
    results.push({ text: `Scan complete. ${count} hosts found.`, cls: 'term-blue' });
    return results;
  },
  exploit: () => [
    { text: 'Loading exploit framework v4.2.0...', cls: 'term-info' },
    { text: `[*] Target: ${ipAddr()}`, cls: 'term-info' },
    { text: '[*] Payload: reverse_tcp_quantum_shell', cls: 'term-info' },
    { text: '[*] Encoder: polymorphic/shikata_ga_nai', cls: 'term-warn' },
    { text: `[+] Exploit sent (${randInt(200,2000)} bytes)`, cls: 'term-info' },
    { text: `[+] ${Math.random()>0.3 ? 'Session opened!' : 'Exploit failed - target patched'}`, cls: Math.random()>0.3 ? 'term-info' : 'term-error' },
  ],
  decrypt: () => {
    const lines = [{ text: 'Decrypting intercepted transmission...', cls: 'term-info' }];
    for (let i = 0; i < 3; i++) {
      lines.push({ text: `  Block ${i}: ${Array.from({length:8}, hexWord).join(' ')}`, cls: 'term-warn' });
    }
    lines.push({ text: pick([
      'Decrypted: "The eagle has left the building"',
      'Decrypted: "Rendezvous at coordinates 41.40338, 2.17403"',
      'Decrypted: "Operation BLACKOUT is a go"',
      'Decrypted: "All your base are belong to us"',
      'Decrypted: "The cake is a lie"',
      'Decrypted: "HACK THE PLANET"',
    ]), cls: 'term-purple' });
    return lines;
  },
  trace: () => {
    const lines = [{ text: `Tracing route to ${ipAddr()}...`, cls: 'term-info' }];
    const hops = randInt(8, 16);
    for (let i = 1; i <= hops; i++) {
      lines.push({ text: `  ${i.toString().padStart(2)}  ${ipAddr()}  ${randInt(1,200)}ms ${i===hops ? '*** TARGET REACHED ***' : ''}`, cls: i===hops ? 'term-purple' : 'term-info' });
    }
    return lines;
  },
  dump: () => {
    const lines = [{ text: 'Memory dump @ 0x' + Array.from({length:4}, hex).join(''), cls: 'term-info' }];
    for (let i = 0; i < 8; i++) {
      const addr = (0x7fff0000 + i * 16).toString(16);
      const bytes = Array.from({length:16}, () => hex()).join(' ');
      const ascii = Array.from({length:16}, () => String.fromCharCode(randInt(33, 126))).join('');
      lines.push({ text: `  ${addr}: ${bytes}  |${ascii}|`, cls: 'term-info' });
    }
    return lines;
  },
  connect: () => {
    const ip = ipAddr();
    return [
      { text: `Connecting to ${ip}:${pick([22,443,8080])}...`, cls: 'term-info' },
      { text: 'SSH-2.0-OpenSSH_8.9 Quantum Edition', cls: 'term-info' },
      { text: `Authenticating with RSA-4096 key...`, cls: 'term-warn' },
      { text: `Welcome to ${pick(['darknode','shadowbox','ghostserver','blacksite'])}-${randInt(1,99)}`, cls: 'term-purple' },
      { text: `root@${ip}:~# `, cls: 'term-info' },
    ];
  },
  status: () => [
    { text: '=== SYSTEM STATUS ===', cls: 'term-cyan' },
    { text: `  CPU: ${randInt(30,95)}% | Cores: 8 | Freq: ${(rand(3.5,5.2)).toFixed(1)} THz`, cls: 'term-info' },
    { text: `  RAM: ${randInt(40,90)}% | ${randInt(50,100)}PB / 128PB`, cls: 'term-info' },
    { text: `  NET: ↑${(rand(1,50)).toFixed(1)}MB/s ↓${(rand(5,200)).toFixed(1)}MB/s`, cls: 'term-info' },
    { text: `  TOR: ${randInt(3,7)} relays | Latency: ${randInt(50,300)}ms`, cls: 'term-info' },
    { text: `  Active sessions: ${randInt(5,30)}`, cls: 'term-info' },
    { text: `  Threats blocked: ${randInt(100,9999)}`, cls: 'term-warn' },
  ],
  hack: () => [
    { text: '> INITIATING HACK SEQUENCE', cls: 'term-error' },
    { text: '> ...', cls: 'term-info' },
    { text: `> ACCESS GRANTED. Welcome, ${pick(['Neo','Trinity','Morpheus','Zero Cool','Crash Override','Acid Burn','The Plague','L0rd N1k0n','Zer0 C00l','c3r34lk1ll3r'])}`, cls: 'term-purple' },
  ],
  clear: () => 'CLEAR',
};

function createTerminal(body) {
  const output = document.createElement('div');
  output.className = 'terminal-output';
  output.innerHTML = `<div class="term-line term-cyan">root@nexus-core:~# Welcome to N3XUS Terminal</div>`;

  const inputLine = document.createElement('div');
  inputLine.className = 'term-input-line';
  inputLine.innerHTML = `<span>root@nexus:~# </span>`;
  const input = document.createElement('input');
  input.className = 'term-input';
  input.spellcheck = false;
  inputLine.appendChild(input);

  body.style.display = 'flex';
  body.style.flexDirection = 'column';
  body.appendChild(output);
  body.appendChild(inputLine);

  input.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      const cmd = input.value.trim().toLowerCase();
      addTermLine(output, `root@nexus:~# ${input.value}`, 'term-prompt');
      input.value = '';

      if (cmd === '') return;

      const basecmd = cmd.split(' ')[0];
      if (terminalCommands[basecmd]) {
        const result = terminalCommands[basecmd]();
        if (result === 'CLEAR') {
          output.innerHTML = '';
          return;
        }
        result.forEach(l => addTermLine(output, l.text, l.cls));
      } else {
        addTermLine(output, `bash: ${basecmd}: command not found. Try 'help'`, 'term-error');
      }
    }
  });

  input.focus();
  body.addEventListener('click', () => input.focus());
  return { output, input };
}

function addTermLine(container, text, cls) {
  const line = document.createElement('div');
  line.className = `term-line ${cls || ''}`;
  line.textContent = text;
  container.appendChild(line);
  container.scrollTop = container.scrollHeight;
}

// --- LIVE LOG FEED ---
function createLogFeed(body) {
  const output = document.createElement('div');
  output.className = 'terminal-output';
  body.appendChild(output);

  const logTypes = [
    () => ({ text: `[${timestamp()}] INFO  Connection from ${ipAddr()}:${randInt(1024,65535)}`, cls: 'term-info' }),
    () => ({ text: `[${timestamp()}] WARN  Brute force detected: ${ipAddr()} (attempt ${randInt(1,999)})`, cls: 'term-warn' }),
    () => ({ text: `[${timestamp()}] ERROR Segfault at 0x${Array.from({length:4},hex).join('')}`, cls: 'term-error' }),
    () => ({ text: `[${timestamp()}] INFO  Packet intercepted: ${randInt(64,1500)} bytes from ${ipAddr()}`, cls: 'term-info' }),
    () => ({ text: `[${timestamp()}] DEBUG Auth token: ${uuid().substring(0,8)}...`, cls: 'term-blue' }),
    () => ({ text: `[${timestamp()}] WARN  SSL cert mismatch on ${pick(['api','cdn','auth','db'])}.${pick(['shadow','dark','black','ghost'])}.net`, cls: 'term-warn' }),
    () => ({ text: `[${timestamp()}] INFO  Encrypted tunnel ${randInt(1,99)} active: ${randInt(100,9999)} packets`, cls: 'term-info' }),
    () => ({ text: `[${timestamp()}] CRIT  Intrusion attempt from ${ipAddr()} - BLOCKED`, cls: 'term-error' }),
    () => ({ text: `[${timestamp()}] INFO  DNS query: ${pick(['mx','ns','a','aaaa','cname'])}.${pick(['target','evil','shadow'])}.${pick(['com','net','onion'])}`, cls: 'term-info' }),
    () => ({ text: `[${timestamp()}] DEBUG Decrypted payload: ${randInt(1,500)}KB [${pick(['AES-256','ChaCha20','Quantum'])}]`, cls: 'term-purple' }),
  ];

  function addLog() {
    if (!document.body.contains(output)) return;
    const log = pick(logTypes)();
    addTermLine(output, log.text, log.cls);
    if (output.children.length > 200) output.removeChild(output.firstChild);
    setTimeout(addLog, rand(100, 800));
  }
  addLog();
}

function timestamp() {
  const d = new Date();
  return d.toTimeString().split(' ')[0] + '.' + d.getMilliseconds().toString().padStart(3, '0');
}

// ============================================================
// WEBGL PANEL HELPER — reusable full-screen-quad shader runner
// ============================================================
function createGLPanel(body, fragSrc, opts = {}) {
  const canvas = document.createElement('canvas');
  canvas.className = 'graph-canvas';
  body.appendChild(canvas);

  const gl = canvas.getContext('webgl', { alpha: true, premultipliedAlpha: false, antialias: false }) ||
             canvas.getContext('experimental-webgl', { alpha: true, premultipliedAlpha: false });
  if (!gl) { console.warn('WebGL unavailable for panel'); return null; }

  const vertSrc = `attribute vec2 a;varying vec2 v;void main(){v=a*.5+.5;gl_Position=vec4(a,0,1);}`;

  function compile(src, type) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      console.error('Shader error:', gl.getShaderInfoLog(s), src.split('\\n').slice(0,5));
      return null;
    }
    return s;
  }
  const vs = compile(vertSrc, gl.VERTEX_SHADER);
  const fs = compile(fragSrc, gl.FRAGMENT_SHADER);
  if (!vs || !fs) return null;
  const prog = gl.createProgram();
  gl.attachShader(prog, vs); gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
    console.error('Link error:', gl.getProgramInfoLog(prog)); return null;
  }
  gl.useProgram(prog);

  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
  const a = gl.getAttribLocation(prog, 'a');
  gl.enableVertexAttribArray(a);
  gl.vertexAttribPointer(a, 2, gl.FLOAT, false, 0, 0);

  const uTime = gl.getUniformLocation(prog, 'T');
  const uRes = gl.getUniformLocation(prog, 'R');

  // Extra uniforms
  const extraLocs = {};
  if (opts.uniforms) {
    for (const name of opts.uniforms) {
      extraLocs[name] = gl.getUniformLocation(prog, name);
    }
  }

  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

  const t0 = Date.now();
  function frame() {
    if (!document.body.contains(canvas)) return;
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    if (w === 0 || h === 0) { requestAnimationFrame(frame); return; }
    canvas.width = w; canvas.height = h;
    gl.viewport(0, 0, w, h);
    gl.useProgram(prog);
    gl.uniform1f(uTime, (Date.now() - t0) / 1000.0);
    gl.uniform2f(uRes, w, h);
    if (opts.onFrame) opts.onFrame(gl, extraLocs);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(frame);
  }
  frame();
  return { canvas, gl, prog, extraLocs };
}

// --- NETWORK GRAPH (WebGL) ---
function createNetworkGraph(body) {
  // 20 procedural nodes with edges — all in shader
  createGLPanel(body, `
    precision highp float;
    varying vec2 v;
    uniform float T;
    uniform vec2 R;
    float hash(float n){return fract(sin(n)*43758.5453);}
    vec2 nodePos(float id){
      // Drifting node positions
      float s=hash(id*1.17)*0.5+0.3;
      return vec2(
        0.1+hash(id*2.31)*0.8+sin(T*s*0.3+id*3.0)*0.06,
        0.1+hash(id*3.47)*0.8+cos(T*s*0.25+id*5.0)*0.06
      );
    }
    vec3 nodeColor(float id){
      float h=hash(id*4.59);
      if(h<0.3) return vec3(0.0,1.0,0.25);  // green
      if(h<0.5) return vec3(0.0,1.0,1.0);    // cyan
      if(h<0.7) return vec3(1.0,0.75,0.0);   // amber
      if(h<0.85) return vec3(1.0,0.0,0.25);  // red
      return vec3(0.75,0.0,1.0);              // purple
    }
    void main(){
      vec2 uv=v;
      float aspect=R.x/R.y;
      vec2 auv=uv*vec2(aspect,1.0);
      float px=1.0/R.y;
      vec3 col=vec3(0.0);
      float N=20.0;
      // Edges (draw first, underneath)
      for(int i=0;i<20;i++){
        float fi=float(i);
        vec2 a=nodePos(fi)*vec2(aspect,1.0);
        // Connect to 1-2 other nodes
        for(int j=0;j<2;j++){
          float target=mod(fi+1.0+float(j)*7.0,N);
          vec2 b=nodePos(target)*vec2(aspect,1.0);
          // Distance from point to line segment
          vec2 pa=auv-a,ba=b-a;
          float t=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);
          float d=length(pa-ba*t);
          float op=hash(fi*5.0+float(j)*3.0)*0.3;
          col+=vec3(0.0,1.0,0.25)*op*smoothstep(1.5*px,0.0,d);
          // Packet traveling along edge
          float pktT=fract(T*0.4+hash(fi*7.0+float(j)*11.0));
          vec2 pktPos=mix(a,b,pktT);
          float pktD=length(auv-pktPos);
          col+=vec3(0.0,1.0,1.0)*0.6*smoothstep(3.0*px,0.0,pktD);
        }
      }
      // Nodes
      for(int i=0;i<20;i++){
        float fi=float(i);
        vec2 np=nodePos(fi)*vec2(aspect,1.0);
        float d=length(auv-np);
        float r=(0.006+hash(fi*6.11)*0.008)*(1.0+sin(T*2.0+hash(fi)*6.28)*0.3);
        vec3 nc=nodeColor(fi);
        // Glow
        col+=nc*0.1*smoothstep(r+0.03,r,d);
        // Node body
        col+=nc*smoothstep(r+px,r-px,d);
      }
      gl_FragColor=vec4(col,1.0);
    }
  `);
}

// --- GRAPHIC EQ (WebGL) ---
function createEQ(body) {
  createGLPanel(body, `
    precision highp float;
    varying vec2 v;
    uniform float T;
    uniform vec2 R;
    float hash(float n){return fract(sin(n)*43758.5453);}
    void main(){
      vec2 uv=v;
      float px=1.0/R.y;
      float pxX=1.0/R.x;
      vec3 col=vec3(0.0);
      float numBars=48.0;
      float gap=2.0/R.x;
      float totalW=1.0;
      float barW=(totalW-gap*(numBars-1.0))/numBars;
      float idx=floor(uv.x/(barW+gap));
      float localX=uv.x-idx*(barW+gap);
      if(idx>=0.0 && idx<numBars && localX<barW && localX>0.0){
        float fi=idx;
        // Animated height matching original: abs(sin)*0.6+abs(sin)*0.3+random*0.1
        float h=abs(sin(T*3.0+fi*0.3))*0.6
               +abs(sin(T*7.0+fi*0.5))*0.3
               +hash(fi+floor(T*12.0))*0.1;
        h=clamp(h,0.02,0.98);
        if(uv.y<h){
          float gradT=uv.y/h;
          // Gradient: green(bottom) → cyan(mid) → red(top)
          vec3 barCol;
          if(gradT<0.5){
            barCol=mix(vec3(0.0,1.0,0.25),vec3(0.0,1.0,1.0),gradT*2.0);
          }else{
            barCol=mix(vec3(0.0,1.0,1.0),vec3(1.0,0.0,0.25),(gradT-0.5)*2.0);
          }
          col=barCol*0.85;
          // Slight glow at the top of each bar
          col+=barCol*0.3*smoothstep(4.0*px,0.0,abs(uv.y-h));
          // Rounded top cap
          col*=smoothstep(0.0,2.0*px,h-uv.y+1.5*px);
        }
        // Bright top edge glow even above bar
        float fi2=idx;
        float h2=abs(sin(T*3.0+fi2*0.3))*0.6
                +abs(sin(T*7.0+fi2*0.5))*0.3
                +hash(fi2+floor(T*12.0))*0.1;
        h2=clamp(h2,0.02,0.98);
        col+=vec3(1.0,1.0,1.0)*0.15*smoothstep(3.0*px,0.0,abs(uv.y-h2));
      }
      gl_FragColor=vec4(col,1.0);
    }
  `);
}

// --- WAVEFORM (WebGL) ---
function createWaveform(body) {
  createGLPanel(body, `
    precision highp float;
    varying vec2 v;
    uniform float T;
    uniform vec2 R;
    void main(){
      vec2 uv=v; float px=1.0/R.y;
      // Grid
      vec2 g=mod(uv*R,20.0);
      float grid=step(g.x,1.0)+step(g.y,1.0);
      vec3 col=vec3(0.0,0.27,0.0)*grid*0.3;
      // Center line
      col+=vec3(0.0,0.27,0.0)*0.6*smoothstep(1.5*px,0.0,abs(uv.y-0.5));
      // Waves
      float y=uv.y;
      // Wave 1: green
      float w1=0.5+sin(uv.x*6.28*3.0+T*3.0)*0.3+sin(uv.x*3.14*3.0+T*2.0)*0.15;
      col+=vec3(0.0,1.0,0.25)*0.8*smoothstep(2.5*px,0.0,abs(y-w1));
      // Wave 2: cyan
      float w2=0.5+sin(uv.x*6.28*5.0+T*5.0)*0.2+sin(uv.x*3.14*5.0+T*2.0)*0.1;
      col+=vec3(0.0,1.0,1.0)*0.6*smoothstep(2.0*px,0.0,abs(y-w2));
      // Wave 3: red
      float w3=0.5+sin(uv.x*6.28*8.0+T*8.0)*0.15+sin(uv.x*3.14*8.0+T*2.0)*0.075;
      col+=vec3(1.0,0.0,0.25)*0.4*smoothstep(1.5*px,0.0,abs(y-w3));
      // Wave 4: purple
      float w4=0.5+sin(uv.x*6.28*12.0+T*12.0)*0.1+sin(uv.x*3.14*12.0+T*2.0)*0.05;
      col+=vec3(0.75,0.0,1.0)*0.3*smoothstep(1.5*px,0.0,abs(y-w4));
      // Measurement crosshair
      float cx=0.5+0.3*sin(T*0.5);
      float dash=step(0.5,fract(uv.y*R.y/6.0));
      col+=vec3(1.0,0.75,0.0)*0.4*smoothstep(1.5*px,0.0,abs(uv.x-cx))*dash;
      gl_FragColor=vec4(col,1.0);
    }
  `);
}

// --- LIVE CHART (WebGL) ---
function createLiveChart(body, opts = {}) {
  createGLPanel(body, `
    precision highp float;
    varying vec2 v;
    uniform float T;
    uniform vec2 R;
    float hash(float n){return fract(sin(n)*43758.5453);}
    float noise(float x){float i=floor(x);float f=fract(x);return mix(hash(i),hash(i+1.0),f*f*(3.0-2.0*f));}
    float fbm(float x){return noise(x)*0.5+noise(x*2.0)*0.3+noise(x*4.0)*0.2;}
    void main(){
      vec2 uv=v; float px=1.0/R.y;
      vec3 col=vec3(0.0);
      // Grid
      float gy=step(mod(uv.y*5.0,1.0),0.005*5.0);
      col+=vec3(0.0,0.27,0.0)*gy*0.3;
      // 3 data lines: green, cyan, red — scrolling procedural noise
      float scroll=T*0.3;
      float x=uv.x*8.0+scroll;
      // Line 1: green throughput
      float v1=0.3+fbm(x*1.1+10.0)*0.5;
      float d1=uv.y-v1;
      col+=vec3(0.0,1.0,0.25)*0.9*smoothstep(2.5*px,0.0,abs(d1));
      col+=vec3(0.0,1.0,0.25)*0.05*smoothstep(0.0,0.001,d1)*smoothstep(d1,0.0,-0.3); // fill below
      // Line 2: cyan latency
      float v2=0.4+fbm(x*1.3+50.0)*0.4;
      float d2=uv.y-v2;
      col+=vec3(0.0,1.0,1.0)*0.7*smoothstep(2.0*px,0.0,abs(d2));
      col+=vec3(0.0,1.0,1.0)*0.04*smoothstep(0.0,0.001,d2)*smoothstep(d2,0.0,-0.3);
      // Line 3: red errors
      float v3=0.15+fbm(x*1.7+90.0)*0.25;
      float d3=uv.y-v3;
      col+=vec3(1.0,0.0,0.25)*0.5*smoothstep(2.0*px,0.0,abs(d3));
      col+=vec3(1.0,0.0,0.25)*0.03*smoothstep(0.0,0.001,d3)*smoothstep(d3,0.0,-0.2);
      gl_FragColor=vec4(col,1.0);
    }
  `);
}

// --- HEX DUMP ---
function createHexDump(body) {
  const container = document.createElement('div');
  container.className = 'hex-dump';
  body.appendChild(container);

  function updateHex() {
    if (!document.body.contains(container)) return;
    let html = '';
    const baseAddr = randInt(0x10000000, 0x7FFFFFFF);
    for (let i = 0; i < 30; i++) {
      const addr = (baseAddr + i * 16).toString(16).padStart(8, '0');
      const bytes = Array.from({length: 16}, () => hex());
      const ascii = bytes.map(b => {
        const c = parseInt(b, 16);
        return (c >= 32 && c <= 126) ? String.fromCharCode(c) : '.';
      }).join('');

      // Highlight some bytes randomly
      const highlighted = bytes.map(b =>
        Math.random() > 0.92 ? `<span style="color:var(--red)">${b}</span>` :
        Math.random() > 0.95 ? `<span style="color:var(--cyan)">${b}</span>` : b
      );

      html += `<span style="color:var(--cyan)">${addr}</span>  ${highlighted.join(' ')}  <span style="color:#666">${ascii}</span>\n`;
    }
    container.innerHTML = html;
    setTimeout(updateHex, 500);
  }
  updateHex();
}

// --- RADAR (WebGL) ---
function createRadar(body) {
  createGLPanel(body, `
    precision highp float;
    varying vec2 v;
    uniform float T;
    uniform vec2 R;
    float hash(float n){return fract(sin(n)*43758.5453);}
    #define PI 3.14159265
    #define TAU 6.28318530
    void main(){
      float aspect=R.x/R.y;
      vec2 uv=(v-0.5)*vec2(aspect,1.0);
      float dist=length(uv);
      float maxR=min(aspect,1.0)*0.5-0.05;
      float angle=atan(uv.y,uv.x);
      float px=1.0/R.y;
      vec3 col=vec3(0.0);
      // Rings
      for(int i=1;i<=4;i++){
        float r=maxR*float(i)/4.0;
        col+=vec3(0.0,1.0,0.25)*0.2*smoothstep(1.5*px,0.0,abs(dist-r));
      }
      // Cross
      float onDisk=step(dist,maxR);
      col+=vec3(0.0,1.0,0.25)*0.12*smoothstep(1.0*px,0.0,abs(uv.x))*onDisk;
      col+=vec3(0.0,1.0,0.25)*0.12*smoothstep(1.0*px,0.0,abs(uv.y))*onDisk;
      // Sweep
      float sweep=mod(T*0.8,TAU);
      float a=mod(angle-sweep+TAU,TAU);
      float sweepTrail=smoothstep(0.6,0.0,a)*0.2*step(dist,maxR);
      col+=vec3(0.0,1.0,0.25)*sweepTrail;
      // Sweep line
      float sweepLine=smoothstep(2.5*px,0.0,abs(a))*step(dist,maxR)*smoothstep(0.0,0.01,dist);
      col+=vec3(0.0,1.0,0.25)*0.8*sweepLine;
      // Blips (12 procedural)
      for(int i=0;i<12;i++){
        float fi=float(i);
        float ba=hash(fi*1.17)*TAU+sin(T*0.05+fi)*0.3;
        float bd=0.15+hash(fi*2.31)*0.7;
        vec2 bp=vec2(cos(ba),sin(ba))*bd*maxR;
        float bDist=length(uv-bp);
        // Fade from sweep
        float diff=mod(sweep-ba+TAU,TAU);
        float alpha=max(0.0,1.0-diff/(PI*1.5));
        bool threat=hash(fi*3.47)>0.7;
        vec3 bc=threat?vec3(1.0,0.0,0.25):vec3(0.0,1.0,0.25);
        col+=bc*alpha*smoothstep(4.0*px,0.0,bDist);
      }
      // Center dot
      col+=vec3(0.0,1.0,0.25)*smoothstep(3.0*px,0.0,dist);
      // Clip to disk
      col*=smoothstep(maxR+px,maxR-px,dist);
      gl_FragColor=vec4(col,1.0);
    }
  `);
}

// --- FAKE VIDEO FEED (WebGL) ---
function createVideoFeed(body, label) {
  const container = document.createElement('div');
  container.className = 'video-feed';

  const feedBody = document.createElement('div');
  feedBody.style.cssText = 'width:100%;height:100%;position:relative;';
  container.appendChild(feedBody);

  const overlay = document.createElement('div');
  overlay.className = 'video-overlay rec';
  overlay.textContent = `REC ${label || 'CAM-' + randInt(1,12)}`;
  container.appendChild(overlay);

  const overlay2 = document.createElement('div');
  overlay2.className = 'video-overlay';
  overlay2.style.cssText = 'bottom:4px;top:auto;right:4px;left:auto;color:var(--green);text-shadow:none;font-size:8px;';
  container.appendChild(overlay2);

  body.appendChild(container);

  // Update timestamp with DOM (cheap)
  setInterval(() => {
    if (!document.body.contains(overlay2)) return;
    overlay2.textContent = `${new Date().toISOString()} | ${randInt(24,30)}fps`;
  }, 500);

  createGLPanel(feedBody, `
    precision highp float;
    varying vec2 v;
    uniform float T;
    uniform vec2 R;
    float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
    void main(){
      vec2 uv=v;
      // Noise background (GPU noise — replaces CPU per-pixel loop)
      float n=hash(uv*R+T*100.0)*0.1;
      vec3 col=vec3(n*0.8,n+hash(uv*R+T*77.0)*0.04,n*0.8);
      // 3 thermal blobs
      for(int i=0;i<3;i++){
        float fi=float(i);
        vec2 bp=vec2(0.3+0.4*sin(T*0.3+fi*2.0),0.3+0.3*cos(T*0.2+fi*3.0));
        float d=length(uv-bp);
        float r=0.08+sin(T+fi)*0.03;
        float blob=smoothstep(r,0.0,d)*0.3;
        col+=vec3(0.0,blob,blob*0.4);
        // Target box
        vec2 diff=abs(uv-bp);
        float boxS=0.07;
        float px=1.0/R.y;
        float box=smoothstep(1.5*px,0.0,abs(diff.x-boxS))*step(diff.y,boxS)
                  +smoothstep(1.5*px,0.0,abs(diff.y-boxS))*step(diff.x,boxS);
        col+=vec3(1.0,0.0,0.25)*0.6*box;
      }
      // Crosshair
      float px=1.0/R.y;
      col+=vec3(0.0,1.0,1.0)*0.3*smoothstep(1.0*px,0.0,abs(uv.x-0.5));
      col+=vec3(0.0,1.0,1.0)*0.3*smoothstep(1.0*px,0.0,abs(uv.y-0.5));
      float cd=abs(length((uv-0.5)*vec2(R.x/R.y,1.0))-0.08);
      col+=vec3(0.0,1.0,1.0)*0.25*smoothstep(1.5*px,0.0,cd);
      // Scanline
      float scanY=fract(T*0.15);
      col+=vec3(0.0,1.0,0.25)*0.05*smoothstep(3.0*px,0.0,abs(uv.y-scanY));
      gl_FragColor=vec4(col,1.0);
    }
  `);
}

// --- DATA TABLE ---
function createDataTable(body) {
  const table = document.createElement('table');
  table.className = 'data-table';
  const thead = document.createElement('thead');
  thead.innerHTML = '<tr><th>IP</th><th>PORT</th><th>PROTO</th><th>STATUS</th><th>LATENCY</th><th>COUNTRY</th></tr>';
  table.appendChild(thead);
  const tbody = document.createElement('tbody');
  table.appendChild(tbody);

  const wrapper = document.createElement('div');
  wrapper.style.cssText = 'overflow-y:auto;height:100%;';
  wrapper.appendChild(table);
  body.appendChild(wrapper);

  const countries = ['US','RU','CN','DE','JP','BR','UK','FR','KR','IN','AU','NL','SE','UA','IR'];
  const statuses = ['OPEN','CLOSED','FILTERED','HONEYPOT','COMPROMISED'];
  const protocols = ['TCP','UDP','ICMP','SSH','HTTPS','DNS','FTP','SMTP'];
  const statusColors = { OPEN: 'var(--green)', CLOSED: '#666', FILTERED: 'var(--amber)', HONEYPOT: 'var(--red)', COMPROMISED: 'var(--purple)' };

  function addRow() {
    if (!document.body.contains(tbody)) return;
    const status = pick(statuses);
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${ipAddr()}</td>
      <td>${pick([22,80,443,3306,5432,8080,8443,27017,6379])}</td>
      <td>${pick(protocols)}</td>
      <td style="color:${statusColors[status]}">${status}</td>
      <td>${randInt(1,500)}ms</td>
      <td>${pick(countries)}</td>
    `;
    tr.style.cursor = 'pointer';
    tr.addEventListener('click', () => {
      notify(`Targeting ${tr.children[0].textContent}:${tr.children[1].textContent}`);
      $$('.data-table tr').forEach(r => r.style.background = '');
      tr.style.background = 'rgba(0,255,65,0.1)';
    });
    tbody.insertBefore(tr, tbody.firstChild);
    if (tbody.children.length > 50) tbody.removeChild(tbody.lastChild);
    setTimeout(addRow, rand(300, 1500));
  }
  addRow();
}

// --- SPECTRUM / HEATMAP (WebGL) ---
function createSpectrum(body) {
  createGLPanel(body, `
    precision highp float;
    varying vec2 v;
    uniform float T;
    uniform vec2 R;
    float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
    void main(){
      vec2 uv=v;
      // Waterfall: x = frequency bin, y = time (scrolling down)
      float freq=uv.x*64.0;
      float timeRow=uv.y*60.0-T*4.0;
      // Procedural spectrum intensity
      float val=abs(sin(timeRow*0.2+freq*0.2))*0.5
               +abs(sin(timeRow*0.5+freq*0.5))*0.3
               +hash(vec2(floor(freq),floor(timeRow)))*0.2;
      val=clamp(val,0.0,1.0);
      // Heatmap color: black→green→yellow→red
      vec3 col;
      if(val<0.33){col=mix(vec3(0.0),vec3(0.0,1.0,0.0),val*3.0);}
      else if(val<0.66){col=mix(vec3(0.0,1.0,0.0),vec3(1.0,1.0,0.0),(val-0.33)*3.0);}
      else{col=mix(vec3(1.0,1.0,0.0),vec3(1.0,0.0,0.0),(val-0.66)*3.0);}
      col*=0.8;
      gl_FragColor=vec4(col,1.0);
    }
  `);
}

// --- PIE/DONUT CHART (WebGL) ---
function createDonutChart(body) {
  createGLPanel(body, `
    precision highp float;
    varying vec2 v;
    uniform float T;
    uniform vec2 R;
    #define PI 3.14159265
    #define TAU 6.28318530
    void main(){
      float aspect=R.x/R.y;
      // Center donut on left 60% of panel
      vec2 center=vec2(0.35,0.5);
      vec2 uv=(v-center)*vec2(aspect,1.0);
      float dist=length(uv);
      float angle=mod(atan(uv.y,uv.x)+PI*2.5+sin(T*0.5)*0.1,TAU);
      float maxR=0.38;
      float innerR=maxR*0.55;
      float px=1.0/R.y;
      vec3 col=vec3(0.0);
      // 5 segments with fixed proportions (42,23,15,12,8 out of 100)
      float cuts[6];
      cuts[0]=0.0;cuts[1]=0.42;cuts[2]=0.65;cuts[3]=0.80;cuts[4]=0.92;cuts[5]=1.0;
      // Wobble cuts slightly
      float w1=sin(T*0.7)*0.01;float w2=sin(T*1.1)*0.01;
      cuts[1]+=w1;cuts[2]+=w2;cuts[3]-=w1;cuts[4]+=w2;
      vec3 colors[5];
      colors[0]=vec3(0.0,1.0,0.25);  // green
      colors[1]=vec3(1.0,0.75,0.0);  // amber
      colors[2]=vec3(1.0,0.0,0.25);  // red
      colors[3]=vec3(0.75,0.0,1.0);  // purple
      colors[4]=vec3(0.0,0.5,1.0);   // blue
      float angleNorm=angle/TAU;
      if(dist>innerR && dist<maxR){
        for(int i=0;i<5;i++){
          if(angleNorm>=cuts[i] && angleNorm<cuts[i+1]){
            col=colors[i]*0.8;
            // Gap between segments
            float gapA=smoothstep(0.0,0.008,angleNorm-cuts[i]);
            float gapB=smoothstep(0.0,0.008,cuts[i+1]-angleNorm);
            col*=gapA*gapB;
          }
        }
        // Edge anti-alias
        col*=smoothstep(innerR-px,innerR+px,dist)*smoothstep(maxR+px,maxR-px,dist);
      }
      // Legend dots on the right side
      float lx=0.72*aspect;
      for(int i=0;i<5;i++){
        float fi=float(i);
        vec2 lp=vec2(lx,(0.2+fi*0.14));
        vec2 luv=(v-vec2(lp.x/aspect,lp.y))*vec2(aspect,1.0);
        if(abs(luv.x)<0.012 && abs(luv.y)<0.012) col=colors[i];
      }
      gl_FragColor=vec4(col,1.0);
    }
  `);
}

// --- BAR CHART (WebGL) ---
function createBarChart(body) {
  createGLPanel(body, `
    precision highp float;
    varying vec2 v;
    uniform float T;
    uniform vec2 R;
    float hash(float n){return fract(sin(n)*43758.5453);}
    void main(){
      vec2 uv=v;
      float px=1.0/R.y;
      vec3 col=vec3(0.0);
      // Grid lines
      for(int i=0;i<5;i++){
        float gy=0.1+float(i)*0.17;
        col+=vec3(0.0,0.27,0.0)*0.3*smoothstep(1.0*px,0.0,abs(uv.y-gy));
      }
      // 8 bars
      vec3 colors[8];
      colors[0]=vec3(0.0,1.0,0.25);colors[1]=vec3(0.0,1.0,1.0);
      colors[2]=vec3(1.0,0.75,0.0);colors[3]=vec3(1.0,0.0,0.25);
      colors[4]=vec3(0.75,0.0,1.0);colors[5]=vec3(0.0,0.5,1.0);
      colors[6]=vec3(0.0,1.0,0.25);colors[7]=vec3(1.0,0.75,0.0);
      float barW=1.0/8.0;
      float margin=0.08;
      for(int i=0;i<8;i++){
        float fi=float(i);
        float bx=margin+fi*(1.0-margin*2.0)/8.0;
        float bw=(1.0-margin*2.0)/8.0*0.7;
        // Animated height
        float h=0.3+hash(fi*1.17)*0.5+sin(T*1.5+fi*0.7)*0.1+sin(T*3.7+fi*1.3)*0.05;
        h=clamp(h,0.05,0.9);
        // Bar body
        if(uv.x>bx && uv.x<bx+bw && uv.y<h && uv.y>0.02){
          float gradT=(uv.y)/h;
          col+=colors[i]*(0.3+gradT*0.6);
          // Glow at top
          col+=colors[i]*0.4*smoothstep(3.0*px,0.0,abs(uv.y-h));
        }
        // Top cap glow
        if(uv.x>bx-0.005 && uv.x<bx+bw+0.005){
          col+=colors[i]*0.3*smoothstep(4.0*px,0.0,abs(uv.y-h));
        }
      }
      gl_FragColor=vec4(col,1.0);
    }
  `);
}

// --- WORLD MAP (ASCII-ish) ---
function createWorldMap(body) {
  const container = document.createElement('div');
  container.style.cssText = 'width:100%;height:100%;position:relative;overflow:hidden;';
  body.appendChild(container);

  // --- HUD overlay canvas for labels/stats ---
  const hudCanvas = document.createElement('canvas');
  hudCanvas.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:2;';
  container.appendChild(hudCanvas);

  // --- Three.js setup ---
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
  camera.position.z = 3.2;

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setClearColor(0x000000, 0);
  container.insertBefore(renderer.domElement, hudCanvas);
  renderer.domElement.style.cssText = 'width:100%;height:100%;position:absolute;top:0;left:0;';

  const globeGroup = new THREE.Group();
  scene.add(globeGroup);

  const GLOBE_R = 1.0;

  // --- Wireframe sphere (latitude/longitude lines) ---
  function buildWireframeGlobe() {
    const material = new THREE.LineBasicMaterial({ color: 0x004400, transparent: true, opacity: 0.5 });
    const brightMat = new THREE.LineBasicMaterial({ color: 0x00ff41, transparent: true, opacity: 0.15 });

    // Latitude lines
    for (let lat = -80; lat <= 80; lat += 20) {
      const phi = (90 - lat) * Math.PI / 180;
      const r = GLOBE_R * Math.sin(phi);
      const y = GLOBE_R * Math.cos(phi);
      const pts = [];
      for (let i = 0; i <= 72; i++) {
        const theta = (i / 72) * Math.PI * 2;
        pts.push(new THREE.Vector3(r * Math.cos(theta), y, r * Math.sin(theta)));
      }
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      globeGroup.add(new THREE.Line(geom, lat === 0 ? brightMat : material));
    }

    // Longitude lines
    for (let lon = 0; lon < 360; lon += 20) {
      const theta = lon * Math.PI / 180;
      const pts = [];
      for (let i = 0; i <= 72; i++) {
        const phi = (i / 72) * Math.PI;
        pts.push(new THREE.Vector3(
          GLOBE_R * Math.sin(phi) * Math.cos(theta),
          GLOBE_R * Math.cos(phi),
          GLOBE_R * Math.sin(phi) * Math.sin(theta)
        ));
      }
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      globeGroup.add(new THREE.Line(geom, (lon === 0 || lon === 180) ? brightMat : material));
    }

    // Outer glow ring (equator emphasis)
    const glowMat = new THREE.LineBasicMaterial({ color: 0x00ff41, transparent: true, opacity: 0.08 });
    for (let offset = 0.01; offset <= 0.03; offset += 0.01) {
      const pts = [];
      for (let i = 0; i <= 72; i++) {
        const theta = (i / 72) * Math.PI * 2;
        pts.push(new THREE.Vector3((GLOBE_R + offset) * Math.cos(theta), 0, (GLOBE_R + offset) * Math.sin(theta)));
      }
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      globeGroup.add(new THREE.Line(geom, glowMat));
    }
  }
  buildWireframeGlobe();

  // --- Atmosphere shell ---
  const atmosGeom = new THREE.SphereGeometry(GLOBE_R * 1.02, 32, 32);
  const atmosMat = new THREE.MeshBasicMaterial({
    color: 0x00ff41, transparent: true, opacity: 0.03, side: THREE.BackSide
  });
  globeGroup.add(new THREE.Mesh(atmosGeom, atmosMat));

  // --- lat/lon → 3D helper ---
  function latLonToVec3(lat, lon, radius) {
    const phi = (90 - lat) * Math.PI / 180;
    const theta = (lon + 180) * Math.PI / 180;
    return new THREE.Vector3(
      -radius * Math.sin(phi) * Math.cos(theta),
      radius * Math.cos(phi),
      radius * Math.sin(phi) * Math.sin(theta)
    );
  }

  // --- Depth-fade shader for coastlines ---
  // Vertices on the far side of the globe (facing away from camera) dim out
  const depthFadeVertexShader = `
    varying vec3 vWorldPosition;
    varying vec3 vWorldNormal;
    void main() {
      vec4 worldPos = modelMatrix * vec4(position, 1.0);
      vWorldPosition = worldPos.xyz;
      // For lines on a sphere, the "normal" is just the normalized position (points outward from center)
      vWorldNormal = normalize((modelMatrix * vec4(normalize(position), 0.0)).xyz);
      gl_Position = projectionMatrix * viewMatrix * worldPos;
    }
  `;

  function makeDepthFadeFragShader(r, g, b, baseOpacity) {
    return `
      uniform vec3 uCameraPos;
      uniform float uFalloff;
      uniform float uMinOpacity;
      varying vec3 vWorldPosition;
      varying vec3 vWorldNormal;
      void main() {
        vec3 toCamera = normalize(uCameraPos - vWorldPosition);
        // dot = 1.0 when facing camera, -1.0 when facing away
        float facing = dot(vWorldNormal, toCamera);
        // Remap: 0..1 range for front-facing, clamp back-facing
        float facingNorm = clamp(facing, 0.0, 1.0);
        // Apply power curve for falloff control: higher = sharper cutoff
        float fade = pow(facingNorm, uFalloff);
        // Mix between min opacity and full opacity
        float alpha = mix(uMinOpacity, ${baseOpacity.toFixed(2)}, fade);
        gl_FragColor = vec4(${(r/255).toFixed(3)}, ${(g/255).toFixed(3)}, ${(b/255).toFixed(3)}, alpha);
      }
    `;
  }

  // Shared uniforms (updated every frame)
  const depthFadeUniforms = {
    uCameraPos: { value: new THREE.Vector3(0, 0, 3.2) },
    uFalloff: { value: 2.5 },
    uMinOpacity: { value: 0.03 },
  };

  function makeDepthFadeMaterial(r, g, b, baseOpacity) {
    return new THREE.ShaderMaterial({
      vertexShader: depthFadeVertexShader,
      fragmentShader: makeDepthFadeFragShader(r, g, b, baseOpacity),
      uniforms: {
        uCameraPos: depthFadeUniforms.uCameraPos,
        uFalloff: depthFadeUniforms.uFalloff,
        uMinOpacity: depthFadeUniforms.uMinOpacity,
      },
      transparent: true,
      depthWrite: false,
    });
  }

  // Materials using the depth-fade shader
  const coastMat = makeDepthFadeMaterial(0, 255, 65, 0.8);       // bright green coastlines
  const coastGlowMat = makeDepthFadeMaterial(0, 255, 65, 0.2);   // subtle inner glow
  const borderMat = makeDepthFadeMaterial(0, 68, 0, 0.35);       // dim country borders

  // Upgrade wireframe grid lines to use depth-fade too
  const gridFadeMat = makeDepthFadeMaterial(0, 68, 0, 0.5);      // dark grid lines
  const gridBrightFadeMat = makeDepthFadeMaterial(0, 255, 65, 0.15); // equator/prime meridian
  const gridGlowFadeMat = makeDepthFadeMaterial(0, 255, 65, 0.08);  // outer glow rings
  globeGroup.children.forEach(child => {
    if (child.isLine && child.material) {
      const c = child.material.color;
      const o = child.material.opacity;
      if (!child.material.isShaderMaterial) {
        // Match by color/opacity to the right replacement
        if (c && c.r < 0.02 && c.g < 0.28 && o >= 0.4) {
          child.material = gridFadeMat; // dark green grid
        } else if (c && c.g > 0.9 && o < 0.12) {
          child.material = gridGlowFadeMat; // glow rings
        } else if (c && c.g > 0.9 && o < 0.2) {
          child.material = gridBrightFadeMat; // bright lines (equator etc)
        }
      }
    }
  });

  // --- HUD control panel (slider) ---
  const controlPanel = document.createElement('div');
  controlPanel.style.cssText = `
    position:absolute; bottom:6px; right:6px; z-index:5;
    background: rgba(0,10,0,0.85); border:1px solid rgba(0,255,65,0.3);
    padding: 8px 10px; font-size:9px; color:#00ff41;
    font-family:'Share Tech Mono',monospace; pointer-events:auto;
    box-shadow: 0 0 10px rgba(0,255,65,0.1); min-width: 150px;
  `;
  controlPanel.innerHTML = `
    <div style="color:#00ffff;letter-spacing:1px;margin-bottom:6px;font-size:8px;">◆ RENDER CTRL</div>
    <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
      <span style="white-space:nowrap;min-width:56px;">FALLOFF</span>
      <input type="range" id="globe-falloff" min="0" max="80" value="25"
        style="flex:1;accent-color:#00ff41;height:3px;cursor:pointer;-webkit-appearance:none;
        background:linear-gradient(90deg,#003300,#00ff41);border-radius:2px;outline:none;">
      <span id="globe-falloff-val" style="min-width:28px;text-align:right;color:#00ffff;">2.5</span>
    </div>
    <div style="display:flex;align-items:center;gap:6px;">
      <span style="white-space:nowrap;min-width:56px;">MIN <span style="font-size:7px;color:#666;">OPACITY</span></span>
      <input type="range" id="globe-minopac" min="0" max="100" value="3"
        style="flex:1;accent-color:#00ff41;height:3px;cursor:pointer;-webkit-appearance:none;
        background:linear-gradient(90deg,#003300,#00ff41);border-radius:2px;outline:none;">
      <span id="globe-minopac-val" style="min-width:28px;text-align:right;color:#00ffff;">0.03</span>
    </div>
  `;
  container.appendChild(controlPanel);

  // Wire up slider events
  const falloffSlider = controlPanel.querySelector('#globe-falloff');
  const falloffVal = controlPanel.querySelector('#globe-falloff-val');
  const minopacSlider = controlPanel.querySelector('#globe-minopac');
  const minopacVal = controlPanel.querySelector('#globe-minopac-val');

  falloffSlider.addEventListener('input', () => {
    const v = parseFloat(falloffSlider.value) / 10;
    depthFadeUniforms.uFalloff.value = v;
    falloffVal.textContent = v.toFixed(1);
  });
  minopacSlider.addEventListener('input', () => {
    const v = parseFloat(minopacSlider.value) / 100;
    depthFadeUniforms.uMinOpacity.value = v;
    minopacVal.textContent = v.toFixed(2);
  });

  // Prevent panel drag when interacting with sliders
  controlPanel.addEventListener('mousedown', e => e.stopPropagation());

  // --- Real coastline outlines from Natural Earth 110m ---
  const coastlineGroup = new THREE.Group();
  globeGroup.add(coastlineGroup);

  fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')
    .then(r => r.json())
    .then(world => {
      const land = topojson.feature(world, world.objects.land);

      // Process each polygon/multipolygon
      const geometries = land.type === 'FeatureCollection' ? land.features.map(f => f.geometry) : [land.geometry || land];

      geometries.forEach(geom => {
        let rings = [];
        if (geom.type === 'Polygon') {
          rings = geom.coordinates;
        } else if (geom.type === 'MultiPolygon') {
          geom.coordinates.forEach(poly => {
            rings = rings.concat(poly);
          });
        }

        rings.forEach(ring => {
          const points = [];
          const innerPoints = [];

          for (let i = 0; i < ring.length; i++) {
            const [lon, lat] = ring[i];
            points.push(latLonToVec3(lat, lon, GLOBE_R * 1.003));
            innerPoints.push(latLonToVec3(lat, lon, GLOBE_R * 1.001));
          }

          if (points.length < 2) return;

          // Main coastline outline (depth-faded)
          const lineGeom = new THREE.BufferGeometry().setFromPoints(points);
          coastlineGroup.add(new THREE.Line(lineGeom, coastMat));

          // Inner glow line (depth-faded, dimmer)
          const glowGeom = new THREE.BufferGeometry().setFromPoints(innerPoints);
          coastlineGroup.add(new THREE.Line(glowGeom, coastGlowMat));
        });
      });

      // Also load country borders for extra detail
      return fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
    })
    .then(r => r.json())
    .then(world => {
      const borders = topojson.mesh(world, world.objects.countries, (a, b) => a !== b);

      if (borders.type === 'MultiLineString') {
        borders.coordinates.forEach(line => {
          const points = [];
          for (let i = 0; i < line.length; i++) {
            const [lon, lat] = line[i];
            points.push(latLonToVec3(lat, lon, GLOBE_R * 1.002));
          }
          if (points.length >= 2) {
            const geom = new THREE.BufferGeometry().setFromPoints(points);
            coastlineGroup.add(new THREE.Line(geom, borderMat));
          }
        });
      }
    })
    .catch(err => {
      console.warn('Failed to load coastline data, falling back to dot cloud', err);
      const boxes = [
        { latMin: 25, latMax: 70, lonMin: -140, lonMax: -55 },
        { latMin: -55, latMax: 10, lonMin: -80, lonMax: -35 },
        { latMin: 35, latMax: 70, lonMin: -10, lonMax: 40 },
        { latMin: -35, latMax: 35, lonMin: -18, lonMax: 50 },
        { latMin: 10, latMax: 70, lonMin: 60, lonMax: 180 },
        { latMin: -40, latMax: -12, lonMin: 112, lonMax: 155 },
      ];
      const verts = [];
      boxes.forEach(b => {
        for (let i = 0; i < 200; i++) {
          const v = latLonToVec3(rand(b.latMin, b.latMax), rand(b.lonMin, b.lonMax), GLOBE_R * 1.002);
          verts.push(v.x, v.y, v.z);
        }
      });
      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
      coastlineGroup.add(new THREE.Points(geom, new THREE.PointsMaterial({ color: 0x00ff41, size: 0.012, transparent: true, opacity: 0.6 })));
    });

  // --- Cities ---
  const cities = [
    { name: 'NYC', lat: 40.7, lon: -74, threat: false },
    { name: 'LON', lat: 51.5, lon: -0.1, threat: false },
    { name: 'TYO', lat: 35.7, lon: 139.7, threat: false },
    { name: 'MOS', lat: 55.8, lon: 37.6, threat: true },
    { name: 'BEJ', lat: 39.9, lon: 116.4, threat: true },
    { name: 'SYD', lat: -33.9, lon: 151.2, threat: false },
    { name: 'BER', lat: 52.5, lon: 13.4, threat: false },
    { name: 'SAO', lat: -23.5, lon: -46.6, threat: true },
    { name: 'SEL', lat: 37.6, lon: 127, threat: false },
    { name: 'DXB', lat: 25.2, lon: 55.3, threat: true },
    { name: 'SIN', lat: 1.3, lon: 103.8, threat: false },
    { name: 'LAX', lat: 34, lon: -118.2, threat: false },
    { name: 'PAR', lat: 48.9, lon: 2.35, threat: false },
    { name: 'MUM', lat: 19.1, lon: 72.9, threat: true },
    { name: 'JKT', lat: -6.2, lon: 106.8, threat: false },
    { name: 'LIM', lat: -12, lon: -77, threat: true },
  ];

  // City markers as small sphere meshes
  const cityMeshes = [];
  cities.forEach(c => {
    const pos = latLonToVec3(c.lat, c.lon, GLOBE_R * 1.01);
    const geom = new THREE.SphereGeometry(0.015, 8, 8);
    const mat = new THREE.MeshBasicMaterial({ color: c.threat ? 0xff0040 : 0x00ff41 });
    const mesh = new THREE.Mesh(geom, mat);
    mesh.position.copy(pos);
    mesh.userData = c;
    globeGroup.add(mesh);
    cityMeshes.push(mesh);

    // Pulsing ring
    const ringGeom = new THREE.RingGeometry(0.02, 0.03, 16);
    const ringMat = new THREE.MeshBasicMaterial({
      color: c.threat ? 0xff0040 : 0x00ff41,
      transparent: true, opacity: 0.4, side: THREE.DoubleSide
    });
    const ring = new THREE.Mesh(ringGeom, ringMat);
    ring.position.copy(pos);
    ring.lookAt(new THREE.Vector3(0, 0, 0));
    ring.userData.pulsePhase = rand(0, Math.PI * 2);
    ring.userData.baseScale = 1;
    globeGroup.add(ring);
    c._ring = ring;
    c._mesh = mesh;
    c._pos = pos;
  });

  // --- Vertical ping beams from cities ---
  cities.forEach(c => {
    const dir = c._pos.clone().normalize();
    const beamEnd = dir.clone().multiplyScalar(GLOBE_R * 1.15);
    const pts = [c._pos.clone(), beamEnd];
    const geom = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({
      color: c.threat ? 0xff0040 : 0x00ff41,
      transparent: true, opacity: 0.3
    });
    const beam = new THREE.Line(geom, mat);
    globeGroup.add(beam);
    c._beam = beam;
    c._beamMat = mat;
  });

  // --- Attack arcs ---
  const attacks = [];

  function createArcCurve(fromCity, toCity) {
    const from = latLonToVec3(fromCity.lat, fromCity.lon, GLOBE_R * 1.01);
    const to = latLonToVec3(toCity.lat, toCity.lon, GLOBE_R * 1.01);
    const mid = from.clone().add(to).multiplyScalar(0.5);
    const dist = from.distanceTo(to);
    // Lift control point above the globe surface
    mid.normalize().multiplyScalar(GLOBE_R + dist * 0.5);

    const curve = new THREE.QuadraticBezierCurve3(from, mid, to);
    const points = curve.getPoints(64);
    return { curve, points, from, to, mid };
  }

  function spawnAttack() {
    const threatCities = cities.filter(c => c.threat);
    const safeCities = cities.filter(c => !c.threat);
    const from = pick(threatCities);
    const to = pick(safeCities);
    if (!from || !to) return;

    const { curve, points } = createArcCurve(from, to);

    // Arc trail line
    const trailGeom = new THREE.BufferGeometry().setFromPoints(points);
    const trailMat = new THREE.LineBasicMaterial({
      color: 0xff0040, transparent: true, opacity: 0.6
    });
    const trail = new THREE.Line(trailGeom, trailMat);
    globeGroup.add(trail);

    // Projectile (bright dot)
    const projGeom = new THREE.SphereGeometry(0.012, 6, 6);
    const projMat = new THREE.MeshBasicMaterial({ color: 0xff4444 });
    const projectile = new THREE.Mesh(projGeom, projMat);
    globeGroup.add(projectile);

    // Glow around projectile
    const glowGeom = new THREE.SphereGeometry(0.025, 6, 6);
    const glowMat = new THREE.MeshBasicMaterial({ color: 0xff0040, transparent: true, opacity: 0.3 });
    const glow = new THREE.Mesh(glowGeom, glowMat);
    globeGroup.add(glow);

    attacks.push({
      from, to, curve, trail, trailGeom, trailMat,
      projectile, projMat, glow, glowMat,
      progress: 0,
      speed: rand(0.003, 0.012),
      alive: true
    });
  }

  // --- Impact explosions ---
  const impacts = [];
  function createImpact(position) {
    const ringGeom = new THREE.RingGeometry(0.01, 0.02, 24);
    const ringMat = new THREE.MeshBasicMaterial({
      color: 0xff0040, transparent: true, opacity: 0.9, side: THREE.DoubleSide
    });
    const ring = new THREE.Mesh(ringGeom, ringMat);
    ring.position.copy(position);
    ring.lookAt(new THREE.Vector3(0, 0, 0));
    globeGroup.add(ring);
    impacts.push({ ring, ringMat, scale: 1, life: 1.0 });
  }

  // --- Starfield background ---
  const starVerts = [];
  for (let i = 0; i < 1500; i++) {
    starVerts.push(rand(-50, 50), rand(-50, 50), rand(-50, 50));
  }
  const starGeom = new THREE.BufferGeometry();
  starGeom.setAttribute('position', new THREE.Float32BufferAttribute(starVerts, 3));
  const starMat = new THREE.PointsMaterial({ color: 0x004400, size: 0.15 });
  scene.add(new THREE.Points(starGeom, starMat));

  // --- Orbital ring (decoration) ---
  const orbitPts = [];
  for (let i = 0; i <= 128; i++) {
    const a = (i / 128) * Math.PI * 2;
    orbitPts.push(new THREE.Vector3(Math.cos(a) * 1.6, Math.sin(a) * 0.1, Math.sin(a) * 1.6));
  }
  const orbitGeom = new THREE.BufferGeometry().setFromPoints(orbitPts);
  const orbitMat = new THREE.LineBasicMaterial({ color: 0x003300, transparent: true, opacity: 0.3 });
  const orbitLine = new THREE.Line(orbitGeom, orbitMat);
  orbitLine.rotation.x = 0.3;
  scene.add(orbitLine);

  // Second orbit ring
  const orbit2 = orbitLine.clone();
  orbit2.rotation.x = -0.5;
  orbit2.rotation.z = 0.8;
  scene.add(orbit2);

  // --- Mouse interaction (drag to rotate) ---
  let isDragging = false;
  let prevMouse = { x: 0, y: 0 };
  let rotationVelocity = { x: 0, y: 0.003 }; // auto-rotate by default

  renderer.domElement.style.pointerEvents = 'auto';
  renderer.domElement.addEventListener('mousedown', e => {
    isDragging = true;
    prevMouse = { x: e.clientX, y: e.clientY };
  });
  renderer.domElement.addEventListener('mousemove', e => {
    if (!isDragging) return;
    const dx = e.clientX - prevMouse.x;
    const dy = e.clientY - prevMouse.y;
    rotationVelocity.y = dx * 0.003;
    rotationVelocity.x = dy * 0.002;
    prevMouse = { x: e.clientX, y: e.clientY };
  });
  renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });
  renderer.domElement.addEventListener('mouseleave', () => { isDragging = false; });

  // Scroll to zoom
  renderer.domElement.addEventListener('wheel', e => {
    e.preventDefault();
    camera.position.z = Math.max(1.8, Math.min(6, camera.position.z + e.deltaY * 0.002));
  }, { passive: false });

  // --- Animation loop ---
  let attackTimer = 0;
  let activeAttackCount = 0;

  function animate() {
    if (!document.body.contains(container)) return;
    requestAnimationFrame(animate);

    const w = container.clientWidth;
    const h = container.clientHeight;
    if (w === 0 || h === 0) return;

    renderer.setSize(w, h);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    hudCanvas.width = w;
    hudCanvas.height = h;

    const time = Date.now() / 1000;

    // Rotate globe
    if (!isDragging) {
      rotationVelocity.y += (0.003 - rotationVelocity.y) * 0.02; // ease back to auto-rotate
      rotationVelocity.x *= 0.95; // dampen vertical
    }
    globeGroup.rotation.y += rotationVelocity.y;
    globeGroup.rotation.x += rotationVelocity.x;
    // Clamp vertical rotation
    globeGroup.rotation.x = Math.max(-1.2, Math.min(1.2, globeGroup.rotation.x));
    if (!isDragging) rotationVelocity.y *= 0.99;

    // Pulse city rings
    cities.forEach(c => {
      if (c._ring) {
        const s = 1 + Math.sin(time * 3 + c._ring.userData.pulsePhase) * 0.5;
        c._ring.scale.set(s, s, s);
        c._ring.material.opacity = 0.2 + Math.sin(time * 3 + c._ring.userData.pulsePhase) * 0.2;
      }
      // Pulse beams
      if (c._beamMat) {
        c._beamMat.opacity = 0.15 + Math.sin(time * 4 + c.lon) * 0.15;
      }
    });

    // Spawn attacks
    attackTimer += 0.016;
    if (attackTimer > rand(0.8, 2.5) && attacks.filter(a => a.alive).length < 8) {
      spawnAttack();
      attackTimer = 0;
    }

    // Update attacks
    activeAttackCount = 0;
    for (let i = attacks.length - 1; i >= 0; i--) {
      const atk = attacks[i];
      if (!atk.alive) continue;
      activeAttackCount++;

      atk.progress += atk.speed;

      // Move projectile along curve
      const pt = atk.curve.getPoint(Math.min(atk.progress, 1));
      atk.projectile.position.copy(pt);
      atk.glow.position.copy(pt);
      atk.glow.scale.setScalar(1 + Math.sin(time * 20) * 0.3);

      // Fade trail with progress
      atk.trailMat.opacity = 0.5 * (1 - atk.progress * 0.5);

      // Partial trail drawing: show only the part behind the projectile
      const totalPts = 65;
      const visiblePts = Math.floor(atk.progress * totalPts);
      const positions = atk.trailGeom.attributes.position.array;
      // Fade will handle visual, keep full trail

      if (atk.progress >= 1) {
        atk.alive = false;
        // Impact!
        createImpact(atk.curve.getPoint(1));

        // Cleanup
        globeGroup.remove(atk.trail);
        globeGroup.remove(atk.projectile);
        globeGroup.remove(atk.glow);
        atk.trailGeom.dispose();
        atk.trailMat.dispose();
        atk.projMat.dispose();
        atk.glowMat.dispose();
        attacks.splice(i, 1);
      }
    }

    // Update impacts
    for (let i = impacts.length - 1; i >= 0; i--) {
      const imp = impacts[i];
      imp.scale += 0.08;
      imp.life -= 0.02;
      imp.ring.scale.set(imp.scale, imp.scale, imp.scale);
      imp.ringMat.opacity = Math.max(0, imp.life);
      if (imp.life <= 0) {
        globeGroup.remove(imp.ring);
        imp.ringMat.dispose();
        impacts.splice(i, 1);
      }
    }

    // Update depth-fade shader uniforms
    depthFadeUniforms.uCameraPos.value.copy(camera.position);

    // Render
    renderer.render(scene, camera);

    // --- HUD overlay ---
    const hctx = hudCanvas.getContext('2d');
    hctx.clearRect(0, 0, w, h);

    // Title
    hctx.font = '10px "Share Tech Mono"';
    hctx.fillStyle = 'rgba(0,255,255,0.7)';
    hctx.fillText('◆ GLOBAL THREAT MAP // 3D SIGINT', 6, 14);

    // Stats
    hctx.font = '9px "Share Tech Mono"';
    hctx.fillStyle = 'rgba(255,0,64,0.7)';
    hctx.fillText(`● ACTIVE ATTACKS: ${activeAttackCount}`, 6, h - 26);
    hctx.fillStyle = 'rgba(0,255,65,0.5)';
    hctx.fillText(`NODES: ${cities.length} | THREATS: ${cities.filter(c=>c.threat).length} | ROT: ${(globeGroup.rotation.y % (Math.PI*2)).toFixed(2)}rad`, 6, h - 12);

    // Project city labels to 2D
    cities.forEach(c => {
      const worldPos = c._pos.clone();
      worldPos.applyMatrix4(globeGroup.matrixWorld);

      // Check if on front side of globe (facing camera)
      const camDir = new THREE.Vector3();
      camera.getWorldDirection(camDir);
      const toCity = worldPos.clone().sub(camera.position).normalize();
      const dot = worldPos.clone().normalize().dot(camera.position.clone().normalize());

      if (dot > 0.1) { // front-facing
        const projected = worldPos.clone().project(camera);
        const sx = (projected.x * 0.5 + 0.5) * w;
        const sy = (-projected.y * 0.5 + 0.5) * h;

        if (sx > 0 && sx < w && sy > 0 && sy < h) {
          hctx.font = '8px "Share Tech Mono"';
          hctx.fillStyle = c.threat ? 'rgba(255,0,64,0.8)' : 'rgba(0,255,255,0.8)';
          hctx.fillText(c.name, sx + 6, sy - 4);

          // Tiny crosshair
          hctx.strokeStyle = c.threat ? 'rgba(255,0,64,0.4)' : 'rgba(0,255,65,0.4)';
          hctx.lineWidth = 0.5;
          hctx.beginPath();
          hctx.moveTo(sx - 4, sy); hctx.lineTo(sx + 4, sy);
          hctx.moveTo(sx, sy - 4); hctx.lineTo(sx, sy + 4);
          hctx.stroke();
        }
      }
    });

    // Corner decorations
    hctx.strokeStyle = 'rgba(0,255,65,0.2)';
    hctx.lineWidth = 1;
    const cs = 15;
    // Top-left
    hctx.beginPath(); hctx.moveTo(0, cs); hctx.lineTo(0, 0); hctx.lineTo(cs, 0); hctx.stroke();
    // Top-right
    hctx.beginPath(); hctx.moveTo(w-cs, 0); hctx.lineTo(w, 0); hctx.lineTo(w, cs); hctx.stroke();
    // Bottom-left
    hctx.beginPath(); hctx.moveTo(0, h-cs); hctx.lineTo(0, h); hctx.lineTo(cs, h); hctx.stroke();
    // Bottom-right
    hctx.beginPath(); hctx.moveTo(w-cs, h); hctx.lineTo(w, h); hctx.lineTo(w, h-cs); hctx.stroke();
  }

  animate();
}

// --- PROCESS LIST ---
function createProcessList(body) {
  const container = document.createElement('div');
  container.style.cssText = 'overflow-y:auto;height:100%;font-size:9px;';
  body.appendChild(container);

  const processes = [
    'quantum_decrypt', 'neural_scan', 'tor_relay', 'mesh_network', 'exploit_fw',
    'packet_sniff', 'brute_force', 'keylog_daemon', 'proxy_chain', 'dns_spoof',
    'ssl_strip', 'arp_poison', 'port_knock', 'entropy_gen', 'hash_crack',
    'payload_gen', 'rootkit_scan', 'vuln_assess', 'traffic_anal', 'crypto_mine',
    'darkweb_crawl', 'botnet_ctrl', 'zero_day_scan', 'firmware_dump', 'mem_inject',
  ];

  function update() {
    if (!document.body.contains(container)) return;
    let html = '<div style="color:var(--cyan);margin-bottom:4px;font-size:10px;">PID    CPU%  MEM%  STAT  COMMAND</div>';
    const shuffled = [...processes].sort(() => Math.random() - 0.5).slice(0, 18);
    shuffled.forEach(p => {
      const cpu = rand(0.1, 99.9).toFixed(1).padStart(5);
      const mem = rand(0.1, 30).toFixed(1).padStart(5);
      const stat = pick(['R', 'S', 'D', 'T', 'Z']);
      const pid = randInt(1000, 65535);
      const statColor = stat === 'R' ? 'var(--green)' : stat === 'Z' ? 'var(--red)' : 'var(--amber)';
      html += `<div style="cursor:pointer;" onmouseover="this.style.background='rgba(0,255,65,0.05)'" onmouseout="this.style.background=''">
        ${String(pid).padStart(5)}  ${cpu}  ${mem}  <span style="color:${statColor}">${stat}</span>     ${p}</div>`;
    });
    container.innerHTML = html;
    setTimeout(update, 1000);
  }
  update();
}

// --- CIRCULAR GAUGE ---
function createGauge(body, label, min, max) {
  const canvas = document.createElement('canvas');
  canvas.className = 'graph-canvas';
  body.appendChild(canvas);

  let value = rand(min, max);
  let targetValue = value;

  function draw() {
    if (!document.body.contains(canvas)) return;
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    const cx = w/2, cy = h/2;
    const r = Math.min(cx, cy) - 15;

    // Update target occasionally
    if (Math.random() > 0.98) targetValue = rand(min, max);
    value += (targetValue - value) * 0.05;

    const pct = (value - min) / (max - min);
    const startAngle = Math.PI * 0.75;
    const endAngle = Math.PI * 2.25;
    const currentAngle = startAngle + pct * (endAngle - startAngle);

    // Background arc
    ctx.beginPath();
    ctx.arc(cx, cy, r, startAngle, endAngle);
    ctx.strokeStyle = 'rgba(0,68,0,0.4)';
    ctx.lineWidth = 6;
    ctx.stroke();

    // Value arc
    const color = pct < 0.5 ? '#00ff41' : pct < 0.75 ? '#ffbf00' : '#ff0040';
    ctx.beginPath();
    ctx.arc(cx, cy, r, startAngle, currentAngle);
    ctx.strokeStyle = color;
    ctx.lineWidth = 6;
    ctx.lineCap = 'round';
    ctx.stroke();

    // Ticks
    for (let i = 0; i <= 10; i++) {
      const angle = startAngle + (i/10) * (endAngle - startAngle);
      const inner = r - 10;
      const outer = r + 3;
      ctx.beginPath();
      ctx.moveTo(cx + Math.cos(angle) * inner, cy + Math.sin(angle) * inner);
      ctx.lineTo(cx + Math.cos(angle) * outer, cy + Math.sin(angle) * outer);
      ctx.strokeStyle = 'rgba(0,255,65,0.3)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    // Needle
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(currentAngle) * (r - 15), cy + Math.sin(currentAngle) * (r - 15));
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Center dot
    ctx.beginPath();
    ctx.arc(cx, cy, 4, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();

    // Value text
    ctx.font = `${Math.max(14, r * 0.4)}px "Orbitron"`;
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.fillText(value.toFixed(1), cx, cy + r * 0.3);

    ctx.font = '9px "Share Tech Mono"';
    ctx.fillStyle = 'var(--cyan)';
    ctx.fillText(label, cx, cy + r * 0.55);
    ctx.textAlign = 'left';

    requestAnimationFrame(draw);
  }
  draw();
}

// --- INITIALIZE PANELS ---
function initAll() {
  const ws = $('#workspace');
  const ww = ws.offsetWidth;
  const wh = ws.offsetHeight;

  // Layout - tiled
  const layouts = [
    { id: 'p-terminal', title: '◆ TERMINAL // root@nexus', x: 0, y: 0, w: ww*0.3, h: wh*0.4, init: createTerminal, tabs: ['BASH', 'ZSH', 'PYTHON'] },
    { id: 'p-netgraph', title: '◆ NETWORK TOPOLOGY', x: ww*0.3, y: 0, w: ww*0.35, h: wh*0.4, init: createNetworkGraph },
    { id: 'p-worldmap', title: '◆ GLOBAL THREAT MAP', x: ww*0.65, y: 0, w: ww*0.35, h: wh*0.4, init: createWorldMap },
    { id: 'p-logs', title: '◆ SYSTEM LOGS', x: 0, y: wh*0.4, w: ww*0.22, h: wh*0.3, init: createLogFeed },
    { id: 'p-eq', title: '◆ AUDIO INTERCEPT // EQ', x: ww*0.22, y: wh*0.4, w: ww*0.18, h: wh*0.15, init: createEQ },
    { id: 'p-waveform', title: '◆ SIGNAL ANALYSIS', x: ww*0.22, y: wh*0.55, w: ww*0.18, h: wh*0.15, init: createWaveform },
    { id: 'p-chart', title: '◆ TRAFFIC MONITOR', x: ww*0.4, y: wh*0.4, w: ww*0.3, h: wh*0.3, init: (b) => createLiveChart(b, {label1:'BANDWIDTH', label2:'PACKETS', label3:'DROPPED'}), tabs: ['REAL-TIME', 'HOUR', 'DAY'] },
    { id: 'p-video', title: '◆ SURVEILLANCE // CAM-7', x: ww*0.7, y: wh*0.4, w: ww*0.3, h: wh*0.3, init: (b) => createVideoFeed(b, 'SECTOR-7') },
    { id: 'p-hex', title: '◆ MEMORY DUMP // 0x7FFF0000', x: 0, y: wh*0.7, w: ww*0.22, h: wh*0.3, init: createHexDump },
    { id: 'p-datatable', title: '◆ PORT SCAN RESULTS', x: ww*0.22, y: wh*0.7, w: ww*0.25, h: wh*0.3, init: createDataTable },
    { id: 'p-radar', title: '◆ RADAR // SIGINT', x: ww*0.47, y: wh*0.7, w: ww*0.18, h: wh*0.3, init: createRadar },
    { id: 'p-donut', title: '◆ TRAFFIC CLASSIFICATION', x: ww*0.65, y: wh*0.7, w: ww*0.18, h: wh*0.15, init: createDonutChart },
    { id: 'p-spectrum', title: '◆ SPECTRUM WATERFALL', x: ww*0.65, y: wh*0.85, w: ww*0.18, h: wh*0.15, init: createSpectrum },
    { id: 'p-bars', title: '◆ PROTOCOL ANALYSIS', x: ww*0.83, y: wh*0.7, w: ww*0.17, h: wh*0.15, init: createBarChart },
    { id: 'p-procs', title: '◆ PROCESS MONITOR', x: ww*0.83, y: wh*0.85, w: ww*0.17, h: wh*0.15, init: createProcessList },
  ];

  layouts.forEach(l => {
    const p = createPanel(l);
    l.init(p.body);
  });

  initClock();
  initBottomBar();
  initContextMenu();
  initSelectionBox();
  initKeyboard();
  initMatrixSlider();
  startAutoNotifications();
}

function initMatrixSlider() {
  const densitySlider = document.getElementById('matrix-density');
  const densityVal = document.getElementById('matrix-density-val');
  const fontSlider = document.getElementById('matrix-fontscale');
  const fontVal = document.getElementById('matrix-fontscale-val');

  if (densitySlider) {
    densitySlider.addEventListener('input', () => {
      const v = parseInt(densitySlider.value);
      densityVal.textContent = v + '%';
      if (window.setMatrixDensity) window.setMatrixDensity(v / 100);
    });
  }
  if (fontSlider) {
    fontSlider.addEventListener('input', () => {
      const v = parseInt(fontSlider.value);
      fontVal.textContent = v + '%';
      if (window.setMatrixFontScale) window.setMatrixFontScale(v / 100);
    });
  }
}

// --- CLOCK ---
function initClock() {
  function updateClock() {
    const now = new Date();
    const utc = now.toUTCString().split(' ')[4];
    $('#clock').textContent = `${utc} UTC`;
    requestAnimationFrame(updateClock);
  }
  updateClock();

  // Uptime
  const start = Date.now();
  function updateUptime() {
    const elapsed = Math.floor((Date.now() - start) / 1000);
    const h = Math.floor(elapsed / 3600).toString().padStart(2, '0');
    const m = Math.floor((elapsed % 3600) / 60).toString().padStart(2, '0');
    const s = (elapsed % 60).toString().padStart(2, '0');
    $('#uptime').textContent = `${h}:${m}:${s}`;
    setTimeout(updateUptime, 1000);
  }
  updateUptime();
}

// --- BOTTOM BAR ---
function initBottomBar() {
  function update() {
    const cpu = rand(20, 95);
    const mem = rand(40, 85);
    $('#cpu-bar').style.width = cpu + '%';
    $('#cpu-bar').style.background = cpu > 80 ? 'var(--red)' : cpu > 60 ? 'var(--amber)' : 'var(--green)';
    $('#cpu-val').textContent = cpu.toFixed(0) + '%';
    $('#cpu-val').style.color = cpu > 80 ? 'var(--red)' : 'var(--green)';

    $('#mem-bar').style.width = mem + '%';
    $('#mem-bar').style.background = mem > 75 ? 'var(--amber)' : 'var(--green)';
    $('#mem-val').textContent = mem.toFixed(0) + '%';

    const up = rand(0.5, 50).toFixed(1);
    const down = rand(2, 200).toFixed(1);
    $('#net-val').textContent = `↑ ${up}MB/s ↓ ${down}MB/s`;
    $('#node-count').textContent = randInt(30, 80);
    $('#thread-count').textContent = randInt(128, 512);

    setTimeout(update, rand(500, 1500));
  }
  update();
}

// --- CONTEXT MENU ---
function initContextMenu() {
  const menu = $('#context-menu');

  document.addEventListener('contextmenu', e => {
    e.preventDefault();
    menu.style.display = 'block';
    menu.style.left = e.clientX + 'px';
    menu.style.top = e.clientY + 'px';
  });

  document.addEventListener('click', () => {
    menu.style.display = 'none';
  });
}

// --- SELECTION BOX ---
function initSelectionBox() {
  const box = $('#selection-box');
  let isSelecting = false, startX, startY;

  document.addEventListener('mousedown', e => {
    if (e.button !== 0) return;
    if (e.target.closest('.panel') || e.target.closest('#top-bar') || e.target.closest('#bottom-bar') || e.target.closest('.context-menu')) return;
    isSelecting = true;
    startX = e.clientX;
    startY = e.clientY;
    box.style.left = startX + 'px';
    box.style.top = startY + 'px';
    box.style.width = '0px';
    box.style.height = '0px';
    box.style.display = 'block';
  });

  document.addEventListener('mousemove', e => {
    if (!isSelecting) return;
    const x = Math.min(e.clientX, startX);
    const y = Math.min(e.clientY, startY);
    const w = Math.abs(e.clientX - startX);
    const h = Math.abs(e.clientY - startY);
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = w + 'px';
    box.style.height = h + 'px';
  });

  document.addEventListener('mouseup', () => {
    if (isSelecting) {
      const w = parseInt(box.style.width);
      const h = parseInt(box.style.height);
      if (w > 20 && h > 20) {
        notify(`Selection area: ${w}x${h}px — ${randInt(1,12)} targets identified`);
      }
    }
    isSelecting = false;
    box.style.display = 'none';
  });
}

// --- KEYBOARD SHORTCUTS ---
function closeAllPanels() {
  $$('.panel').forEach(p => {
    p.style.transition = 'opacity 0.3s, transform 0.3s';
    p.style.opacity = '0';
    p.style.transform = 'scale(0.9)';
    setTimeout(() => p.remove(), 300);
  });
  panels = [];
  notify('All panels closed — press [L] to restore', 'warn');
}

const HOTKEYS = [
  { key: '?',      label: '?',      desc: 'Toggle this help overlay' },
  { key: 'g',      label: 'G',      desc: 'Trigger glitch effect' },
  { key: 'n',      label: 'N',      desc: 'Toggle night vision mode' },
  { key: 't',      label: 'T',      desc: 'Spawn new floating terminal' },
  { key: 'h',      label: 'H',      desc: 'Hack The Gibson (full sequence)' },
  { key: 'r',      label: 'R',      desc: 'Run network scan' },
  { key: 'q',      label: 'Q',      desc: 'Close all panels (clear view)' },
  { key: 'l',      label: 'L',      desc: 'Restore default layout' },
  { key: 'Escape', label: 'ESC',    desc: 'Defocus all panels' },
];

let helpOverlayVisible = false;
let helpOverlayEl = null;

function toggleHelpOverlay() {
  if (helpOverlayEl) {
    helpOverlayEl.remove();
    helpOverlayEl = null;
    helpOverlayVisible = false;
    return;
  }
  helpOverlayVisible = true;
  helpOverlayEl = document.createElement('div');
  helpOverlayEl.style.cssText = `
    position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
    background:rgba(0,10,0,0.95); border:1px solid var(--green);
    padding:24px 32px; z-index:100001; min-width:360px;
    box-shadow: 0 0 40px rgba(0,255,65,0.3), 0 0 80px rgba(0,255,65,0.1);
    font-family:'Share Tech Mono',monospace;
  `;
  let html = `
    <div style="font-family:'Orbitron',sans-serif;font-size:14px;color:#00ffff;letter-spacing:3px;margin-bottom:16px;text-align:center;text-shadow:0 0 10px rgba(0,255,255,0.5);">
      ◆ KEYBOARD SHORTCUTS ◆
    </div>
    <div style="display:flex;flex-direction:column;gap:6px;">
  `;
  HOTKEYS.forEach(h => {
    html += `
      <div style="display:flex;align-items:center;gap:12px;font-size:12px;">
        <span style="
          display:inline-block;min-width:48px;text-align:center;
          padding:3px 8px;background:rgba(0,255,65,0.1);border:1px solid rgba(0,255,65,0.3);
          color:#00ff41;font-size:11px;letter-spacing:1px;
        ">${h.label}</span>
        <span style="color:#00ff41;opacity:0.8;">${h.desc}</span>
      </div>
    `;
  });
  html += `
    </div>
    <div style="margin-top:16px;text-align:center;font-size:9px;color:#004400;">
      Press <span style="color:#00ffff;">?</span> to close  ·  Right-click for context menu
    </div>
  `;
  helpOverlayEl.innerHTML = html;
  document.body.appendChild(helpOverlayEl);
}

function initKeyboard() {
  document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT') return;
    if (e.key === '?') toggleHelpOverlay();
    if (e.key === 'g') triggerGlitch();
    if (e.key === 'n') toggleNightVision();
    if (e.key === 't') spawnFloatingTerminal();
    if (e.key === 'h') hackTheGibson();
    if (e.key === 'r') runNetScan();
    if (e.key === 'q') closeAllPanels();
    if (e.key === 'l') resetLayout();
    if (e.key === 'Escape') {
      if (helpOverlayVisible) { toggleHelpOverlay(); return; }
      $$('.panel').forEach(p => p.classList.remove('focused'));
      notify('All panels defocused');
    }
  });
}

// --- NOTIFICATIONS ---
function notify(msg, type) {
  const el = document.createElement('div');
  el.className = 'notification' + (type === 'error' ? ' error' : type === 'warn' ? ' warn' : '');
  el.textContent = `[${timestamp()}] ${msg}`;

  // Stack notifications
  const existing = $$('.notification');
  el.style.top = (42 + existing.length * 36) + 'px';

  document.body.appendChild(el);
  setTimeout(() => el.remove(), 4000);
}

function startAutoNotifications() {
  const msgs = [
    () => `Encrypted tunnel ${randInt(1,99)} renegotiated`,
    () => `New node joined mesh: ${ipAddr()}`,
    () => `Blocked scan from ${ipAddr()}`,
    () => `Firewall rule updated: DROP ${ipAddr()}`,
    () => `Certificate pinning verified for *.${pick(['shadow','dark','ghost'])}.net`,
    () => `Tor circuit rebuilt: ${randInt(3,7)} hops`,
    () => `Quantum key exchange completed (${randInt(256,4096)} bits)`,
    () => `Intelligence feed updated: ${randInt(10,500)} new IOCs`,
    () => `Anomaly detected on port ${pick([22,80,443,8080])}`,
    () => `Decryption complete: ${randInt(1,50)}MB payload`,
  ];

  function autoNotify() {
    if (Math.random() > 0.6) {
      notify(pick(msgs)(), Math.random() > 0.85 ? 'warn' : undefined);
    }
    setTimeout(autoNotify, rand(5000, 15000));
  }
  setTimeout(autoNotify, 5000);
}

// --- SPECIAL ACTIONS ---
function triggerGlitch() {
  const container = $('#main-container');
  container.style.animation = 'none';
  void container.offsetHeight;
  container.style.animation = 'glitch 0.3s ease 3';
  setTimeout(() => { container.style.animation = 'flicker 4s infinite'; }, 1000);
  notify('GLITCH DETECTED — Recovering...', 'error');
}

function toggleNightVision() {
  document.body.style.filter = document.body.style.filter === 'hue-rotate(60deg) brightness(1.2)' ? '' : 'hue-rotate(60deg) brightness(1.2)';
  notify('Night vision ' + (document.body.style.filter ? 'ENABLED' : 'DISABLED'));
}

function hackTheGibson() {
  notify('HACK THE PLANET!', 'warn');
  triggerGlitch();
  setTimeout(() => notify('ACCESS GRANTED — Welcome to The Gibson', 'warn'), 1500);
  setTimeout(() => notify('Downloading garbage file...', 'error'), 3000);
  setTimeout(() => {
    // Spawn a big dramatic overlay briefly
    const overlay = document.createElement('div');
    overlay.style.cssText = `
      position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:99999;
      display:flex;align-items:center;justify-content:center;
      background:rgba(0,0,0,0.9);
      font-family:'Orbitron',sans-serif;font-size:60px;color:#00ff41;
      text-shadow:0 0 30px #00ff41, 0 0 60px #00ff41;
      letter-spacing:10px;
    `;
    overlay.textContent = 'ACCESS GRANTED';
    document.body.appendChild(overlay);
    setTimeout(() => {
      overlay.style.transition = 'opacity 1s';
      overlay.style.opacity = '0';
      setTimeout(() => overlay.remove(), 1000);
    }, 2000);
  }, 4000);
}

function runNetScan() {
  notify('Network sweep initiated...', 'warn');
  let count = 0;
  const interval = setInterval(() => {
    notify(`Found: ${ipAddr()} [${pick(['OPEN','FILTERED','CLOSED'])}]`);
    count++;
    if (count >= 5) {
      clearInterval(interval);
      notify(`Sweep complete: ${randInt(10,50)} hosts discovered`, 'warn');
    }
  }, 800);
}

function spawnFloatingTerminal() {
  const p = createPanel({
    title: `◆ TERMINAL // PID:${randInt(1000,9999)}`,
    x: randInt(50, 400),
    y: randInt(50, 300),
    w: 450,
    h: 280,
  });
  createTerminal(p.body);
  p.el.classList.add('focused');
  p.el.style.zIndex = ++panelZIndex;
  notify('New terminal spawned');
}

function resetLayout() {
  $$('.panel').forEach(p => p.remove());
  panels = [];
  initAll();
  notify('Layout reset');
}

// --- AUDIO CONTEXT (click to activate) ---
let audioCtx;
document.addEventListener('click', () => {
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    // Create subtle background hum
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    oscillator.type = 'sawtooth';
    oscillator.frequency.value = 55;
    gainNode.gain.value = 0.015;
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    oscillator.start();
  } catch(e) {}
}, { once: true });

// --- SOUND EFFECTS ---
function beep(freq = 800, duration = 50) {
  if (!audioCtx) return;
  try {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'square';
    osc.frequency.value = freq;
    gain.gain.value = 0.03;
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration/1000);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration/1000);
  } catch(e) {}
}

// Beep on notifications
const origNotify = notify;
// Override to add sound
const _notify = notify;
notify = function(msg, type) {
  _notify(msg, type);
  beep(type === 'error' ? 200 : type === 'warn' ? 400 : 800);
};

// --- START ---
initMatrix();
bootSequence();
</script>
</body>
</html>
