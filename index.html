<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>H4CK3R C0NS0L3 // 31337 OPS</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&display=swap');

  :root {
    --green: #00ff41;
    --dark-green: #003b00;
    --cyan: #00ffff;
    --red: #ff0040;
    --amber: #ffbf00;
    --purple: #bf00ff;
    --blue: #0080ff;
    --bg: #0a0a0a;
    --panel-bg: rgba(0, 20, 0, 0.85);
    --border: #004400;
    --glow: 0 0 10px rgba(0, 255, 65, 0.5);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--green);
    font-family: 'Share Tech Mono', monospace;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    cursor: crosshair;
  }

  /* SCANLINE OVERLAY */
  body::after {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: repeating-linear-gradient(
      0deg,
      rgba(0, 0, 0, 0.15) 0px,
      rgba(0, 0, 0, 0.15) 1px,
      transparent 1px,
      transparent 2px
    );
    pointer-events: none;
    z-index: 10000;
  }

  /* GLOBAL FLICKER */
  @keyframes flicker {
    0%, 97%, 100% { opacity: 1; }
    98% { opacity: 0.85; }
    99% { opacity: 0.92; }
  }

  #main-container {
    width: 100vw;
    height: 100vh;
    animation: flicker 4s infinite;
    display: flex;
    flex-direction: column;
  }

  /* TOP BAR */
  #top-bar {
    height: 36px;
    background: linear-gradient(180deg, #001a00, #000d00);
    border-bottom: 1px solid var(--green);
    display: flex;
    align-items: center;
    padding: 0 10px;
    gap: 20px;
    flex-shrink: 0;
    box-shadow: 0 2px 10px rgba(0, 255, 65, 0.2);
    z-index: 100;
  }

  #top-bar .logo {
    font-family: 'Orbitron', sans-serif;
    font-weight: 900;
    font-size: 14px;
    color: var(--green);
    text-shadow: var(--glow);
    letter-spacing: 3px;
  }

  .top-menu {
    display: flex;
    gap: 2px;
  }

  .top-menu-item {
    padding: 4px 12px;
    font-size: 11px;
    cursor: pointer;
    color: var(--green);
    transition: all 0.1s;
    position: relative;
  }

  .top-menu-item:hover {
    background: var(--green);
    color: #000;
  }

  .dropdown-menu {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    background: #001a00;
    border: 1px solid var(--green);
    min-width: 180px;
    z-index: 9999;
  }

  .top-menu-item:hover .dropdown-menu {
    display: block;
  }

  .dropdown-item {
    padding: 6px 14px;
    font-size: 11px;
    cursor: pointer;
    white-space: nowrap;
    color: var(--green);
  }

  .dropdown-item:hover {
    background: var(--green);
    color: #000;
  }

  .top-bar-status {
    margin-left: auto;
    display: flex;
    gap: 15px;
    align-items: center;
    font-size: 10px;
  }

  .status-indicator {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .status-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    animation: pulse-dot 2s infinite;
  }

  @keyframes pulse-dot {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  .dot-green { background: var(--green); box-shadow: 0 0 6px var(--green); }
  .dot-red { background: var(--red); box-shadow: 0 0 6px var(--red); }
  .dot-amber { background: var(--amber); box-shadow: 0 0 6px var(--amber); }
  .dot-cyan { background: var(--cyan); box-shadow: 0 0 6px var(--cyan); }

  /* WORKSPACE */
  #workspace {
    flex: 1;
    position: relative;
    overflow: hidden;
  }

  /* PANELS */
  .panel {
    position: absolute;
    background: var(--panel-bg);
    border: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 0 0 15px rgba(0, 255, 65, 0.1), inset 0 0 30px rgba(0, 0, 0, 0.5);
  }

  .panel.focused {
    border-color: var(--green);
    box-shadow: 0 0 20px rgba(0, 255, 65, 0.3), inset 0 0 30px rgba(0, 0, 0, 0.5);
    z-index: 50;
  }

  .panel-header {
    height: 24px;
    background: linear-gradient(90deg, #002200, #001100);
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    padding: 0 8px;
    cursor: move;
    flex-shrink: 0;
    user-select: none;
  }

  .panel-header .title {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    flex: 1;
  }

  .panel-header .controls {
    display: flex;
    gap: 4px;
  }

  .panel-header .ctrl-btn {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    cursor: pointer;
  }

  .ctrl-close { background: var(--red); }
  .ctrl-min { background: var(--amber); }
  .ctrl-max { background: var(--green); }

  .panel-body {
    flex: 1;
    overflow: hidden;
    padding: 6px;
    position: relative;
  }

  /* RESIZE HANDLE */
  .resize-handle {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 14px;
    height: 14px;
    cursor: nwse-resize;
    z-index: 10;
  }

  .resize-handle::after {
    content: '⋱';
    position: absolute;
    right: 2px;
    bottom: -2px;
    font-size: 10px;
    color: var(--green);
    opacity: 0.5;
  }

  /* TERMINAL */
  .terminal-output {
    height: 100%;
    overflow-y: auto;
    font-size: 11px;
    line-height: 1.4;
    scrollbar-width: thin;
    scrollbar-color: var(--green) transparent;
  }

  .terminal-output::-webkit-scrollbar { width: 4px; }
  .terminal-output::-webkit-scrollbar-thumb { background: var(--dark-green); }

  .term-line { margin-bottom: 1px; white-space: pre-wrap; word-break: break-all; }
  .term-prompt { color: var(--cyan); }
  .term-error { color: var(--red); }
  .term-warn { color: var(--amber); }
  .term-info { color: var(--green); }
  .term-purple { color: var(--purple); }
  .term-blue { color: var(--blue); }

  .term-input-line {
    display: flex;
    align-items: center;
    margin-top: 4px;
  }

  .term-input-line span { color: var(--cyan); font-size: 11px; }

  .term-input {
    background: transparent;
    border: none;
    color: var(--green);
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    outline: none;
    flex: 1;
    caret-color: var(--green);
  }

  /* GRAPH CANVAS */
  .graph-canvas {
    width: 100%;
    height: 100%;
  }

  /* MATRIX RAIN BG */
  #matrix-bg {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    opacity: 0.06;
  }

  /* EQ BARS */
  .eq-container {
    display: flex;
    align-items: flex-end;
    gap: 2px;
    height: 100%;
    padding: 4px;
  }

  .eq-bar {
    flex: 1;
    background: linear-gradient(to top, var(--green), var(--cyan), var(--red));
    min-width: 3px;
    transition: height 0.08s ease;
    border-radius: 1px 1px 0 0;
  }

  /* WORLD MAP */
  .world-map-container {
    width: 100%;
    height: 100%;
    position: relative;
  }

  /* HEX DUMP */
  .hex-dump {
    font-size: 9px;
    line-height: 1.5;
    color: var(--green);
    opacity: 0.9;
    overflow-y: auto;
    height: 100%;
  }

  /* SELECTION BOX */
  .selection-box {
    position: fixed;
    border: 1px dashed var(--cyan);
    background: rgba(0, 255, 255, 0.05);
    pointer-events: none;
    z-index: 9998;
    display: none;
  }

  /* VIDEO FEED */
  .video-feed {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    background: #000;
  }

  .video-feed canvas {
    width: 100%;
    height: 100%;
  }

  .video-overlay {
    position: absolute;
    top: 4px;
    left: 4px;
    font-size: 9px;
    color: var(--red);
    text-shadow: 0 0 5px var(--red);
  }

  .video-overlay.rec::before {
    content: '● ';
    animation: pulse-dot 1s infinite;
  }

  /* BOTTOM BAR */
  #bottom-bar {
    height: 22px;
    background: linear-gradient(180deg, #000d00, #001a00);
    border-top: 1px solid var(--border);
    display: flex;
    align-items: center;
    padding: 0 10px;
    font-size: 9px;
    gap: 20px;
    flex-shrink: 0;
    z-index: 100;
  }

  #bottom-bar .section {
    display: flex;
    gap: 6px;
    align-items: center;
  }

  /* PROGRESS BARS */
  .mini-progress {
    width: 60px;
    height: 4px;
    background: #001100;
    border: 1px solid var(--border);
    overflow: hidden;
  }

  .mini-progress-fill {
    height: 100%;
    transition: width 0.3s;
  }

  /* CONTEXT MENU */
  .context-menu {
    display: none;
    position: fixed;
    background: #001a00;
    border: 1px solid var(--green);
    min-width: 160px;
    z-index: 99999;
    box-shadow: 0 0 15px rgba(0, 255, 65, 0.3);
  }

  .context-menu-item {
    padding: 6px 14px;
    font-size: 11px;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
  }

  .context-menu-item:hover {
    background: var(--green);
    color: #000;
  }

  .context-menu-sep {
    height: 1px;
    background: var(--border);
    margin: 2px 0;
  }

  .ctx-shortcut { opacity: 0.6; font-size: 9px; }

  /* TOOLTIP */
  .tooltip {
    position: fixed;
    background: #001a00;
    border: 1px solid var(--green);
    padding: 4px 8px;
    font-size: 9px;
    pointer-events: none;
    z-index: 99999;
    display: none;
    max-width: 200px;
    box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
  }

  /* NOTIFICATION */
  .notification {
    position: fixed;
    top: 42px;
    right: 10px;
    background: #001a00;
    border: 1px solid var(--green);
    padding: 10px 16px;
    font-size: 11px;
    z-index: 99999;
    animation: slideIn 0.3s ease, fadeOut 0.5s ease 3s forwards;
    box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
  }

  .notification.error { border-color: var(--red); color: var(--red); box-shadow: 0 0 20px rgba(255, 0, 64, 0.3); }
  .notification.warn { border-color: var(--amber); color: var(--amber); }

  @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
  @keyframes fadeOut { to { opacity: 0; transform: translateY(-10px); } }

  /* BOOT SCREEN */
  #boot-screen {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    background: #000;
    z-index: 100000;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-family: 'Share Tech Mono', monospace;
  }

  #boot-text {
    max-width: 700px;
    font-size: 13px;
    line-height: 1.6;
    color: var(--green);
    text-shadow: var(--glow);
  }

  #boot-text .blink-cursor::after {
    content: '█';
    animation: blink 0.5s infinite;
  }

  @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

  /* DATA TABLE */
  .data-table {
    width: 100%;
    font-size: 9px;
    border-collapse: collapse;
  }

  .data-table th {
    background: rgba(0, 255, 65, 0.1);
    padding: 3px 6px;
    text-align: left;
    border-bottom: 1px solid var(--border);
    color: var(--cyan);
  }

  .data-table td {
    padding: 2px 6px;
    border-bottom: 1px solid rgba(0, 68, 0, 0.3);
  }

  .data-table tr:hover td {
    background: rgba(0, 255, 65, 0.05);
  }

  /* RADAR */
  .radar-container {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* NODE GRAPH */
  .node-graph { width: 100%; height: 100%; }

  /* TABS */
  .panel-tabs {
    display: flex;
    background: rgba(0, 17, 0, 0.5);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }

  .panel-tab {
    padding: 3px 10px;
    font-size: 9px;
    cursor: pointer;
    border-right: 1px solid var(--border);
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .panel-tab.active {
    background: rgba(0, 255, 65, 0.1);
    color: var(--cyan);
  }

  .panel-tab:hover { background: rgba(0, 255, 65, 0.05); }

  /* GLITCH EFFECT */
  @keyframes glitch {
    0%, 90%, 100% { transform: translate(0); }
    92% { transform: translate(-2px, 1px); filter: hue-rotate(90deg); }
    94% { transform: translate(2px, -1px); }
    96% { transform: translate(-1px, -1px); filter: hue-rotate(180deg); }
    98% { transform: translate(1px, 2px); }
  }

  .glitch-text {
    animation: glitch 8s infinite;
  }

  /* TYPING CURSOR */
  @keyframes typing-cursor {
    0%, 100% { border-right-color: var(--green); }
    50% { border-right-color: transparent; }
  }

  /* AUDIO WAVE */
  .audio-wave {
    width: 100%;
    height: 100%;
  }

  /* SPECTRUM */
  .spectrum-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    gap: 2px;
    padding: 4px;
  }

  .spectrum-row {
    display: flex;
    gap: 1px;
    flex: 1;
  }

  .spectrum-cell {
    flex: 1;
    transition: background 0.15s;
    border-radius: 1px;
  }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson-client@3.1.0/dist/topojson-client.min.js"></script>
</head>
<body>
<canvas id="matrix-bg"></canvas>

<div id="boot-screen">
  <div id="boot-text"></div>
</div>

<div id="main-container" style="display:none;">
  <!-- TOP BAR -->
  <div id="top-bar">
    <div class="logo glitch-text">◆ N3XUS-C0R3 v6.66</div>
    <div class="top-menu">
      <div class="top-menu-item">FILE
        <div class="dropdown-menu">
          <div class="dropdown-item" onclick="notify('Importing neural dataset...')">Import Dataset</div>
          <div class="dropdown-item" onclick="notify('Exporting encrypted payload...')">Export Payload</div>
          <div class="dropdown-item" onclick="notify('Quantum tunnel established')">New Tunnel</div>
          <div class="dropdown-item" onclick="notify('Session archived to /dev/null')">Archive Session</div>
        </div>
      </div>
      <div class="top-menu-item">SCAN
        <div class="dropdown-menu">
          <div class="dropdown-item" onclick="runNetScan()">Network Sweep</div>
          <div class="dropdown-item" onclick="notify('Vulnerability scan initiated...')">Vuln Scanner</div>
          <div class="dropdown-item" onclick="notify('Port enumeration: 65535 ports...')">Port Enum</div>
          <div class="dropdown-item" onclick="notify('DNS recon in progress...')">DNS Recon</div>
        </div>
      </div>
      <div class="top-menu-item">TOOLS
        <div class="dropdown-menu">
          <div class="dropdown-item" onclick="notify('Packet sniffer active on eth0')">Packet Sniffer</div>
          <div class="dropdown-item" onclick="notify('Crypto miner deployed (jk)')">Hash Cracker</div>
          <div class="dropdown-item" onclick="notify('Decompiler loaded')">Decompiler</div>
          <div class="dropdown-item" onclick="spawnFloatingTerminal()">New Terminal</div>
        </div>
      </div>
      <div class="top-menu-item">VIEW
        <div class="dropdown-menu">
          <div class="dropdown-item" onclick="toggleNightVision()">Night Vision</div>
          <div class="dropdown-item" onclick="triggerGlitch()">Glitch Mode</div>
          <div class="dropdown-item" onclick="notify('Wireframe overlay active')">Wireframe</div>
          <div class="dropdown-item" onclick="resetLayout()">Reset Layout</div>
        </div>
      </div>
      <div class="top-menu-item">HACK
        <div class="dropdown-menu">
          <div class="dropdown-item" onclick="notify('ACCESS GRANTED', 'warn')">Bypass Auth</div>
          <div class="dropdown-item" onclick="notify('Injecting shellcode...', 'error')">Inject Payload</div>
          <div class="dropdown-item" onclick="notify('Firewall rules: iptables -F')">Drop Firewall</div>
          <div class="dropdown-item" onclick="hackTheGibson()">Hack The Gibson</div>
        </div>
      </div>
    </div>
    <div class="top-bar-status">
      <div class="status-indicator"><div class="status-dot dot-green"></div>UPLINK</div>
      <div class="status-indicator"><div class="status-dot dot-cyan"></div>TOR x3</div>
      <div class="status-indicator"><div class="status-dot dot-amber"></div>PROXY</div>
      <div class="status-indicator"><div class="status-dot dot-red" style="animation-delay:0.5s"></div>ENCRYPT</div>
      <div id="clock" style="font-family:'Orbitron',sans-serif;font-size:11px;color:var(--cyan);"></div>
    </div>
  </div>

  <!-- WORKSPACE -->
  <div id="workspace">
    <!-- All panels injected by JS -->
  </div>

  <!-- BOTTOM BAR -->
  <div id="bottom-bar">
    <div class="section">
      <span style="color:var(--cyan)">CPU:</span>
      <div class="mini-progress"><div class="mini-progress-fill" id="cpu-bar" style="width:45%;background:var(--green);"></div></div>
      <span id="cpu-val">45%</span>
    </div>
    <div class="section">
      <span style="color:var(--cyan)">MEM:</span>
      <div class="mini-progress"><div class="mini-progress-fill" id="mem-bar" style="width:62%;background:var(--amber);"></div></div>
      <span id="mem-val">62%</span>
    </div>
    <div class="section">
      <span style="color:var(--cyan)">NET:</span>
      <span id="net-val" style="color:var(--green);">↑ 2.4MB/s ↓ 14.7MB/s</span>
    </div>
    <div class="section">
      <span style="color:var(--cyan)">NODES:</span>
      <span id="node-count">47</span>
    </div>
    <div class="section">
      <span style="color:var(--cyan)">THREADS:</span>
      <span id="thread-count">256</span>
    </div>
    <div class="section" style="margin-left:auto;">
      <span style="color:var(--purple)">▶ OPERATION BLACKOUT</span>
    </div>
    <div class="section">
      <span id="uptime" style="color:var(--green);">00:00:00</span>
    </div>
  </div>
</div>

<!-- CONTEXT MENU -->
<div class="context-menu" id="context-menu">
  <div class="context-menu-item" onclick="notify('Trace route initiated')">Trace Route <span class="ctx-shortcut">Ctrl+T</span></div>
  <div class="context-menu-item" onclick="notify('Packet captured')">Capture Packet <span class="ctx-shortcut">Ctrl+P</span></div>
  <div class="context-menu-sep"></div>
  <div class="context-menu-item" onclick="notify('Encrypting selection...')">Encrypt Selection <span class="ctx-shortcut">Ctrl+E</span></div>
  <div class="context-menu-item" onclick="notify('Decrypting...')">Decrypt <span class="ctx-shortcut">Ctrl+D</span></div>
  <div class="context-menu-sep"></div>
  <div class="context-menu-item" onclick="notify('Memory dump saved')">Dump Memory <span class="ctx-shortcut">Ctrl+M</span></div>
  <div class="context-menu-item" onclick="notify('Injecting...')">Inject Code <span class="ctx-shortcut">Ctrl+I</span></div>
  <div class="context-menu-sep"></div>
  <div class="context-menu-item" onclick="spawnFloatingTerminal()">New Terminal <span class="ctx-shortcut">Ctrl+N</span></div>
  <div class="context-menu-item" onclick="triggerGlitch()">Glitch <span class="ctx-shortcut">Ctrl+G</span></div>
</div>

<!-- SELECTION BOX -->
<div class="selection-box" id="selection-box"></div>

<!-- TOOLTIP -->
<div class="tooltip" id="tooltip"></div>

<script>
// ============================================================
// H4CK3R C0NS0L3 - THE MOST RIDICULOUS HOLLYWOOD THING EVER
// ============================================================

// --- UTILITY ---
const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);
const rand = (a, b) => Math.random() * (b - a) + a;
const randInt = (a, b) => Math.floor(rand(a, b));
const pick = arr => arr[randInt(0, arr.length)];
const hex = () => randInt(0, 256).toString(16).padStart(2, '0');
const hexWord = () => randInt(0, 65536).toString(16).padStart(4, '0');
const ipAddr = () => `${randInt(1,255)}.${randInt(0,255)}.${randInt(0,255)}.${randInt(1,255)}`;
const macAddr = () => Array.from({length:6}, () => hex()).join(':');
const uuid = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
  const r = Math.random() * 16 | 0; return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
});

// --- BOOT SEQUENCE ---
const bootLines = [
  'BIOS v3.31337 (C) N3XUS CORP 2025',
  'Checking quantum entanglement pairs... OK',
  'Neural coprocessor: ONLINE [8 cores @ 4.7THz]',
  'Initializing holographic RAM... 128PB detected',
  'Loading kernel: nexus-core-6.66.0-quantum-amd64',
  '  [  OK  ] Started Quantum Entropy Daemon',
  '  [  OK  ] Started Neural Network Inference Engine',
  '  [  OK  ] Started Dark Web Relay Service',
  '  [  OK  ] Started Encrypted Mesh Network',
  '  [  OK  ] Started AI Threat Detection Module',
  '  [ WARN ] Intrusion Detection: 47 probes blocked',
  '  [  OK  ] Started Zero-Day Exploit Scanner',
  'Establishing TOR circuit... 3 relays connected',
  'Proxy chain: SOCKS5 → VPN → TOR → SATELLITE',
  'Encryption: AES-4096-GCM + Quantum Key Exchange',
  '///////////////////////////////////////////\\\\',
  '  N 3 X U S - C 0 R 3    v 6 . 6 6',
  '  "There is no spoon."',
  '///////////////////////////////////////////\\\\',
  '',
  'SYSTEM READY. ACCESS LEVEL: ROOT [31337]',
  'Type "help" for command list.',
  ''
];

async function bootSequence() {
  const bootText = $('#boot-text');
  const bootScreen = $('#boot-screen');

  for (let i = 0; i < bootLines.length; i++) {
    const line = bootLines[i];
    const div = document.createElement('div');
    div.style.color = line.includes('WARN') ? 'var(--amber)' : line.includes('///') ? 'var(--cyan)' : 'var(--green)';
    div.style.textShadow = 'var(--glow)';
    bootText.appendChild(div);

    for (let j = 0; j < line.length; j++) {
      div.textContent += line[j];
      if (Math.random() > 0.85) await sleep(10);
    }
    div.textContent = line;

    if (i === bootLines.length - 1) {
      const cursor = document.createElement('span');
      cursor.className = 'blink-cursor';
      div.appendChild(cursor);
    }

    bootText.scrollTop = bootText.scrollHeight;
    await sleep(rand(20, 80));
  }

  await sleep(800);
  bootScreen.style.transition = 'opacity 0.8s';
  bootScreen.style.opacity = '0';
  await sleep(800);
  bootScreen.style.display = 'none';
  $('#main-container').style.display = 'flex';
  initAll();
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// --- MATRIX RAIN BACKGROUND ---
function initMatrix() {
  const canvas = $('#matrix-bg');
  const ctx = canvas.getContext('2d');
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const cols = Math.floor(canvas.width / 14);
  const drops = Array.from({length: cols}, () => randInt(0, canvas.height));
  const chars = 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン0123456789ABCDEF'.split('');

  function draw() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#00ff41';
    ctx.font = '13px monospace';

    for (let i = 0; i < drops.length; i++) {
      ctx.fillText(pick(chars), i * 14, drops[i]);
      if (drops[i] > canvas.height && Math.random() > 0.975) drops[i] = 0;
      drops[i] += 14;
    }
    requestAnimationFrame(draw);
  }
  draw();

  window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  });
}

// --- PANEL MANAGEMENT ---
let panelZIndex = 10;
let panels = [];

function createPanel(config) {
  const panel = document.createElement('div');
  panel.className = 'panel';
  panel.id = config.id || 'panel-' + Date.now();
  panel.style.left = config.x + 'px';
  panel.style.top = config.y + 'px';
  panel.style.width = config.w + 'px';
  panel.style.height = config.h + 'px';

  const header = document.createElement('div');
  header.className = 'panel-header';
  header.innerHTML = `
    <span class="title">${config.title}</span>
    <div class="controls">
      <div class="ctrl-btn ctrl-min"></div>
      <div class="ctrl-btn ctrl-max"></div>
      <div class="ctrl-btn ctrl-close"></div>
    </div>
  `;

  let tabs = '';
  if (config.tabs) {
    const tabsDiv = document.createElement('div');
    tabsDiv.className = 'panel-tabs';
    config.tabs.forEach((t, i) => {
      const tab = document.createElement('div');
      tab.className = 'panel-tab' + (i === 0 ? ' active' : '');
      tab.textContent = t;
      tab.onclick = (e) => {
        tabsDiv.querySelectorAll('.panel-tab').forEach(x => x.classList.remove('active'));
        tab.classList.add('active');
        notify(`Switched to ${t}`);
      };
      tabsDiv.appendChild(tab);
    });
    tabs = tabsDiv;
  }

  const body = document.createElement('div');
  body.className = 'panel-body';

  const resize = document.createElement('div');
  resize.className = 'resize-handle';

  panel.appendChild(header);
  if (tabs) panel.appendChild(tabs);
  panel.appendChild(body);
  panel.appendChild(resize);

  // Drag
  let isDragging = false, dragX, dragY;
  header.addEventListener('mousedown', e => {
    if (e.target.classList.contains('ctrl-btn')) return;
    isDragging = true;
    dragX = e.clientX - panel.offsetLeft;
    dragY = e.clientY - panel.offsetTop;
    panel.style.zIndex = ++panelZIndex;
    panels.forEach(p => p.el.classList.remove('focused'));
    panel.classList.add('focused');
  });

  document.addEventListener('mousemove', e => {
    if (!isDragging) return;
    panel.style.left = (e.clientX - dragX) + 'px';
    panel.style.top = (e.clientY - dragY) + 'px';
  });

  document.addEventListener('mouseup', () => { isDragging = false; });

  // Resize
  let isResizing = false, rStartX, rStartY, rStartW, rStartH;
  resize.addEventListener('mousedown', e => {
    isResizing = true;
    rStartX = e.clientX;
    rStartY = e.clientY;
    rStartW = panel.offsetWidth;
    rStartH = panel.offsetHeight;
    e.stopPropagation();
  });

  document.addEventListener('mousemove', e => {
    if (!isResizing) return;
    panel.style.width = Math.max(150, rStartW + e.clientX - rStartX) + 'px';
    panel.style.height = Math.max(100, rStartH + e.clientY - rStartY) + 'px';
  });

  document.addEventListener('mouseup', () => { isResizing = false; });

  // Focus on click
  panel.addEventListener('mousedown', () => {
    panel.style.zIndex = ++panelZIndex;
    panels.forEach(p => p.el.classList.remove('focused'));
    panel.classList.add('focused');
  });

  // Close
  header.querySelector('.ctrl-close').addEventListener('click', () => {
    panel.style.transition = 'opacity 0.3s, transform 0.3s';
    panel.style.opacity = '0';
    panel.style.transform = 'scale(0.9)';
    setTimeout(() => panel.remove(), 300);
  });

  // Maximize
  let isMaximized = false, prevBounds;
  header.querySelector('.ctrl-max').addEventListener('click', () => {
    if (!isMaximized) {
      prevBounds = { left: panel.style.left, top: panel.style.top, width: panel.style.width, height: panel.style.height };
      const ws = $('#workspace');
      panel.style.left = '0px'; panel.style.top = '0px';
      panel.style.width = ws.offsetWidth + 'px';
      panel.style.height = ws.offsetHeight + 'px';
    } else {
      Object.assign(panel.style, prevBounds);
    }
    isMaximized = !isMaximized;
  });

  // Minimize
  header.querySelector('.ctrl-min').addEventListener('click', () => {
    body.style.display = body.style.display === 'none' ? '' : 'none';
    if (tabs) tabs.style.display = tabs.style.display === 'none' ? '' : 'none';
    resize.style.display = resize.style.display === 'none' ? '' : 'none';
    if (body.style.display === 'none') {
      panel.style.height = '24px';
    } else {
      panel.style.height = config.h + 'px';
    }
  });

  $('#workspace').appendChild(panel);
  const pObj = { el: panel, body, config, id: panel.id };
  panels.push(pObj);
  return pObj;
}

// --- TERMINAL ---
const terminalCommands = {
  help: () => [
    { text: 'Available commands:', cls: 'term-cyan' },
    { text: '  help          - Show this message', cls: 'term-info' },
    { text: '  scan <target> - Scan target system', cls: 'term-info' },
    { text: '  exploit       - Run exploit framework', cls: 'term-info' },
    { text: '  decrypt       - Decrypt intercepted data', cls: 'term-info' },
    { text: '  trace         - Trace network route', cls: 'term-info' },
    { text: '  dump          - Dump memory contents', cls: 'term-info' },
    { text: '  connect       - Connect to remote node', cls: 'term-info' },
    { text: '  status        - System status', cls: 'term-info' },
    { text: '  hack          - You know what this does', cls: 'term-purple' },
    { text: '  clear         - Clear terminal', cls: 'term-info' },
  ],
  scan: () => {
    const results = [];
    results.push({ text: `Scanning subnet ${randInt(10,192)}.${randInt(0,255)}.${randInt(0,255)}.0/24...`, cls: 'term-info' });
    const count = randInt(5, 15);
    for (let i = 0; i < count; i++) {
      const ports = Array.from({length: randInt(1,5)}, () => pick([22,80,443,3306,5432,8080,8443,27017,6379,9200]));
      results.push({ text: `  [+] ${ipAddr()} - Ports: ${ports.join(', ')} - ${pick(['Linux','Windows','FreeBSD','RouterOS'])}`, cls: Math.random()>0.7 ? 'term-warn' : 'term-info' });
    }
    results.push({ text: `Scan complete. ${count} hosts found.`, cls: 'term-blue' });
    return results;
  },
  exploit: () => [
    { text: 'Loading exploit framework v4.2.0...', cls: 'term-info' },
    { text: `[*] Target: ${ipAddr()}`, cls: 'term-info' },
    { text: '[*] Payload: reverse_tcp_quantum_shell', cls: 'term-info' },
    { text: '[*] Encoder: polymorphic/shikata_ga_nai', cls: 'term-warn' },
    { text: `[+] Exploit sent (${randInt(200,2000)} bytes)`, cls: 'term-info' },
    { text: `[+] ${Math.random()>0.3 ? 'Session opened!' : 'Exploit failed - target patched'}`, cls: Math.random()>0.3 ? 'term-info' : 'term-error' },
  ],
  decrypt: () => {
    const lines = [{ text: 'Decrypting intercepted transmission...', cls: 'term-info' }];
    for (let i = 0; i < 3; i++) {
      lines.push({ text: `  Block ${i}: ${Array.from({length:8}, hexWord).join(' ')}`, cls: 'term-warn' });
    }
    lines.push({ text: pick([
      'Decrypted: "The eagle has left the building"',
      'Decrypted: "Rendezvous at coordinates 41.40338, 2.17403"',
      'Decrypted: "Operation BLACKOUT is a go"',
      'Decrypted: "All your base are belong to us"',
      'Decrypted: "The cake is a lie"',
      'Decrypted: "HACK THE PLANET"',
    ]), cls: 'term-purple' });
    return lines;
  },
  trace: () => {
    const lines = [{ text: `Tracing route to ${ipAddr()}...`, cls: 'term-info' }];
    const hops = randInt(8, 16);
    for (let i = 1; i <= hops; i++) {
      lines.push({ text: `  ${i.toString().padStart(2)}  ${ipAddr()}  ${randInt(1,200)}ms ${i===hops ? '*** TARGET REACHED ***' : ''}`, cls: i===hops ? 'term-purple' : 'term-info' });
    }
    return lines;
  },
  dump: () => {
    const lines = [{ text: 'Memory dump @ 0x' + Array.from({length:4}, hex).join(''), cls: 'term-info' }];
    for (let i = 0; i < 8; i++) {
      const addr = (0x7fff0000 + i * 16).toString(16);
      const bytes = Array.from({length:16}, () => hex()).join(' ');
      const ascii = Array.from({length:16}, () => String.fromCharCode(randInt(33, 126))).join('');
      lines.push({ text: `  ${addr}: ${bytes}  |${ascii}|`, cls: 'term-info' });
    }
    return lines;
  },
  connect: () => {
    const ip = ipAddr();
    return [
      { text: `Connecting to ${ip}:${pick([22,443,8080])}...`, cls: 'term-info' },
      { text: 'SSH-2.0-OpenSSH_8.9 Quantum Edition', cls: 'term-info' },
      { text: `Authenticating with RSA-4096 key...`, cls: 'term-warn' },
      { text: `Welcome to ${pick(['darknode','shadowbox','ghostserver','blacksite'])}-${randInt(1,99)}`, cls: 'term-purple' },
      { text: `root@${ip}:~# `, cls: 'term-info' },
    ];
  },
  status: () => [
    { text: '=== SYSTEM STATUS ===', cls: 'term-cyan' },
    { text: `  CPU: ${randInt(30,95)}% | Cores: 8 | Freq: ${(rand(3.5,5.2)).toFixed(1)} THz`, cls: 'term-info' },
    { text: `  RAM: ${randInt(40,90)}% | ${randInt(50,100)}PB / 128PB`, cls: 'term-info' },
    { text: `  NET: ↑${(rand(1,50)).toFixed(1)}MB/s ↓${(rand(5,200)).toFixed(1)}MB/s`, cls: 'term-info' },
    { text: `  TOR: ${randInt(3,7)} relays | Latency: ${randInt(50,300)}ms`, cls: 'term-info' },
    { text: `  Active sessions: ${randInt(5,30)}`, cls: 'term-info' },
    { text: `  Threats blocked: ${randInt(100,9999)}`, cls: 'term-warn' },
  ],
  hack: () => [
    { text: '> INITIATING HACK SEQUENCE', cls: 'term-error' },
    { text: '> ...', cls: 'term-info' },
    { text: `> ACCESS GRANTED. Welcome, ${pick(['Neo','Trinity','Morpheus','Zero Cool','Crash Override','Acid Burn','The Plague','L0rd N1k0n','Zer0 C00l','c3r34lk1ll3r'])}`, cls: 'term-purple' },
  ],
  clear: () => 'CLEAR',
};

function createTerminal(body) {
  const output = document.createElement('div');
  output.className = 'terminal-output';
  output.innerHTML = `<div class="term-line term-cyan">root@nexus-core:~# Welcome to N3XUS Terminal</div>`;

  const inputLine = document.createElement('div');
  inputLine.className = 'term-input-line';
  inputLine.innerHTML = `<span>root@nexus:~# </span>`;
  const input = document.createElement('input');
  input.className = 'term-input';
  input.spellcheck = false;
  inputLine.appendChild(input);

  body.style.display = 'flex';
  body.style.flexDirection = 'column';
  body.appendChild(output);
  body.appendChild(inputLine);

  input.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      const cmd = input.value.trim().toLowerCase();
      addTermLine(output, `root@nexus:~# ${input.value}`, 'term-prompt');
      input.value = '';

      if (cmd === '') return;

      const basecmd = cmd.split(' ')[0];
      if (terminalCommands[basecmd]) {
        const result = terminalCommands[basecmd]();
        if (result === 'CLEAR') {
          output.innerHTML = '';
          return;
        }
        result.forEach(l => addTermLine(output, l.text, l.cls));
      } else {
        addTermLine(output, `bash: ${basecmd}: command not found. Try 'help'`, 'term-error');
      }
    }
  });

  input.focus();
  body.addEventListener('click', () => input.focus());
  return { output, input };
}

function addTermLine(container, text, cls) {
  const line = document.createElement('div');
  line.className = `term-line ${cls || ''}`;
  line.textContent = text;
  container.appendChild(line);
  container.scrollTop = container.scrollHeight;
}

// --- LIVE LOG FEED ---
function createLogFeed(body) {
  const output = document.createElement('div');
  output.className = 'terminal-output';
  body.appendChild(output);

  const logTypes = [
    () => ({ text: `[${timestamp()}] INFO  Connection from ${ipAddr()}:${randInt(1024,65535)}`, cls: 'term-info' }),
    () => ({ text: `[${timestamp()}] WARN  Brute force detected: ${ipAddr()} (attempt ${randInt(1,999)})`, cls: 'term-warn' }),
    () => ({ text: `[${timestamp()}] ERROR Segfault at 0x${Array.from({length:4},hex).join('')}`, cls: 'term-error' }),
    () => ({ text: `[${timestamp()}] INFO  Packet intercepted: ${randInt(64,1500)} bytes from ${ipAddr()}`, cls: 'term-info' }),
    () => ({ text: `[${timestamp()}] DEBUG Auth token: ${uuid().substring(0,8)}...`, cls: 'term-blue' }),
    () => ({ text: `[${timestamp()}] WARN  SSL cert mismatch on ${pick(['api','cdn','auth','db'])}.${pick(['shadow','dark','black','ghost'])}.net`, cls: 'term-warn' }),
    () => ({ text: `[${timestamp()}] INFO  Encrypted tunnel ${randInt(1,99)} active: ${randInt(100,9999)} packets`, cls: 'term-info' }),
    () => ({ text: `[${timestamp()}] CRIT  Intrusion attempt from ${ipAddr()} - BLOCKED`, cls: 'term-error' }),
    () => ({ text: `[${timestamp()}] INFO  DNS query: ${pick(['mx','ns','a','aaaa','cname'])}.${pick(['target','evil','shadow'])}.${pick(['com','net','onion'])}`, cls: 'term-info' }),
    () => ({ text: `[${timestamp()}] DEBUG Decrypted payload: ${randInt(1,500)}KB [${pick(['AES-256','ChaCha20','Quantum'])}]`, cls: 'term-purple' }),
  ];

  function addLog() {
    if (!document.body.contains(output)) return;
    const log = pick(logTypes)();
    addTermLine(output, log.text, log.cls);
    if (output.children.length > 200) output.removeChild(output.firstChild);
    setTimeout(addLog, rand(100, 800));
  }
  addLog();
}

function timestamp() {
  const d = new Date();
  return d.toTimeString().split(' ')[0] + '.' + d.getMilliseconds().toString().padStart(3, '0');
}

// --- NETWORK GRAPH (Canvas based) ---
function createNetworkGraph(body) {
  const canvas = document.createElement('canvas');
  canvas.className = 'graph-canvas';
  body.appendChild(canvas);

  const nodes = Array.from({length: 30}, (_, i) => ({
    x: rand(30, 370), y: rand(30, 270),
    vx: rand(-0.3, 0.3), vy: rand(-0.3, 0.3),
    r: rand(3, 8), color: pick(['#00ff41', '#00ffff', '#ff0040', '#ffbf00', '#bf00ff']),
    label: pick(['SRV', 'NOD', 'GW', 'FW', 'DB', 'API', 'DNS', 'TOR', 'VPN', 'BOT']) + '-' + randInt(1,99),
    pulse: rand(0, Math.PI * 2),
  }));

  const edges = [];
  for (let i = 0; i < nodes.length; i++) {
    const numConn = randInt(1, 3);
    for (let j = 0; j < numConn; j++) {
      const target = randInt(0, nodes.length);
      if (target !== i) edges.push([i, target, rand(0.2, 1)]);
    }
  }

  let hoveredNode = null;

  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    hoveredNode = null;
    for (const n of nodes) {
      if (Math.hypot(n.x - mx, n.y - my) < n.r + 5) { hoveredNode = n; break; }
    }
    canvas.style.cursor = hoveredNode ? 'pointer' : 'crosshair';
  });

  canvas.addEventListener('click', e => {
    if (hoveredNode) {
      notify(`Node ${hoveredNode.label}: ${ipAddr()} [${pick(['ACTIVE','IDLE','SCANNING','ENCRYPTED'])}]`);
    }
  });

  function animate() {
    if (!document.body.contains(canvas)) return;
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');

    // Edges
    for (const [a, b, opacity] of edges) {
      ctx.beginPath();
      ctx.moveTo(nodes[a].x, nodes[a].y);
      ctx.lineTo(nodes[b].x, nodes[b].y);
      ctx.strokeStyle = `rgba(0,255,65,${opacity * 0.3})`;
      ctx.lineWidth = 0.5;
      ctx.stroke();

      // Packet animation
      if (Math.random() > 0.98) {
        const t = (Date.now() % 2000) / 2000;
        const px = nodes[a].x + (nodes[b].x - nodes[a].x) * t;
        const py = nodes[a].y + (nodes[b].y - nodes[a].y) * t;
        ctx.beginPath();
        ctx.arc(px, py, 2, 0, Math.PI * 2);
        ctx.fillStyle = '#00ffff';
        ctx.fill();
      }
    }

    // Nodes
    const time = Date.now() / 1000;
    for (const n of nodes) {
      n.x += n.vx; n.y += n.vy;
      if (n.x < 10 || n.x > w - 10) n.vx *= -1;
      if (n.y < 10 || n.y > h - 10) n.vy *= -1;

      const pulseR = n.r + Math.sin(time * 2 + n.pulse) * 2;

      // Glow
      ctx.beginPath();
      ctx.arc(n.x, n.y, pulseR + 8, 0, Math.PI * 2);
      ctx.fillStyle = n.color.replace(')', ',0.1)').replace('rgb', 'rgba');
      ctx.fill();

      // Node
      ctx.beginPath();
      ctx.arc(n.x, n.y, pulseR, 0, Math.PI * 2);
      ctx.fillStyle = n === hoveredNode ? '#ffffff' : n.color;
      ctx.fill();

      // Label
      ctx.font = '8px "Share Tech Mono"';
      ctx.fillStyle = 'rgba(0,255,65,0.7)';
      ctx.fillText(n.label, n.x + n.r + 4, n.y + 3);
    }

    requestAnimationFrame(animate);
  }
  animate();
}

// --- GRAPHIC EQ ---
function createEQ(body) {
  const container = document.createElement('div');
  container.className = 'eq-container';
  body.appendChild(container);

  const numBars = 48;
  const bars = [];
  for (let i = 0; i < numBars; i++) {
    const bar = document.createElement('div');
    bar.className = 'eq-bar';
    container.appendChild(bar);
    bars.push(bar);
  }

  function animateEQ() {
    if (!document.body.contains(container)) return;
    const time = Date.now() / 1000;
    for (let i = 0; i < bars.length; i++) {
      const h = Math.abs(Math.sin(time * 3 + i * 0.3)) * 60 +
                Math.abs(Math.sin(time * 7 + i * 0.5)) * 30 +
                Math.random() * 10;
      bars[i].style.height = h + '%';
    }
    requestAnimationFrame(animateEQ);
  }
  animateEQ();
}

// --- WAVEFORM ---
function createWaveform(body) {
  const canvas = document.createElement('canvas');
  canvas.className = 'graph-canvas';
  body.appendChild(canvas);

  function draw() {
    if (!document.body.contains(canvas)) return;
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    const time = Date.now() / 1000;

    // Multiple waveforms
    const waves = [
      { freq: 3, amp: 0.3, color: 'rgba(0,255,65,0.8)', width: 2 },
      { freq: 5, amp: 0.2, color: 'rgba(0,255,255,0.6)', width: 1.5 },
      { freq: 8, amp: 0.15, color: 'rgba(255,0,64,0.4)', width: 1 },
      { freq: 12, amp: 0.1, color: 'rgba(191,0,255,0.3)', width: 1 },
    ];

    // Grid
    ctx.strokeStyle = 'rgba(0,68,0,0.3)';
    ctx.lineWidth = 0.5;
    for (let x = 0; x < w; x += 20) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }
    for (let y = 0; y < h; y += 20) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }

    // Center line
    ctx.strokeStyle = 'rgba(0,68,0,0.6)';
    ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();

    for (const wave of waves) {
      ctx.beginPath();
      ctx.strokeStyle = wave.color;
      ctx.lineWidth = wave.width;
      for (let x = 0; x < w; x++) {
        const y = h/2 + Math.sin(x * 0.02 * wave.freq + time * wave.freq) * h * wave.amp +
                  Math.sin(x * 0.01 * wave.freq + time * 2) * h * wave.amp * 0.5;
        x === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    // Measurement crosshair
    ctx.setLineDash([3, 3]);
    ctx.strokeStyle = 'rgba(255,191,0,0.4)';
    const cx = w * (0.5 + 0.3 * Math.sin(time * 0.5));
    ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, h); ctx.stroke();
    ctx.setLineDash([]);

    // Value readout
    ctx.font = '9px "Share Tech Mono"';
    ctx.fillStyle = '#ffbf00';
    ctx.fillText(`f=${(Math.sin(time)*500+1000).toFixed(1)}Hz`, cx + 5, 15);
    ctx.fillText(`A=${(Math.sin(time*2)*0.5+0.5).toFixed(3)}V`, cx + 5, 27);

    requestAnimationFrame(draw);
  }
  draw();
}

// --- LIVE CHART (like stock/monitoring) ---
function createLiveChart(body, opts = {}) {
  const canvas = document.createElement('canvas');
  canvas.className = 'graph-canvas';
  body.appendChild(canvas);

  const datasets = [
    { data: [], color: '#00ff41', label: opts.label1 || 'THROUGHPUT' },
    { data: [], color: '#00ffff', label: opts.label2 || 'LATENCY' },
    { data: [], color: '#ff0040', label: opts.label3 || 'ERRORS' },
  ];

  // Seed data
  datasets.forEach(ds => {
    for (let i = 0; i < 100; i++) ds.data.push(rand(10, 90));
  });

  function draw() {
    if (!document.body.contains(canvas)) return;
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');

    // Push new data
    datasets.forEach(ds => {
      const last = ds.data[ds.data.length - 1];
      ds.data.push(Math.max(5, Math.min(95, last + rand(-8, 8))));
      if (ds.data.length > 200) ds.data.shift();
    });

    // Grid
    ctx.strokeStyle = 'rgba(0,68,0,0.3)';
    ctx.lineWidth = 0.5;
    for (let y = 0; y < h; y += h/5) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
      ctx.font = '8px "Share Tech Mono"';
      ctx.fillStyle = 'rgba(0,255,65,0.4)';
      ctx.fillText(Math.round((1 - y/h) * 100), 2, y + 10);
    }

    // Lines
    datasets.forEach(ds => {
      ctx.beginPath();
      ctx.strokeStyle = ds.color;
      ctx.lineWidth = 1.5;
      const step = w / (ds.data.length - 1);
      ds.data.forEach((v, i) => {
        const x = i * step;
        const y = h - (v / 100) * h;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      });
      ctx.stroke();

      // Fill
      ctx.lineTo(w, h);
      ctx.lineTo(0, h);
      ctx.fillStyle = ds.color.replace(')', ',0.05)').replace('rgb', 'rgba').replace('#', '');
      // Convert hex to rgba for fill
      const r = parseInt(ds.color.slice(1,3),16);
      const g = parseInt(ds.color.slice(3,5),16);
      const b = parseInt(ds.color.slice(5,7),16);
      ctx.fillStyle = `rgba(${r},${g},${b},0.05)`;
      ctx.fill();
    });

    // Legend
    datasets.forEach((ds, i) => {
      ctx.font = '9px "Share Tech Mono"';
      ctx.fillStyle = ds.color;
      ctx.fillText(`■ ${ds.label}: ${ds.data[ds.data.length-1].toFixed(1)}`, w - 140, 14 + i * 14);
    });

    requestAnimationFrame(draw);
  }
  draw();
}

// --- HEX DUMP ---
function createHexDump(body) {
  const container = document.createElement('div');
  container.className = 'hex-dump';
  body.appendChild(container);

  function updateHex() {
    if (!document.body.contains(container)) return;
    let html = '';
    const baseAddr = randInt(0x10000000, 0x7FFFFFFF);
    for (let i = 0; i < 30; i++) {
      const addr = (baseAddr + i * 16).toString(16).padStart(8, '0');
      const bytes = Array.from({length: 16}, () => hex());
      const ascii = bytes.map(b => {
        const c = parseInt(b, 16);
        return (c >= 32 && c <= 126) ? String.fromCharCode(c) : '.';
      }).join('');

      // Highlight some bytes randomly
      const highlighted = bytes.map(b =>
        Math.random() > 0.92 ? `<span style="color:var(--red)">${b}</span>` :
        Math.random() > 0.95 ? `<span style="color:var(--cyan)">${b}</span>` : b
      );

      html += `<span style="color:var(--cyan)">${addr}</span>  ${highlighted.join(' ')}  <span style="color:#666">${ascii}</span>\n`;
    }
    container.innerHTML = html;
    setTimeout(updateHex, 500);
  }
  updateHex();
}

// --- RADAR ---
function createRadar(body) {
  const canvas = document.createElement('canvas');
  canvas.className = 'graph-canvas';
  body.appendChild(canvas);

  const blips = Array.from({length: 12}, () => ({
    angle: rand(0, Math.PI * 2),
    dist: rand(0.1, 0.9),
    fadeIn: rand(0, Math.PI * 2),
    label: pick(['UAV','SAT','SIG','TGT','UNK','DRONE','BOGEY']) + '-' + randInt(1,99),
    threat: Math.random() > 0.7,
  }));

  function draw() {
    if (!document.body.contains(canvas)) return;
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    const cx = w/2, cy = h/2;
    const r = Math.min(cx, cy) - 20;
    const time = Date.now() / 1000;
    const sweep = (time * 0.8) % (Math.PI * 2);

    // Rings
    for (let i = 1; i <= 4; i++) {
      ctx.beginPath();
      ctx.arc(cx, cy, r * i / 4, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(0,255,65,0.2)';
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    // Cross
    ctx.strokeStyle = 'rgba(0,255,65,0.15)';
    ctx.beginPath(); ctx.moveTo(cx-r, cy); ctx.lineTo(cx+r, cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx, cy-r); ctx.lineTo(cx, cy+r); ctx.stroke();

    // Sweep
    const gradient = ctx.createConicalGradient ? null : null; // Fallback
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, r, sweep - 0.5, sweep);
    ctx.fillStyle = 'rgba(0,255,65,0.15)';
    ctx.fill();

    // Sweep line
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(sweep) * r, cy + Math.sin(sweep) * r);
    ctx.strokeStyle = 'rgba(0,255,65,0.8)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Blips
    for (const b of blips) {
      const bx = cx + Math.cos(b.angle) * b.dist * r;
      const by = cy + Math.sin(b.angle) * b.dist * r;

      // Fade based on sweep
      let diff = sweep - b.angle;
      if (diff < 0) diff += Math.PI * 2;
      const alpha = Math.max(0, 1 - diff / (Math.PI * 1.5));

      if (alpha > 0.05) {
        ctx.beginPath();
        ctx.arc(bx, by, 3, 0, Math.PI * 2);
        const col = b.threat ? `rgba(255,0,64,${alpha})` : `rgba(0,255,65,${alpha})`;
        ctx.fillStyle = col;
        ctx.fill();

        if (alpha > 0.3) {
          ctx.font = '7px "Share Tech Mono"';
          ctx.fillStyle = `rgba(0,255,255,${alpha * 0.8})`;
          ctx.fillText(b.label, bx + 6, by - 4);
        }
      }

      // Slowly move blips
      b.angle += rand(-0.002, 0.002);
      b.dist = Math.max(0.05, Math.min(0.95, b.dist + rand(-0.001, 0.001)));
    }

    // Center dot
    ctx.beginPath();
    ctx.arc(cx, cy, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#00ff41';
    ctx.fill();

    // Range text
    ctx.font = '8px "Share Tech Mono"';
    ctx.fillStyle = 'rgba(0,255,65,0.4)';
    ctx.fillText('50km', cx + r/4, cy + 12);
    ctx.fillText('100km', cx + r/2, cy + 12);
    ctx.fillText('200km', cx + 3*r/4, cy + 12);

    requestAnimationFrame(draw);
  }
  draw();
}

// --- FAKE VIDEO FEED ---
function createVideoFeed(body, label) {
  const container = document.createElement('div');
  container.className = 'video-feed';

  const canvas = document.createElement('canvas');
  container.appendChild(canvas);

  const overlay = document.createElement('div');
  overlay.className = 'video-overlay rec';
  overlay.textContent = `REC ${label || 'CAM-' + randInt(1,12)}`;
  container.appendChild(overlay);

  const overlay2 = document.createElement('div');
  overlay2.className = 'video-overlay';
  overlay2.style.cssText = 'bottom:4px;top:auto;right:4px;left:auto;color:var(--green);text-shadow:none;font-size:8px;';
  container.appendChild(overlay2);

  body.appendChild(container);

  function draw() {
    if (!document.body.contains(canvas)) return;
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    const time = Date.now() / 1000;

    // Static noise background
    const imgData = ctx.createImageData(w, h);
    for (let i = 0; i < imgData.data.length; i += 4) {
      const v = Math.random() * 25;
      imgData.data[i] = v;
      imgData.data[i+1] = v + Math.random() * 10;
      imgData.data[i+2] = v;
      imgData.data[i+3] = 255;
    }
    ctx.putImageData(imgData, 0, 0);

    // Fake thermal blobs
    for (let b = 0; b < 3; b++) {
      const bx = w * (0.3 + 0.4 * Math.sin(time * 0.3 + b * 2));
      const by = h * (0.3 + 0.3 * Math.cos(time * 0.2 + b * 3));
      const gradient = ctx.createRadialGradient(bx, by, 0, bx, by, 30 + Math.sin(time + b) * 10);
      gradient.addColorStop(0, 'rgba(0,255,65,0.3)');
      gradient.addColorStop(0.5, 'rgba(0,255,65,0.1)');
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, w, h);

      // Box around blob
      ctx.strokeStyle = 'rgba(255,0,64,0.6)';
      ctx.lineWidth = 1;
      ctx.strokeRect(bx - 25, by - 25, 50, 50);
      ctx.font = '7px "Share Tech Mono"';
      ctx.fillStyle = 'rgba(255,0,64,0.8)';
      ctx.fillText(`TGT-${b+1}`, bx - 23, by - 28);
    }

    // Crosshair
    ctx.strokeStyle = 'rgba(0,255,255,0.3)';
    ctx.lineWidth = 0.5;
    ctx.beginPath(); ctx.moveTo(w/2, 0); ctx.lineTo(w/2, h); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();
    ctx.beginPath(); ctx.arc(w/2, h/2, 30, 0, Math.PI*2); ctx.stroke();

    // Scanline
    const scanY = (time * 100) % h;
    ctx.fillStyle = 'rgba(0,255,65,0.05)';
    ctx.fillRect(0, scanY, w, 3);

    // Timestamp
    overlay2.textContent = `${new Date().toISOString()} | ${w}x${h} | ${randInt(24,30)}fps`;

    requestAnimationFrame(draw);
  }
  draw();
}

// --- DATA TABLE ---
function createDataTable(body) {
  const table = document.createElement('table');
  table.className = 'data-table';
  const thead = document.createElement('thead');
  thead.innerHTML = '<tr><th>IP</th><th>PORT</th><th>PROTO</th><th>STATUS</th><th>LATENCY</th><th>COUNTRY</th></tr>';
  table.appendChild(thead);
  const tbody = document.createElement('tbody');
  table.appendChild(tbody);

  const wrapper = document.createElement('div');
  wrapper.style.cssText = 'overflow-y:auto;height:100%;';
  wrapper.appendChild(table);
  body.appendChild(wrapper);

  const countries = ['US','RU','CN','DE','JP','BR','UK','FR','KR','IN','AU','NL','SE','UA','IR'];
  const statuses = ['OPEN','CLOSED','FILTERED','HONEYPOT','COMPROMISED'];
  const protocols = ['TCP','UDP','ICMP','SSH','HTTPS','DNS','FTP','SMTP'];
  const statusColors = { OPEN: 'var(--green)', CLOSED: '#666', FILTERED: 'var(--amber)', HONEYPOT: 'var(--red)', COMPROMISED: 'var(--purple)' };

  function addRow() {
    if (!document.body.contains(tbody)) return;
    const status = pick(statuses);
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${ipAddr()}</td>
      <td>${pick([22,80,443,3306,5432,8080,8443,27017,6379])}</td>
      <td>${pick(protocols)}</td>
      <td style="color:${statusColors[status]}">${status}</td>
      <td>${randInt(1,500)}ms</td>
      <td>${pick(countries)}</td>
    `;
    tr.style.cursor = 'pointer';
    tr.addEventListener('click', () => {
      notify(`Targeting ${tr.children[0].textContent}:${tr.children[1].textContent}`);
      $$('.data-table tr').forEach(r => r.style.background = '');
      tr.style.background = 'rgba(0,255,65,0.1)';
    });
    tbody.insertBefore(tr, tbody.firstChild);
    if (tbody.children.length > 50) tbody.removeChild(tbody.lastChild);
    setTimeout(addRow, rand(300, 1500));
  }
  addRow();
}

// --- SPECTRUM / HEATMAP ---
function createSpectrum(body) {
  const canvas = document.createElement('canvas');
  canvas.className = 'graph-canvas';
  body.appendChild(canvas);

  const history = [];

  function draw() {
    if (!document.body.contains(canvas)) return;
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    const time = Date.now() / 1000;

    // Generate new row
    const cols = 64;
    const row = [];
    for (let i = 0; i < cols; i++) {
      const v = Math.abs(Math.sin(time * 2 + i * 0.2)) * 0.5 +
                Math.abs(Math.sin(time * 5 + i * 0.5)) * 0.3 +
                Math.random() * 0.2;
      row.push(Math.min(1, v));
    }
    history.push(row);
    if (history.length > 60) history.shift();

    // Draw heatmap
    const cellW = w / cols;
    const cellH = h / 60;
    for (let y = 0; y < history.length; y++) {
      for (let x = 0; x < cols; x++) {
        const v = history[y][x];
        const r = Math.min(255, v * 500);
        const g = Math.min(255, v * 255);
        const b = Math.max(0, 50 - v * 100);
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        ctx.fillRect(x * cellW, y * cellH, cellW + 1, cellH + 1);
      }
    }

    // Labels
    ctx.font = '8px "Share Tech Mono"';
    ctx.fillStyle = 'rgba(0,255,255,0.8)';
    ctx.fillText('FREQ SPECTRUM ANALYSIS', 4, 12);
    ctx.fillText(`${(Math.sin(time)*500+2000).toFixed(0)}Hz - ${(Math.sin(time*0.5)*1000+5000).toFixed(0)}Hz`, 4, h - 4);

    requestAnimationFrame(draw);
  }
  draw();
}

// --- PIE/DONUT CHART ---
function createDonutChart(body) {
  const canvas = document.createElement('canvas');
  canvas.className = 'graph-canvas';
  body.appendChild(canvas);

  const segments = [
    { label: 'ENCRYPTED', value: 42, color: '#00ff41' },
    { label: 'SUSPICIOUS', value: 23, color: '#ffbf00' },
    { label: 'MALICIOUS', value: 15, color: '#ff0040' },
    { label: 'UNKNOWN', value: 12, color: '#bf00ff' },
    { label: 'CLEAN', value: 8, color: '#0080ff' },
  ];

  function draw() {
    if (!document.body.contains(canvas)) return;
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    const cx = w * 0.4, cy = h / 2;
    const r = Math.min(cx, cy) - 20;
    const time = Date.now() / 1000;

    // Wobble values slightly
    const total = segments.reduce((s, seg) => s + seg.value, 0);
    let angle = -Math.PI / 2 + Math.sin(time * 0.5) * 0.1;

    for (const seg of segments) {
      const sliceAngle = (seg.value / total) * Math.PI * 2;
      ctx.beginPath();
      ctx.arc(cx, cy, r, angle, angle + sliceAngle);
      ctx.arc(cx, cy, r * 0.55, angle + sliceAngle, angle, true);
      ctx.closePath();
      ctx.fillStyle = seg.color;
      ctx.globalAlpha = 0.8;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.stroke();

      // Label
      const midAngle = angle + sliceAngle / 2;
      const lx = cx + Math.cos(midAngle) * (r * 0.78);
      const ly = cy + Math.sin(midAngle) * (r * 0.78);
      ctx.font = '8px "Share Tech Mono"';
      ctx.fillStyle = '#fff';
      ctx.fillText(`${Math.round(seg.value/total*100)}%`, lx - 10, ly + 3);

      angle += sliceAngle;
    }

    // Center text
    ctx.font = '10px "Orbitron"';
    ctx.fillStyle = '#00ffff';
    ctx.textAlign = 'center';
    ctx.fillText('TRAFFIC', cx, cy - 4);
    ctx.fillText('ANALYSIS', cx, cy + 10);
    ctx.textAlign = 'left';

    // Legend
    const lx = w * 0.72;
    segments.forEach((seg, i) => {
      ctx.fillStyle = seg.color;
      ctx.fillRect(lx, 15 + i * 18, 8, 8);
      ctx.font = '9px "Share Tech Mono"';
      ctx.fillText(`${seg.label}: ${seg.value}`, lx + 12, 23 + i * 18);
    });

    // Animate values slightly
    segments.forEach(seg => {
      seg.value = Math.max(3, seg.value + rand(-0.3, 0.3));
    });

    requestAnimationFrame(draw);
  }
  draw();
}

// --- BAR CHART ---
function createBarChart(body) {
  const canvas = document.createElement('canvas');
  canvas.className = 'graph-canvas';
  body.appendChild(canvas);

  const data = [
    { label: 'SSH', value: rand(30,90), color: '#00ff41' },
    { label: 'HTTP', value: rand(40,95), color: '#00ffff' },
    { label: 'DNS', value: rand(20,60), color: '#ffbf00' },
    { label: 'FTP', value: rand(10,40), color: '#ff0040' },
    { label: 'SMTP', value: rand(15,50), color: '#bf00ff' },
    { label: 'TOR', value: rand(30,80), color: '#0080ff' },
    { label: 'VPN', value: rand(40,70), color: '#00ff41' },
    { label: 'IRC', value: rand(5,30), color: '#ffbf00' },
  ];

  function draw() {
    if (!document.body.contains(canvas)) return;
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');

    const barW = (w - 40) / data.length;
    const maxH = h - 30;

    // Grid
    ctx.strokeStyle = 'rgba(0,68,0,0.3)';
    for (let y = 0; y < 5; y++) {
      const yp = 10 + (maxH / 5) * y;
      ctx.beginPath(); ctx.moveTo(30, yp); ctx.lineTo(w, yp); ctx.stroke();
    }

    data.forEach((d, i) => {
      // Animate
      d.value = Math.max(5, Math.min(100, d.value + rand(-1.5, 1.5)));

      const barH = (d.value / 100) * (maxH - 10);
      const x = 35 + i * barW;
      const y = maxH - barH + 10;

      // Bar
      const gradient = ctx.createLinearGradient(x, y, x, maxH + 10);
      gradient.addColorStop(0, d.color);
      gradient.addColorStop(1, d.color.replace(')', ',0.2)').replace('rgb', 'rgba'));
      ctx.fillStyle = gradient;
      ctx.fillRect(x + 2, y, barW - 6, barH);

      // Glow
      ctx.shadowColor = d.color;
      ctx.shadowBlur = 5;
      ctx.fillRect(x + 2, y, barW - 6, 2);
      ctx.shadowBlur = 0;

      // Label
      ctx.font = '7px "Share Tech Mono"';
      ctx.fillStyle = 'rgba(0,255,65,0.8)';
      ctx.textAlign = 'center';
      ctx.fillText(d.label, x + barW/2, maxH + 20);
      ctx.fillStyle = d.color;
      ctx.fillText(d.value.toFixed(0), x + barW/2, y - 4);
      ctx.textAlign = 'left';
    });

    requestAnimationFrame(draw);
  }
  draw();
}

// --- WORLD MAP (ASCII-ish) ---
function createWorldMap(body) {
  const container = document.createElement('div');
  container.style.cssText = 'width:100%;height:100%;position:relative;overflow:hidden;';
  body.appendChild(container);

  // --- HUD overlay canvas for labels/stats ---
  const hudCanvas = document.createElement('canvas');
  hudCanvas.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:2;';
  container.appendChild(hudCanvas);

  // --- Three.js setup ---
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
  camera.position.z = 3.2;

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setClearColor(0x000000, 0);
  container.insertBefore(renderer.domElement, hudCanvas);
  renderer.domElement.style.cssText = 'width:100%;height:100%;position:absolute;top:0;left:0;';

  const globeGroup = new THREE.Group();
  scene.add(globeGroup);

  const GLOBE_R = 1.0;

  // --- Wireframe sphere (latitude/longitude lines) ---
  function buildWireframeGlobe() {
    const material = new THREE.LineBasicMaterial({ color: 0x004400, transparent: true, opacity: 0.5 });
    const brightMat = new THREE.LineBasicMaterial({ color: 0x00ff41, transparent: true, opacity: 0.15 });

    // Latitude lines
    for (let lat = -80; lat <= 80; lat += 20) {
      const phi = (90 - lat) * Math.PI / 180;
      const r = GLOBE_R * Math.sin(phi);
      const y = GLOBE_R * Math.cos(phi);
      const pts = [];
      for (let i = 0; i <= 72; i++) {
        const theta = (i / 72) * Math.PI * 2;
        pts.push(new THREE.Vector3(r * Math.cos(theta), y, r * Math.sin(theta)));
      }
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      globeGroup.add(new THREE.Line(geom, lat === 0 ? brightMat : material));
    }

    // Longitude lines
    for (let lon = 0; lon < 360; lon += 20) {
      const theta = lon * Math.PI / 180;
      const pts = [];
      for (let i = 0; i <= 72; i++) {
        const phi = (i / 72) * Math.PI;
        pts.push(new THREE.Vector3(
          GLOBE_R * Math.sin(phi) * Math.cos(theta),
          GLOBE_R * Math.cos(phi),
          GLOBE_R * Math.sin(phi) * Math.sin(theta)
        ));
      }
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      globeGroup.add(new THREE.Line(geom, (lon === 0 || lon === 180) ? brightMat : material));
    }

    // Outer glow ring (equator emphasis)
    const glowMat = new THREE.LineBasicMaterial({ color: 0x00ff41, transparent: true, opacity: 0.08 });
    for (let offset = 0.01; offset <= 0.03; offset += 0.01) {
      const pts = [];
      for (let i = 0; i <= 72; i++) {
        const theta = (i / 72) * Math.PI * 2;
        pts.push(new THREE.Vector3((GLOBE_R + offset) * Math.cos(theta), 0, (GLOBE_R + offset) * Math.sin(theta)));
      }
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      globeGroup.add(new THREE.Line(geom, glowMat));
    }
  }
  buildWireframeGlobe();

  // --- Atmosphere shell ---
  const atmosGeom = new THREE.SphereGeometry(GLOBE_R * 1.02, 32, 32);
  const atmosMat = new THREE.MeshBasicMaterial({
    color: 0x00ff41, transparent: true, opacity: 0.03, side: THREE.BackSide
  });
  globeGroup.add(new THREE.Mesh(atmosGeom, atmosMat));

  // --- lat/lon → 3D helper ---
  function latLonToVec3(lat, lon, radius) {
    const phi = (90 - lat) * Math.PI / 180;
    const theta = (lon + 180) * Math.PI / 180;
    return new THREE.Vector3(
      -radius * Math.sin(phi) * Math.cos(theta),
      radius * Math.cos(phi),
      radius * Math.sin(phi) * Math.sin(theta)
    );
  }

  // --- Real coastline outlines from Natural Earth 110m ---
  const coastlineGroup = new THREE.Group();
  globeGroup.add(coastlineGroup);

  // Outline material (bright green wireframe coastlines)
  const coastMat = new THREE.LineBasicMaterial({
    color: 0x00ff41, transparent: true, opacity: 0.7
  });
  // Subtle fill glow material
  const coastGlowMat = new THREE.LineBasicMaterial({
    color: 0x00ff41, transparent: true, opacity: 0.15
  });

  fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')
    .then(r => r.json())
    .then(world => {
      const land = topojson.feature(world, world.objects.land);

      // Process each polygon/multipolygon
      const geometries = land.type === 'FeatureCollection' ? land.features.map(f => f.geometry) : [land.geometry || land];

      geometries.forEach(geom => {
        let rings = [];
        if (geom.type === 'Polygon') {
          rings = geom.coordinates;
        } else if (geom.type === 'MultiPolygon') {
          geom.coordinates.forEach(poly => {
            rings = rings.concat(poly);
          });
        }

        rings.forEach(ring => {
          const points = [];
          const innerPoints = []; // slightly smaller for fill effect

          for (let i = 0; i < ring.length; i++) {
            const [lon, lat] = ring[i];
            points.push(latLonToVec3(lat, lon, GLOBE_R * 1.003));
            innerPoints.push(latLonToVec3(lat, lon, GLOBE_R * 1.001));
          }

          if (points.length < 2) return;

          // Main coastline outline
          const lineGeom = new THREE.BufferGeometry().setFromPoints(points);
          coastlineGroup.add(new THREE.Line(lineGeom, coastMat));

          // Inner glow line (slightly recessed, dimmer)
          const glowGeom = new THREE.BufferGeometry().setFromPoints(innerPoints);
          coastlineGroup.add(new THREE.Line(glowGeom, coastGlowMat));
        });
      });

      // Also load country borders for extra detail
      return fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
    })
    .then(r => r.json())
    .then(world => {
      // Extract internal borders using topojson.mesh with filter
      const borders = topojson.mesh(world, world.objects.countries, (a, b) => a !== b);

      const borderMat = new THREE.LineBasicMaterial({
        color: 0x004400, transparent: true, opacity: 0.35
      });

      // borders is a MultiLineString
      if (borders.type === 'MultiLineString') {
        borders.coordinates.forEach(line => {
          const points = [];
          for (let i = 0; i < line.length; i++) {
            const [lon, lat] = line[i];
            points.push(latLonToVec3(lat, lon, GLOBE_R * 1.002));
          }
          if (points.length >= 2) {
            const geom = new THREE.BufferGeometry().setFromPoints(points);
            coastlineGroup.add(new THREE.Line(geom, borderMat));
          }
        });
      }
    })
    .catch(err => {
      console.warn('Failed to load coastline data, falling back to dot cloud', err);
      // Fallback: simple dot cloud if fetch fails
      const boxes = [
        { latMin: 25, latMax: 70, lonMin: -140, lonMax: -55 },
        { latMin: -55, latMax: 10, lonMin: -80, lonMax: -35 },
        { latMin: 35, latMax: 70, lonMin: -10, lonMax: 40 },
        { latMin: -35, latMax: 35, lonMin: -18, lonMax: 50 },
        { latMin: 10, latMax: 70, lonMin: 60, lonMax: 180 },
        { latMin: -40, latMax: -12, lonMin: 112, lonMax: 155 },
      ];
      const verts = [];
      boxes.forEach(b => {
        for (let i = 0; i < 200; i++) {
          const v = latLonToVec3(rand(b.latMin, b.latMax), rand(b.lonMin, b.lonMax), GLOBE_R * 1.002);
          verts.push(v.x, v.y, v.z);
        }
      });
      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
      coastlineGroup.add(new THREE.Points(geom, new THREE.PointsMaterial({ color: 0x00ff41, size: 0.012, transparent: true, opacity: 0.6 })));
    });

  // --- Cities ---
  const cities = [
    { name: 'NYC', lat: 40.7, lon: -74, threat: false },
    { name: 'LON', lat: 51.5, lon: -0.1, threat: false },
    { name: 'TYO', lat: 35.7, lon: 139.7, threat: false },
    { name: 'MOS', lat: 55.8, lon: 37.6, threat: true },
    { name: 'BEJ', lat: 39.9, lon: 116.4, threat: true },
    { name: 'SYD', lat: -33.9, lon: 151.2, threat: false },
    { name: 'BER', lat: 52.5, lon: 13.4, threat: false },
    { name: 'SAO', lat: -23.5, lon: -46.6, threat: true },
    { name: 'SEL', lat: 37.6, lon: 127, threat: false },
    { name: 'DXB', lat: 25.2, lon: 55.3, threat: true },
    { name: 'SIN', lat: 1.3, lon: 103.8, threat: false },
    { name: 'LAX', lat: 34, lon: -118.2, threat: false },
    { name: 'PAR', lat: 48.9, lon: 2.35, threat: false },
    { name: 'MUM', lat: 19.1, lon: 72.9, threat: true },
    { name: 'JKT', lat: -6.2, lon: 106.8, threat: false },
    { name: 'LIM', lat: -12, lon: -77, threat: true },
  ];

  // City markers as small sphere meshes
  const cityMeshes = [];
  cities.forEach(c => {
    const pos = latLonToVec3(c.lat, c.lon, GLOBE_R * 1.01);
    const geom = new THREE.SphereGeometry(0.015, 8, 8);
    const mat = new THREE.MeshBasicMaterial({ color: c.threat ? 0xff0040 : 0x00ff41 });
    const mesh = new THREE.Mesh(geom, mat);
    mesh.position.copy(pos);
    mesh.userData = c;
    globeGroup.add(mesh);
    cityMeshes.push(mesh);

    // Pulsing ring
    const ringGeom = new THREE.RingGeometry(0.02, 0.03, 16);
    const ringMat = new THREE.MeshBasicMaterial({
      color: c.threat ? 0xff0040 : 0x00ff41,
      transparent: true, opacity: 0.4, side: THREE.DoubleSide
    });
    const ring = new THREE.Mesh(ringGeom, ringMat);
    ring.position.copy(pos);
    ring.lookAt(new THREE.Vector3(0, 0, 0));
    ring.userData.pulsePhase = rand(0, Math.PI * 2);
    ring.userData.baseScale = 1;
    globeGroup.add(ring);
    c._ring = ring;
    c._mesh = mesh;
    c._pos = pos;
  });

  // --- Vertical ping beams from cities ---
  cities.forEach(c => {
    const dir = c._pos.clone().normalize();
    const beamEnd = dir.clone().multiplyScalar(GLOBE_R * 1.15);
    const pts = [c._pos.clone(), beamEnd];
    const geom = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({
      color: c.threat ? 0xff0040 : 0x00ff41,
      transparent: true, opacity: 0.3
    });
    const beam = new THREE.Line(geom, mat);
    globeGroup.add(beam);
    c._beam = beam;
    c._beamMat = mat;
  });

  // --- Attack arcs ---
  const attacks = [];

  function createArcCurve(fromCity, toCity) {
    const from = latLonToVec3(fromCity.lat, fromCity.lon, GLOBE_R * 1.01);
    const to = latLonToVec3(toCity.lat, toCity.lon, GLOBE_R * 1.01);
    const mid = from.clone().add(to).multiplyScalar(0.5);
    const dist = from.distanceTo(to);
    // Lift control point above the globe surface
    mid.normalize().multiplyScalar(GLOBE_R + dist * 0.5);

    const curve = new THREE.QuadraticBezierCurve3(from, mid, to);
    const points = curve.getPoints(64);
    return { curve, points, from, to, mid };
  }

  function spawnAttack() {
    const threatCities = cities.filter(c => c.threat);
    const safeCities = cities.filter(c => !c.threat);
    const from = pick(threatCities);
    const to = pick(safeCities);
    if (!from || !to) return;

    const { curve, points } = createArcCurve(from, to);

    // Arc trail line
    const trailGeom = new THREE.BufferGeometry().setFromPoints(points);
    const trailMat = new THREE.LineBasicMaterial({
      color: 0xff0040, transparent: true, opacity: 0.6
    });
    const trail = new THREE.Line(trailGeom, trailMat);
    globeGroup.add(trail);

    // Projectile (bright dot)
    const projGeom = new THREE.SphereGeometry(0.012, 6, 6);
    const projMat = new THREE.MeshBasicMaterial({ color: 0xff4444 });
    const projectile = new THREE.Mesh(projGeom, projMat);
    globeGroup.add(projectile);

    // Glow around projectile
    const glowGeom = new THREE.SphereGeometry(0.025, 6, 6);
    const glowMat = new THREE.MeshBasicMaterial({ color: 0xff0040, transparent: true, opacity: 0.3 });
    const glow = new THREE.Mesh(glowGeom, glowMat);
    globeGroup.add(glow);

    attacks.push({
      from, to, curve, trail, trailGeom, trailMat,
      projectile, projMat, glow, glowMat,
      progress: 0,
      speed: rand(0.003, 0.012),
      alive: true
    });
  }

  // --- Impact explosions ---
  const impacts = [];
  function createImpact(position) {
    const ringGeom = new THREE.RingGeometry(0.01, 0.02, 24);
    const ringMat = new THREE.MeshBasicMaterial({
      color: 0xff0040, transparent: true, opacity: 0.9, side: THREE.DoubleSide
    });
    const ring = new THREE.Mesh(ringGeom, ringMat);
    ring.position.copy(position);
    ring.lookAt(new THREE.Vector3(0, 0, 0));
    globeGroup.add(ring);
    impacts.push({ ring, ringMat, scale: 1, life: 1.0 });
  }

  // --- Starfield background ---
  const starVerts = [];
  for (let i = 0; i < 1500; i++) {
    starVerts.push(rand(-50, 50), rand(-50, 50), rand(-50, 50));
  }
  const starGeom = new THREE.BufferGeometry();
  starGeom.setAttribute('position', new THREE.Float32BufferAttribute(starVerts, 3));
  const starMat = new THREE.PointsMaterial({ color: 0x004400, size: 0.15 });
  scene.add(new THREE.Points(starGeom, starMat));

  // --- Orbital ring (decoration) ---
  const orbitPts = [];
  for (let i = 0; i <= 128; i++) {
    const a = (i / 128) * Math.PI * 2;
    orbitPts.push(new THREE.Vector3(Math.cos(a) * 1.6, Math.sin(a) * 0.1, Math.sin(a) * 1.6));
  }
  const orbitGeom = new THREE.BufferGeometry().setFromPoints(orbitPts);
  const orbitMat = new THREE.LineBasicMaterial({ color: 0x003300, transparent: true, opacity: 0.3 });
  const orbitLine = new THREE.Line(orbitGeom, orbitMat);
  orbitLine.rotation.x = 0.3;
  scene.add(orbitLine);

  // Second orbit ring
  const orbit2 = orbitLine.clone();
  orbit2.rotation.x = -0.5;
  orbit2.rotation.z = 0.8;
  scene.add(orbit2);

  // --- Mouse interaction (drag to rotate) ---
  let isDragging = false;
  let prevMouse = { x: 0, y: 0 };
  let rotationVelocity = { x: 0, y: 0.003 }; // auto-rotate by default

  renderer.domElement.style.pointerEvents = 'auto';
  renderer.domElement.addEventListener('mousedown', e => {
    isDragging = true;
    prevMouse = { x: e.clientX, y: e.clientY };
  });
  renderer.domElement.addEventListener('mousemove', e => {
    if (!isDragging) return;
    const dx = e.clientX - prevMouse.x;
    const dy = e.clientY - prevMouse.y;
    rotationVelocity.y = dx * 0.003;
    rotationVelocity.x = dy * 0.002;
    prevMouse = { x: e.clientX, y: e.clientY };
  });
  renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });
  renderer.domElement.addEventListener('mouseleave', () => { isDragging = false; });

  // Scroll to zoom
  renderer.domElement.addEventListener('wheel', e => {
    e.preventDefault();
    camera.position.z = Math.max(1.8, Math.min(6, camera.position.z + e.deltaY * 0.002));
  }, { passive: false });

  // --- Animation loop ---
  let attackTimer = 0;
  let activeAttackCount = 0;

  function animate() {
    if (!document.body.contains(container)) return;
    requestAnimationFrame(animate);

    const w = container.clientWidth;
    const h = container.clientHeight;
    if (w === 0 || h === 0) return;

    renderer.setSize(w, h);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    hudCanvas.width = w;
    hudCanvas.height = h;

    const time = Date.now() / 1000;

    // Rotate globe
    if (!isDragging) {
      rotationVelocity.y += (0.003 - rotationVelocity.y) * 0.02; // ease back to auto-rotate
      rotationVelocity.x *= 0.95; // dampen vertical
    }
    globeGroup.rotation.y += rotationVelocity.y;
    globeGroup.rotation.x += rotationVelocity.x;
    // Clamp vertical rotation
    globeGroup.rotation.x = Math.max(-1.2, Math.min(1.2, globeGroup.rotation.x));
    if (!isDragging) rotationVelocity.y *= 0.99;

    // Pulse city rings
    cities.forEach(c => {
      if (c._ring) {
        const s = 1 + Math.sin(time * 3 + c._ring.userData.pulsePhase) * 0.5;
        c._ring.scale.set(s, s, s);
        c._ring.material.opacity = 0.2 + Math.sin(time * 3 + c._ring.userData.pulsePhase) * 0.2;
      }
      // Pulse beams
      if (c._beamMat) {
        c._beamMat.opacity = 0.15 + Math.sin(time * 4 + c.lon) * 0.15;
      }
    });

    // Spawn attacks
    attackTimer += 0.016;
    if (attackTimer > rand(0.8, 2.5) && attacks.filter(a => a.alive).length < 8) {
      spawnAttack();
      attackTimer = 0;
    }

    // Update attacks
    activeAttackCount = 0;
    for (let i = attacks.length - 1; i >= 0; i--) {
      const atk = attacks[i];
      if (!atk.alive) continue;
      activeAttackCount++;

      atk.progress += atk.speed;

      // Move projectile along curve
      const pt = atk.curve.getPoint(Math.min(atk.progress, 1));
      atk.projectile.position.copy(pt);
      atk.glow.position.copy(pt);
      atk.glow.scale.setScalar(1 + Math.sin(time * 20) * 0.3);

      // Fade trail with progress
      atk.trailMat.opacity = 0.5 * (1 - atk.progress * 0.5);

      // Partial trail drawing: show only the part behind the projectile
      const totalPts = 65;
      const visiblePts = Math.floor(atk.progress * totalPts);
      const positions = atk.trailGeom.attributes.position.array;
      // Fade will handle visual, keep full trail

      if (atk.progress >= 1) {
        atk.alive = false;
        // Impact!
        createImpact(atk.curve.getPoint(1));

        // Cleanup
        globeGroup.remove(atk.trail);
        globeGroup.remove(atk.projectile);
        globeGroup.remove(atk.glow);
        atk.trailGeom.dispose();
        atk.trailMat.dispose();
        atk.projMat.dispose();
        atk.glowMat.dispose();
        attacks.splice(i, 1);
      }
    }

    // Update impacts
    for (let i = impacts.length - 1; i >= 0; i--) {
      const imp = impacts[i];
      imp.scale += 0.08;
      imp.life -= 0.02;
      imp.ring.scale.set(imp.scale, imp.scale, imp.scale);
      imp.ringMat.opacity = Math.max(0, imp.life);
      if (imp.life <= 0) {
        globeGroup.remove(imp.ring);
        imp.ringMat.dispose();
        impacts.splice(i, 1);
      }
    }

    // Render
    renderer.render(scene, camera);

    // --- HUD overlay ---
    const hctx = hudCanvas.getContext('2d');
    hctx.clearRect(0, 0, w, h);

    // Title
    hctx.font = '10px "Share Tech Mono"';
    hctx.fillStyle = 'rgba(0,255,255,0.7)';
    hctx.fillText('◆ GLOBAL THREAT MAP // 3D SIGINT', 6, 14);

    // Stats
    hctx.font = '9px "Share Tech Mono"';
    hctx.fillStyle = 'rgba(255,0,64,0.7)';
    hctx.fillText(`● ACTIVE ATTACKS: ${activeAttackCount}`, 6, h - 26);
    hctx.fillStyle = 'rgba(0,255,65,0.5)';
    hctx.fillText(`NODES: ${cities.length} | THREATS: ${cities.filter(c=>c.threat).length} | ROT: ${(globeGroup.rotation.y % (Math.PI*2)).toFixed(2)}rad`, 6, h - 12);

    // Project city labels to 2D
    cities.forEach(c => {
      const worldPos = c._pos.clone();
      worldPos.applyMatrix4(globeGroup.matrixWorld);

      // Check if on front side of globe (facing camera)
      const camDir = new THREE.Vector3();
      camera.getWorldDirection(camDir);
      const toCity = worldPos.clone().sub(camera.position).normalize();
      const dot = worldPos.clone().normalize().dot(camera.position.clone().normalize());

      if (dot > 0.1) { // front-facing
        const projected = worldPos.clone().project(camera);
        const sx = (projected.x * 0.5 + 0.5) * w;
        const sy = (-projected.y * 0.5 + 0.5) * h;

        if (sx > 0 && sx < w && sy > 0 && sy < h) {
          hctx.font = '8px "Share Tech Mono"';
          hctx.fillStyle = c.threat ? 'rgba(255,0,64,0.8)' : 'rgba(0,255,255,0.8)';
          hctx.fillText(c.name, sx + 6, sy - 4);

          // Tiny crosshair
          hctx.strokeStyle = c.threat ? 'rgba(255,0,64,0.4)' : 'rgba(0,255,65,0.4)';
          hctx.lineWidth = 0.5;
          hctx.beginPath();
          hctx.moveTo(sx - 4, sy); hctx.lineTo(sx + 4, sy);
          hctx.moveTo(sx, sy - 4); hctx.lineTo(sx, sy + 4);
          hctx.stroke();
        }
      }
    });

    // Corner decorations
    hctx.strokeStyle = 'rgba(0,255,65,0.2)';
    hctx.lineWidth = 1;
    const cs = 15;
    // Top-left
    hctx.beginPath(); hctx.moveTo(0, cs); hctx.lineTo(0, 0); hctx.lineTo(cs, 0); hctx.stroke();
    // Top-right
    hctx.beginPath(); hctx.moveTo(w-cs, 0); hctx.lineTo(w, 0); hctx.lineTo(w, cs); hctx.stroke();
    // Bottom-left
    hctx.beginPath(); hctx.moveTo(0, h-cs); hctx.lineTo(0, h); hctx.lineTo(cs, h); hctx.stroke();
    // Bottom-right
    hctx.beginPath(); hctx.moveTo(w-cs, h); hctx.lineTo(w, h); hctx.lineTo(w, h-cs); hctx.stroke();
  }

  animate();
}

// --- PROCESS LIST ---
function createProcessList(body) {
  const container = document.createElement('div');
  container.style.cssText = 'overflow-y:auto;height:100%;font-size:9px;';
  body.appendChild(container);

  const processes = [
    'quantum_decrypt', 'neural_scan', 'tor_relay', 'mesh_network', 'exploit_fw',
    'packet_sniff', 'brute_force', 'keylog_daemon', 'proxy_chain', 'dns_spoof',
    'ssl_strip', 'arp_poison', 'port_knock', 'entropy_gen', 'hash_crack',
    'payload_gen', 'rootkit_scan', 'vuln_assess', 'traffic_anal', 'crypto_mine',
    'darkweb_crawl', 'botnet_ctrl', 'zero_day_scan', 'firmware_dump', 'mem_inject',
  ];

  function update() {
    if (!document.body.contains(container)) return;
    let html = '<div style="color:var(--cyan);margin-bottom:4px;font-size:10px;">PID    CPU%  MEM%  STAT  COMMAND</div>';
    const shuffled = [...processes].sort(() => Math.random() - 0.5).slice(0, 18);
    shuffled.forEach(p => {
      const cpu = rand(0.1, 99.9).toFixed(1).padStart(5);
      const mem = rand(0.1, 30).toFixed(1).padStart(5);
      const stat = pick(['R', 'S', 'D', 'T', 'Z']);
      const pid = randInt(1000, 65535);
      const statColor = stat === 'R' ? 'var(--green)' : stat === 'Z' ? 'var(--red)' : 'var(--amber)';
      html += `<div style="cursor:pointer;" onmouseover="this.style.background='rgba(0,255,65,0.05)'" onmouseout="this.style.background=''">
        ${String(pid).padStart(5)}  ${cpu}  ${mem}  <span style="color:${statColor}">${stat}</span>     ${p}</div>`;
    });
    container.innerHTML = html;
    setTimeout(update, 1000);
  }
  update();
}

// --- CIRCULAR GAUGE ---
function createGauge(body, label, min, max) {
  const canvas = document.createElement('canvas');
  canvas.className = 'graph-canvas';
  body.appendChild(canvas);

  let value = rand(min, max);
  let targetValue = value;

  function draw() {
    if (!document.body.contains(canvas)) return;
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    const cx = w/2, cy = h/2;
    const r = Math.min(cx, cy) - 15;

    // Update target occasionally
    if (Math.random() > 0.98) targetValue = rand(min, max);
    value += (targetValue - value) * 0.05;

    const pct = (value - min) / (max - min);
    const startAngle = Math.PI * 0.75;
    const endAngle = Math.PI * 2.25;
    const currentAngle = startAngle + pct * (endAngle - startAngle);

    // Background arc
    ctx.beginPath();
    ctx.arc(cx, cy, r, startAngle, endAngle);
    ctx.strokeStyle = 'rgba(0,68,0,0.4)';
    ctx.lineWidth = 6;
    ctx.stroke();

    // Value arc
    const color = pct < 0.5 ? '#00ff41' : pct < 0.75 ? '#ffbf00' : '#ff0040';
    ctx.beginPath();
    ctx.arc(cx, cy, r, startAngle, currentAngle);
    ctx.strokeStyle = color;
    ctx.lineWidth = 6;
    ctx.lineCap = 'round';
    ctx.stroke();

    // Ticks
    for (let i = 0; i <= 10; i++) {
      const angle = startAngle + (i/10) * (endAngle - startAngle);
      const inner = r - 10;
      const outer = r + 3;
      ctx.beginPath();
      ctx.moveTo(cx + Math.cos(angle) * inner, cy + Math.sin(angle) * inner);
      ctx.lineTo(cx + Math.cos(angle) * outer, cy + Math.sin(angle) * outer);
      ctx.strokeStyle = 'rgba(0,255,65,0.3)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    // Needle
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(currentAngle) * (r - 15), cy + Math.sin(currentAngle) * (r - 15));
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Center dot
    ctx.beginPath();
    ctx.arc(cx, cy, 4, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();

    // Value text
    ctx.font = `${Math.max(14, r * 0.4)}px "Orbitron"`;
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.fillText(value.toFixed(1), cx, cy + r * 0.3);

    ctx.font = '9px "Share Tech Mono"';
    ctx.fillStyle = 'var(--cyan)';
    ctx.fillText(label, cx, cy + r * 0.55);
    ctx.textAlign = 'left';

    requestAnimationFrame(draw);
  }
  draw();
}

// --- INITIALIZE PANELS ---
function initAll() {
  const ws = $('#workspace');
  const ww = ws.offsetWidth;
  const wh = ws.offsetHeight;

  // Layout - tiled
  const layouts = [
    { id: 'p-terminal', title: '◆ TERMINAL // root@nexus', x: 0, y: 0, w: ww*0.3, h: wh*0.4, init: createTerminal, tabs: ['BASH', 'ZSH', 'PYTHON'] },
    { id: 'p-netgraph', title: '◆ NETWORK TOPOLOGY', x: ww*0.3, y: 0, w: ww*0.35, h: wh*0.4, init: createNetworkGraph },
    { id: 'p-worldmap', title: '◆ GLOBAL THREAT MAP', x: ww*0.65, y: 0, w: ww*0.35, h: wh*0.4, init: createWorldMap },
    { id: 'p-logs', title: '◆ SYSTEM LOGS', x: 0, y: wh*0.4, w: ww*0.22, h: wh*0.3, init: createLogFeed },
    { id: 'p-eq', title: '◆ AUDIO INTERCEPT // EQ', x: ww*0.22, y: wh*0.4, w: ww*0.18, h: wh*0.15, init: createEQ },
    { id: 'p-waveform', title: '◆ SIGNAL ANALYSIS', x: ww*0.22, y: wh*0.55, w: ww*0.18, h: wh*0.15, init: createWaveform },
    { id: 'p-chart', title: '◆ TRAFFIC MONITOR', x: ww*0.4, y: wh*0.4, w: ww*0.3, h: wh*0.3, init: (b) => createLiveChart(b, {label1:'BANDWIDTH', label2:'PACKETS', label3:'DROPPED'}), tabs: ['REAL-TIME', 'HOUR', 'DAY'] },
    { id: 'p-video', title: '◆ SURVEILLANCE // CAM-7', x: ww*0.7, y: wh*0.4, w: ww*0.3, h: wh*0.3, init: (b) => createVideoFeed(b, 'SECTOR-7') },
    { id: 'p-hex', title: '◆ MEMORY DUMP // 0x7FFF0000', x: 0, y: wh*0.7, w: ww*0.22, h: wh*0.3, init: createHexDump },
    { id: 'p-datatable', title: '◆ PORT SCAN RESULTS', x: ww*0.22, y: wh*0.7, w: ww*0.25, h: wh*0.3, init: createDataTable },
    { id: 'p-radar', title: '◆ RADAR // SIGINT', x: ww*0.47, y: wh*0.7, w: ww*0.18, h: wh*0.3, init: createRadar },
    { id: 'p-donut', title: '◆ TRAFFIC CLASSIFICATION', x: ww*0.65, y: wh*0.7, w: ww*0.18, h: wh*0.15, init: createDonutChart },
    { id: 'p-spectrum', title: '◆ SPECTRUM WATERFALL', x: ww*0.65, y: wh*0.85, w: ww*0.18, h: wh*0.15, init: createSpectrum },
    { id: 'p-bars', title: '◆ PROTOCOL ANALYSIS', x: ww*0.83, y: wh*0.7, w: ww*0.17, h: wh*0.15, init: createBarChart },
    { id: 'p-procs', title: '◆ PROCESS MONITOR', x: ww*0.83, y: wh*0.85, w: ww*0.17, h: wh*0.15, init: createProcessList },
  ];

  layouts.forEach(l => {
    const p = createPanel(l);
    l.init(p.body);
  });

  initClock();
  initBottomBar();
  initContextMenu();
  initSelectionBox();
  initKeyboard();
  startAutoNotifications();
}

// --- CLOCK ---
function initClock() {
  function updateClock() {
    const now = new Date();
    const utc = now.toUTCString().split(' ')[4];
    $('#clock').textContent = `${utc} UTC`;
    requestAnimationFrame(updateClock);
  }
  updateClock();

  // Uptime
  const start = Date.now();
  function updateUptime() {
    const elapsed = Math.floor((Date.now() - start) / 1000);
    const h = Math.floor(elapsed / 3600).toString().padStart(2, '0');
    const m = Math.floor((elapsed % 3600) / 60).toString().padStart(2, '0');
    const s = (elapsed % 60).toString().padStart(2, '0');
    $('#uptime').textContent = `${h}:${m}:${s}`;
    setTimeout(updateUptime, 1000);
  }
  updateUptime();
}

// --- BOTTOM BAR ---
function initBottomBar() {
  function update() {
    const cpu = rand(20, 95);
    const mem = rand(40, 85);
    $('#cpu-bar').style.width = cpu + '%';
    $('#cpu-bar').style.background = cpu > 80 ? 'var(--red)' : cpu > 60 ? 'var(--amber)' : 'var(--green)';
    $('#cpu-val').textContent = cpu.toFixed(0) + '%';
    $('#cpu-val').style.color = cpu > 80 ? 'var(--red)' : 'var(--green)';

    $('#mem-bar').style.width = mem + '%';
    $('#mem-bar').style.background = mem > 75 ? 'var(--amber)' : 'var(--green)';
    $('#mem-val').textContent = mem.toFixed(0) + '%';

    const up = rand(0.5, 50).toFixed(1);
    const down = rand(2, 200).toFixed(1);
    $('#net-val').textContent = `↑ ${up}MB/s ↓ ${down}MB/s`;
    $('#node-count').textContent = randInt(30, 80);
    $('#thread-count').textContent = randInt(128, 512);

    setTimeout(update, rand(500, 1500));
  }
  update();
}

// --- CONTEXT MENU ---
function initContextMenu() {
  const menu = $('#context-menu');

  document.addEventListener('contextmenu', e => {
    e.preventDefault();
    menu.style.display = 'block';
    menu.style.left = e.clientX + 'px';
    menu.style.top = e.clientY + 'px';
  });

  document.addEventListener('click', () => {
    menu.style.display = 'none';
  });
}

// --- SELECTION BOX ---
function initSelectionBox() {
  const box = $('#selection-box');
  let isSelecting = false, startX, startY;

  document.addEventListener('mousedown', e => {
    if (e.button !== 0) return;
    if (e.target.closest('.panel') || e.target.closest('#top-bar') || e.target.closest('#bottom-bar') || e.target.closest('.context-menu')) return;
    isSelecting = true;
    startX = e.clientX;
    startY = e.clientY;
    box.style.left = startX + 'px';
    box.style.top = startY + 'px';
    box.style.width = '0px';
    box.style.height = '0px';
    box.style.display = 'block';
  });

  document.addEventListener('mousemove', e => {
    if (!isSelecting) return;
    const x = Math.min(e.clientX, startX);
    const y = Math.min(e.clientY, startY);
    const w = Math.abs(e.clientX - startX);
    const h = Math.abs(e.clientY - startY);
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = w + 'px';
    box.style.height = h + 'px';
  });

  document.addEventListener('mouseup', () => {
    if (isSelecting) {
      const w = parseInt(box.style.width);
      const h = parseInt(box.style.height);
      if (w > 20 && h > 20) {
        notify(`Selection area: ${w}x${h}px — ${randInt(1,12)} targets identified`);
      }
    }
    isSelecting = false;
    box.style.display = 'none';
  });
}

// --- KEYBOARD SHORTCUTS ---
function initKeyboard() {
  document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT') return;
    if (e.key === 'g') triggerGlitch();
    if (e.key === 'n') toggleNightVision();
    if (e.key === 't') spawnFloatingTerminal();
    if (e.key === 'h') hackTheGibson();
    if (e.key === 'r') runNetScan();
    if (e.key === 'Escape') {
      $$('.panel').forEach(p => p.classList.remove('focused'));
      notify('All panels defocused');
    }
  });
}

// --- NOTIFICATIONS ---
function notify(msg, type) {
  const el = document.createElement('div');
  el.className = 'notification' + (type === 'error' ? ' error' : type === 'warn' ? ' warn' : '');
  el.textContent = `[${timestamp()}] ${msg}`;

  // Stack notifications
  const existing = $$('.notification');
  el.style.top = (42 + existing.length * 36) + 'px';

  document.body.appendChild(el);
  setTimeout(() => el.remove(), 4000);
}

function startAutoNotifications() {
  const msgs = [
    () => `Encrypted tunnel ${randInt(1,99)} renegotiated`,
    () => `New node joined mesh: ${ipAddr()}`,
    () => `Blocked scan from ${ipAddr()}`,
    () => `Firewall rule updated: DROP ${ipAddr()}`,
    () => `Certificate pinning verified for *.${pick(['shadow','dark','ghost'])}.net`,
    () => `Tor circuit rebuilt: ${randInt(3,7)} hops`,
    () => `Quantum key exchange completed (${randInt(256,4096)} bits)`,
    () => `Intelligence feed updated: ${randInt(10,500)} new IOCs`,
    () => `Anomaly detected on port ${pick([22,80,443,8080])}`,
    () => `Decryption complete: ${randInt(1,50)}MB payload`,
  ];

  function autoNotify() {
    if (Math.random() > 0.6) {
      notify(pick(msgs)(), Math.random() > 0.85 ? 'warn' : undefined);
    }
    setTimeout(autoNotify, rand(5000, 15000));
  }
  setTimeout(autoNotify, 5000);
}

// --- SPECIAL ACTIONS ---
function triggerGlitch() {
  const container = $('#main-container');
  container.style.animation = 'none';
  void container.offsetHeight;
  container.style.animation = 'glitch 0.3s ease 3';
  setTimeout(() => { container.style.animation = 'flicker 4s infinite'; }, 1000);
  notify('GLITCH DETECTED — Recovering...', 'error');
}

function toggleNightVision() {
  document.body.style.filter = document.body.style.filter === 'hue-rotate(60deg) brightness(1.2)' ? '' : 'hue-rotate(60deg) brightness(1.2)';
  notify('Night vision ' + (document.body.style.filter ? 'ENABLED' : 'DISABLED'));
}

function hackTheGibson() {
  notify('HACK THE PLANET!', 'warn');
  triggerGlitch();
  setTimeout(() => notify('ACCESS GRANTED — Welcome to The Gibson', 'warn'), 1500);
  setTimeout(() => notify('Downloading garbage file...', 'error'), 3000);
  setTimeout(() => {
    // Spawn a big dramatic overlay briefly
    const overlay = document.createElement('div');
    overlay.style.cssText = `
      position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:99999;
      display:flex;align-items:center;justify-content:center;
      background:rgba(0,0,0,0.9);
      font-family:'Orbitron',sans-serif;font-size:60px;color:#00ff41;
      text-shadow:0 0 30px #00ff41, 0 0 60px #00ff41;
      letter-spacing:10px;
    `;
    overlay.textContent = 'ACCESS GRANTED';
    document.body.appendChild(overlay);
    setTimeout(() => {
      overlay.style.transition = 'opacity 1s';
      overlay.style.opacity = '0';
      setTimeout(() => overlay.remove(), 1000);
    }, 2000);
  }, 4000);
}

function runNetScan() {
  notify('Network sweep initiated...', 'warn');
  let count = 0;
  const interval = setInterval(() => {
    notify(`Found: ${ipAddr()} [${pick(['OPEN','FILTERED','CLOSED'])}]`);
    count++;
    if (count >= 5) {
      clearInterval(interval);
      notify(`Sweep complete: ${randInt(10,50)} hosts discovered`, 'warn');
    }
  }, 800);
}

function spawnFloatingTerminal() {
  const p = createPanel({
    title: `◆ TERMINAL // PID:${randInt(1000,9999)}`,
    x: randInt(50, 400),
    y: randInt(50, 300),
    w: 450,
    h: 280,
  });
  createTerminal(p.body);
  p.el.classList.add('focused');
  p.el.style.zIndex = ++panelZIndex;
  notify('New terminal spawned');
}

function resetLayout() {
  $$('.panel').forEach(p => p.remove());
  panels = [];
  initAll();
  notify('Layout reset');
}

// --- AUDIO CONTEXT (click to activate) ---
let audioCtx;
document.addEventListener('click', () => {
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    // Create subtle background hum
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    oscillator.type = 'sawtooth';
    oscillator.frequency.value = 55;
    gainNode.gain.value = 0.015;
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    oscillator.start();
  } catch(e) {}
}, { once: true });

// --- SOUND EFFECTS ---
function beep(freq = 800, duration = 50) {
  if (!audioCtx) return;
  try {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'square';
    osc.frequency.value = freq;
    gain.gain.value = 0.03;
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration/1000);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration/1000);
  } catch(e) {}
}

// Beep on notifications
const origNotify = notify;
// Override to add sound
const _notify = notify;
notify = function(msg, type) {
  _notify(msg, type);
  beep(type === 'error' ? 200 : type === 'warn' ? 400 : 800);
};

// --- START ---
initMatrix();
bootSequence();
</script>
</body>
</html>
