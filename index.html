<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>H4CK3R C0NS0L3 // 31337 OPS</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&family=Nixie+One&display=swap');

  :root {
    --green: #00ff41;
    --dark-green: #003b00;
    --cyan: #00ffff;
    --red: #ff0040;
    --amber: #ffbf00;
    --purple: #bf00ff;
    --blue: #0080ff;
    --bg: #0a0a0a;
    --panel-bg: rgba(0, 20, 0, 0.85);
    --border: #004400;
    --glow: 0 0 10px rgba(0, 255, 65, 0.5);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--green);
    font-family: 'Share Tech Mono', monospace;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    cursor: crosshair;
  }

  /* SCANLINE OVERLAY */
  body::after {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: repeating-linear-gradient(
      0deg,
      rgba(0, 0, 0, 0.15) 0px,
      rgba(0, 0, 0, 0.15) 1px,
      transparent 1px,
      transparent 2px
    );
    pointer-events: none;
    z-index: 10000;
  }

  /* GLOBAL FLICKER */
  @keyframes flicker {
    0%, 97%, 100% { opacity: 1; }
    98% { opacity: 0.85; }
    99% { opacity: 0.92; }
  }

  #main-container {
    width: 100vw;
    height: 100vh;
    animation: flicker 4s infinite;
    display: flex;
    flex-direction: column;
  }

  /* TOP BAR */
  #top-bar {
    height: 36px;
    background: linear-gradient(180deg, #001a00, #000d00);
    border-bottom: 1px solid var(--green);
    display: flex;
    align-items: center;
    padding: 0 10px;
    gap: 20px;
    flex-shrink: 0;
    box-shadow: 0 2px 10px rgba(0, 255, 65, 0.2);
    z-index: 100;
  }

  #top-bar .logo {
    font-family: 'Orbitron', sans-serif;
    font-weight: 900;
    font-size: 14px;
    color: var(--green);
    text-shadow: var(--glow);
    letter-spacing: 3px;
  }

  .top-menu {
    display: flex;
    gap: 2px;
  }

  .top-menu-item {
    padding: 4px 12px;
    font-size: 11px;
    cursor: pointer;
    color: var(--green);
    transition: all 0.1s;
    position: relative;
  }

  .top-menu-item:hover {
    background: var(--green);
    color: #000;
  }

  .dropdown-menu {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    background: #001a00;
    border: 1px solid var(--green);
    min-width: 180px;
    z-index: 9999;
  }

  .top-menu-item:hover .dropdown-menu {
    display: block;
  }

  .dropdown-item {
    padding: 6px 14px;
    font-size: 11px;
    cursor: pointer;
    white-space: nowrap;
    color: var(--green);
  }

  .dropdown-item:hover {
    background: var(--green);
    color: #000;
  }

  .top-bar-status {
    margin-left: auto;
    display: flex;
    gap: 15px;
    align-items: center;
    font-size: 10px;
  }

  .status-indicator {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .status-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    animation: pulse-dot 2s infinite;
  }

  @keyframes pulse-dot {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  .dot-green { background: var(--green); box-shadow: 0 0 6px var(--green); }
  .dot-red { background: var(--red); box-shadow: 0 0 6px var(--red); }
  .dot-amber { background: var(--amber); box-shadow: 0 0 6px var(--amber); }
  .dot-cyan { background: var(--cyan); box-shadow: 0 0 6px var(--cyan); }

  /* WORKSPACE */
  #workspace {
    flex: 1;
    position: relative;
    overflow: hidden;
  }

  /* PANELS */
  .panel {
    position: absolute;
    background: var(--panel-bg);
    border: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 0 0 15px rgba(0, 255, 65, 0.1), inset 0 0 30px rgba(0, 0, 0, 0.5);
  }

  .panel.focused {
    border-color: var(--green);
    box-shadow: 0 0 20px rgba(0, 255, 65, 0.3), inset 0 0 30px rgba(0, 0, 0, 0.5);
    z-index: 50;
  }

  .panel-header {
    height: 24px;
    background: linear-gradient(90deg, #002200, #001100);
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    padding: 0 8px;
    cursor: move;
    flex-shrink: 0;
    user-select: none;
  }

  .panel-header .title {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    flex: 1;
  }

  .panel-header .controls {
    display: flex;
    gap: 4px;
  }

  .panel-header .ctrl-btn {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    cursor: pointer;
  }

  .ctrl-close { background: var(--red); }
  .ctrl-min { background: var(--amber); }
  .ctrl-max { background: var(--green); }

  .panel-body {
    flex: 1;
    overflow: hidden;
    padding: 6px;
    position: relative;
  }

  /* RESIZE HANDLE */
  .resize-handle {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 14px;
    height: 14px;
    cursor: nwse-resize;
    z-index: 10;
  }

  .resize-handle::after {
    content: '⋱';
    position: absolute;
    right: 2px;
    bottom: -2px;
    font-size: 10px;
    color: var(--green);
    opacity: 0.5;
  }

  /* TERMINAL */
  .terminal-output {
    height: 100%;
    overflow-y: auto;
    font-size: 11px;
    line-height: 1.4;
    scrollbar-width: thin;
    scrollbar-color: var(--green) transparent;
  }

  .terminal-output::-webkit-scrollbar { width: 4px; }
  .terminal-output::-webkit-scrollbar-thumb { background: var(--dark-green); }

  .term-line { margin-bottom: 1px; white-space: pre-wrap; word-break: break-all; }
  .term-prompt { color: var(--cyan); }
  .term-error { color: var(--red); }
  .term-warn { color: var(--amber); }
  .term-info { color: var(--green); }
  .term-purple { color: var(--purple); }
  .term-blue { color: var(--blue); }

  .term-input-line {
    display: flex;
    align-items: center;
    margin-top: 4px;
  }

  .term-input-line span { color: var(--cyan); font-size: 11px; }

  .term-input {
    background: transparent;
    border: none;
    color: var(--green);
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    outline: none;
    flex: 1;
    caret-color: var(--green);
  }

  /* GRAPH CANVAS */
  .graph-canvas {
    width: 100%;
    height: 100%;
  }

  /* MATRIX RAIN BG */
  #matrix-bg {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    opacity: 0.55;
  }

  /* EQ BARS */
  /* EQ styles removed — now WebGL */

  /* WORLD MAP */
  .world-map-container {
    width: 100%;
    height: 100%;
    position: relative;
  }

  /* HEX DUMP */
  .hex-dump {
    font-size: 9px;
    line-height: 1.5;
    color: var(--green);
    opacity: 0.9;
    overflow-y: auto;
    height: 100%;
    white-space: pre;
    font-family: 'Share Tech Mono', monospace;
  }

  /* SELECTION BOX */
  .selection-box {
    position: fixed;
    border: 1px dashed var(--cyan);
    background: rgba(0, 255, 255, 0.05);
    pointer-events: none;
    z-index: 9998;
    display: none;
  }

  /* VIDEO FEED */
  .video-feed {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    background: #000;
  }

  .video-feed canvas {
    width: 100%;
    height: 100%;
  }

  .video-overlay {
    position: absolute;
    top: 4px;
    left: 4px;
    font-size: 9px;
    color: var(--red);
    text-shadow: 0 0 5px var(--red);
  }

  .video-overlay.rec::before {
    content: '● ';
    animation: pulse-dot 1s infinite;
  }

  /* BOTTOM BAR */
  #bottom-bar {
    height: 22px;
    background: linear-gradient(180deg, #000d00, #001a00);
    border-top: 1px solid var(--border);
    display: flex;
    align-items: center;
    padding: 0 10px;
    font-size: 9px;
    gap: 20px;
    flex-shrink: 0;
    z-index: 100;
  }

  #bottom-bar .section {
    display: flex;
    gap: 6px;
    align-items: center;
  }

  /* PROGRESS BARS */
  .mini-progress {
    width: 60px;
    height: 4px;
    background: #001100;
    border: 1px solid var(--border);
    overflow: hidden;
  }

  .mini-progress-fill {
    height: 100%;
    transition: width 0.3s;
  }

  /* CONTEXT MENU */
  .context-menu {
    display: none;
    position: fixed;
    background: #001a00;
    border: 1px solid var(--green);
    min-width: 160px;
    z-index: 99999;
    box-shadow: 0 0 15px rgba(0, 255, 65, 0.3);
  }

  .context-menu-item {
    padding: 6px 14px;
    font-size: 11px;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
  }

  .context-menu-item:hover {
    background: var(--green);
    color: #000;
  }

  .context-menu-sep {
    height: 1px;
    background: var(--border);
    margin: 2px 0;
  }

  .ctx-shortcut { opacity: 0.6; font-size: 9px; }

  /* TOOLTIP */
  .tooltip {
    position: fixed;
    background: #001a00;
    border: 1px solid var(--green);
    padding: 4px 8px;
    font-size: 9px;
    pointer-events: none;
    z-index: 99999;
    display: none;
    max-width: 200px;
    box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
  }

  /* NOTIFICATION */
  .notification {
    position: fixed;
    top: 42px;
    right: 10px;
    background: #001a00;
    border: 1px solid var(--green);
    padding: 10px 16px;
    font-size: 11px;
    z-index: 99999;
    animation: slideIn 0.3s ease, fadeOut 0.5s ease 3s forwards;
    box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
  }

  .notification.error { border-color: var(--red); color: var(--red); box-shadow: 0 0 20px rgba(255, 0, 64, 0.3); }
  .notification.warn { border-color: var(--amber); color: var(--amber); }

  @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
  @keyframes fadeOut { to { opacity: 0; transform: translateY(-10px); } }

  /* BOOT SCREEN */
  #boot-screen {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    background: #000;
    z-index: 100000;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-family: 'Share Tech Mono', monospace;
  }

  #boot-text {
    max-width: 700px;
    font-size: 13px;
    line-height: 1.6;
    color: var(--green);
    text-shadow: var(--glow);
  }

  #boot-text .blink-cursor::after {
    content: '█';
    animation: blink 0.5s infinite;
  }

  @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

  /* DATA TABLE */
  .data-table {
    width: 100%;
    font-size: 9px;
    border-collapse: collapse;
  }

  .data-table th {
    background: rgba(0, 255, 65, 0.1);
    padding: 3px 6px;
    text-align: left;
    border-bottom: 1px solid var(--border);
    color: var(--cyan);
  }

  .data-table td {
    padding: 2px 6px;
    border-bottom: 1px solid rgba(0, 68, 0, 0.3);
  }

  .data-table tr:hover td {
    background: rgba(0, 255, 65, 0.05);
  }

  /* RADAR */
  .radar-container {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* NODE GRAPH */
  .node-graph { width: 100%; height: 100%; }

  /* TABS */
  .panel-tabs {
    display: flex;
    background: rgba(0, 17, 0, 0.5);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }

  .panel-tab {
    padding: 3px 10px;
    font-size: 9px;
    cursor: pointer;
    border-right: 1px solid var(--border);
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .panel-tab.active {
    background: rgba(0, 255, 65, 0.1);
    color: var(--cyan);
  }

  .panel-tab:hover { background: rgba(0, 255, 65, 0.05); }

  /* GLITCH EFFECT */
  @keyframes glitch {
    0%, 90%, 100% { transform: translate(0); }
    92% { transform: translate(-2px, 1px); filter: hue-rotate(90deg); }
    94% { transform: translate(2px, -1px); }
    96% { transform: translate(-1px, -1px); filter: hue-rotate(180deg); }
    98% { transform: translate(1px, 2px); }
  }

  .glitch-text {
    animation: glitch 8s infinite;
  }

  /* TYPING CURSOR */
  @keyframes typing-cursor {
    0%, 100% { border-right-color: var(--green); }
    50% { border-right-color: transparent; }
  }

  /* AUDIO WAVE */
  .audio-wave {
    width: 100%;
    height: 100%;
  }

  /* SPECTRUM */
  .spectrum-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    gap: 2px;
    padding: 4px;
  }

  .spectrum-row {
    display: flex;
    gap: 1px;
    flex: 1;
  }

  .spectrum-cell {
    flex: 1;
    transition: background 0.15s;
    border-radius: 1px;
  }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson-client@3.1.0/dist/topojson-client.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
</head>
<body>
<canvas id="matrix-bg"></canvas>
<canvas id="intro-canvas" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:200000;"></canvas>

<div id="boot-screen">
  <div id="boot-text"></div>
</div>

<div id="main-container" style="display:none;">
  <!-- TOP BAR -->
  <div id="top-bar">
    <div class="logo glitch-text">◆ N3XUS-C0R3 v6.66</div>
    <div class="top-menu">
      <div class="top-menu-item">FILE
        <div class="dropdown-menu">
          <div class="dropdown-item" onclick="openImportDataset()">Import Dataset</div>
          <div class="dropdown-item" onclick="openExportPayload()">Export Payload</div>
          <div class="dropdown-item" onclick="openNewTunnel()">New Tunnel</div>
          <div class="dropdown-item" onclick="openArchiveSession()">Archive Session</div>
        </div>
      </div>
      <div class="top-menu-item">SCAN
        <div class="dropdown-menu">
          <div class="dropdown-item" onclick="runNetScan()">Network Sweep</div>
          <div class="dropdown-item" onclick="openVulnScanner()">Vuln Scanner</div>
          <div class="dropdown-item" onclick="openPortEnum()">Port Enum</div>
          <div class="dropdown-item" onclick="openDNSRecon()">DNS Recon</div>
        </div>
      </div>
      <div class="top-menu-item">TOOLS
        <div class="dropdown-menu">
          <div class="dropdown-item" onclick="openPacketSniffer()">Packet Sniffer</div>
          <div class="dropdown-item" onclick="openHashCracker()">Hash Cracker</div>
          <div class="dropdown-item" onclick="openDecompiler()">Decompiler</div>
          <div class="dropdown-item" onclick="openSignalTuner()">Signal Tuner</div>
          <div class="dropdown-item" onclick="spawnFloatingTerminal()">New Terminal</div>
        </div>
      </div>
      <div class="top-menu-item">VIEW
        <div class="dropdown-menu">
          <div class="dropdown-item" onclick="toggleNightVision()">Night Vision</div>
          <div class="dropdown-item" onclick="triggerGlitch()">Glitch Mode</div>
          <div class="dropdown-item" onclick="openWireframe()">Wireframe</div>
          <div class="dropdown-item" onclick="resetLayout()">Reset Layout</div>
        </div>
      </div>
      <div class="top-menu-item">HACK
        <div class="dropdown-menu">
          <div class="dropdown-item" onclick="openBypassAuth()">Bypass Auth</div>
          <div class="dropdown-item" onclick="openInjectPayload()">Inject Payload</div>
          <div class="dropdown-item" onclick="openDropFirewall()">Drop Firewall</div>
          <div class="dropdown-item" onclick="hackTheGibson()">Hack The Gibson</div>
        </div>
      </div>
    </div>
    <div style="display:flex;align-items:center;gap:4px;font-size:9px;color:#00ff41;border-left:1px solid #003300;padding-left:10px;margin-left:2px;">
      <span style="color:#00ffff;letter-spacing:1px;font-size:8px;">RAIN</span>
      <input type="range" id="matrix-density" min="5" max="100" value="55" title="Column density / frequency"
        style="width:52px;accent-color:#00ff41;height:2px;cursor:pointer;-webkit-appearance:none;
        background:linear-gradient(90deg,#002200,#00ff41);border-radius:2px;outline:none;">
      <span id="matrix-density-val" style="min-width:20px;color:#00ffff;font-size:8px;">55%</span>
    </div>
    <div style="display:flex;align-items:center;gap:4px;font-size:9px;color:#00ff41;border-left:1px solid #001a00;padding-left:6px;">
      <span style="color:#00ffff;letter-spacing:1px;font-size:8px;">SIZE</span>
      <input type="range" id="matrix-fontscale" min="5" max="100" value="45" title="Glyph size"
        style="width:52px;accent-color:#00ff41;height:2px;cursor:pointer;-webkit-appearance:none;
        background:linear-gradient(90deg,#002200,#00ff41);border-radius:2px;outline:none;">
      <span id="matrix-fontscale-val" style="min-width:20px;color:#00ffff;font-size:8px;">45%</span>
    </div>
    <div class="top-bar-status">
      <div class="status-indicator"><div class="status-dot dot-green"></div>UPLINK</div>
      <div class="status-indicator"><div class="status-dot dot-cyan"></div>TOR x3</div>
      <div class="status-indicator"><div class="status-dot dot-amber"></div>PROXY</div>
      <div class="status-indicator"><div class="status-dot dot-red" style="animation-delay:0.5s"></div>ENCRYPT</div>
      <div id="clock" style="font-family:'Orbitron',sans-serif;font-size:11px;color:var(--cyan);"></div>
    </div>
  </div>

  <!-- WORKSPACE -->
  <div id="workspace">
    <!-- All panels injected by JS -->
  </div>

  <!-- BOTTOM BAR -->
  <div id="bottom-bar">
    <div class="section">
      <span style="color:var(--cyan)">CPU:</span>
      <div class="mini-progress"><div class="mini-progress-fill" id="cpu-bar" style="width:45%;background:var(--green);"></div></div>
      <span id="cpu-val">45%</span>
    </div>
    <div class="section">
      <span style="color:var(--cyan)">MEM:</span>
      <div class="mini-progress"><div class="mini-progress-fill" id="mem-bar" style="width:62%;background:var(--amber);"></div></div>
      <span id="mem-val">62%</span>
    </div>
    <div class="section">
      <span style="color:var(--cyan)">NET:</span>
      <span id="net-val" style="color:var(--green);">↑ 2.4MB/s ↓ 14.7MB/s</span>
    </div>
    <div class="section">
      <span style="color:var(--cyan)">NODES:</span>
      <span id="node-count">47</span>
    </div>
    <div class="section">
      <span style="color:var(--cyan)">THREADS:</span>
      <span id="thread-count">256</span>
    </div>
    <div class="section" style="margin-left:auto;">
      <span style="color:var(--purple)">▶ OPERATION BLACKOUT</span>
    </div>
    <div class="section">
      <span style="color:#004400;cursor:pointer;" onclick="toggleHelpOverlay()" title="Keyboard shortcuts">[?] KEYS</span>
    </div>
    <div class="section">
      <span id="uptime" style="color:var(--green);">00:00:00</span>
    </div>
  </div>
</div>

<!-- CONTEXT MENU -->
<div class="context-menu" id="context-menu">
  <div class="context-menu-item" onclick="notify('Trace route initiated')">Trace Route <span class="ctx-shortcut">Ctrl+T</span></div>
  <div class="context-menu-item" onclick="notify('Packet captured')">Capture Packet <span class="ctx-shortcut">Ctrl+P</span></div>
  <div class="context-menu-sep"></div>
  <div class="context-menu-item" onclick="notify('Encrypting selection...')">Encrypt Selection <span class="ctx-shortcut">Ctrl+E</span></div>
  <div class="context-menu-item" onclick="notify('Decrypting...')">Decrypt <span class="ctx-shortcut">Ctrl+D</span></div>
  <div class="context-menu-sep"></div>
  <div class="context-menu-item" onclick="notify('Memory dump saved')">Dump Memory <span class="ctx-shortcut">Ctrl+M</span></div>
  <div class="context-menu-item" onclick="notify('Injecting...')">Inject Code <span class="ctx-shortcut">Ctrl+I</span></div>
  <div class="context-menu-sep"></div>
  <div class="context-menu-item" onclick="spawnFloatingTerminal()">New Terminal <span class="ctx-shortcut">Ctrl+N</span></div>
  <div class="context-menu-item" onclick="triggerGlitch()">Glitch <span class="ctx-shortcut">Ctrl+G</span></div>
</div>

<!-- SELECTION BOX -->
<div class="selection-box" id="selection-box"></div>

<!-- TOOLTIP -->
<div class="tooltip" id="tooltip"></div>

<script>
// ============================================================
// H4CK3R C0NS0L3 - THE MOST RIDICULOUS HOLLYWOOD THING EVER
// ============================================================

// --- UTILITY ---
const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);
const rand = (a, b) => Math.random() * (b - a) + a;
const randInt = (a, b) => Math.floor(rand(a, b));
const pick = arr => arr[randInt(0, arr.length)];
const hex = () => randInt(0, 256).toString(16).padStart(2, '0');
const hexWord = () => randInt(0, 65536).toString(16).padStart(4, '0');
const ipAddr = () => `${randInt(1,255)}.${randInt(0,255)}.${randInt(0,255)}.${randInt(1,255)}`;
const macAddr = () => Array.from({length:6}, () => hex()).join(':');
const uuid = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
  const r = Math.random() * 16 | 0; return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
});

// --- MATRIX ZOOM INTRO (The Matrix camera-into-zero scene) ---
async function matrixIntro() {
  const canvas = document.getElementById('intro-canvas');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;

  const W = () => window.innerWidth;
  const H = () => window.innerHeight;

  function resizeCanvas() {
    canvas.width = W() * dpr;
    canvas.height = H() * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  resizeCanvas();

  // Katakana + digits (no slashed zero — we use 'O')
  const glyphs = 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン123456789ABCDEF';
  const glyphArr = [...glyphs];
  const pick = () => glyphArr[Math.floor(Math.random() * glyphArr.length)];

  const cellW = 16, cellH = 20;
  const baseFontSize = cellH - 4;
  const cols = Math.ceil(W() / cellW) + 4;
  const rows = Math.ceil(H() / cellH) + 4;
  const trailLen = 30;

  // Build columns
  const streams = [];
  for (let c = 0; c < cols; c++) {
    streams.push({
      chars: Array.from({ length: rows }, () => pick()),
      head: Math.floor(Math.random() * -rows),
      baseSpeed: 0.15 + Math.random() * 0.55,
      brightness: 0.5 + Math.random() * 0.5,
    });
  }

  // Target zero — placed at the exact cell whose center is closest to screen center.
  // This means tX ≈ w/2 and tY ≈ h/2, so NO panning is needed during zoom.
  const tCol = Math.round((W() / 2 - cellW / 2) / cellW);
  const tRow = Math.round((H() / 2 - cellH / 2) / cellH);
  streams[tCol].chars[tRow] = 'O';
  // Position head so it arrives at tRow after ~2s of animation
  streams[tCol].head = tRow - 48;
  streams[tCol].baseSpeed = 0.4;

  // Zoom target: exact center of the cell where the O is drawn
  const tX = tCol * cellW + cellW / 2;
  const tY = tRow * cellH + cellH / 2;

  // Timeline — zoom starts early, rain keeps going, hold on the O, then cut
  const PHASE_RAIN_FULL = 2.0;  // full-speed rain before anything else
  const PHASE_ZOOM_START = 2.0; // zoom begins (overlaps with rain)
  const PHASE_RAIN_END = 10.0;  // non-target columns keep animating until here
  const PHASE_ZOOM_END = 20.0;  // zoom stops — O fills most of the screen
  const PHASE_HOLD_END = 22.0;  // hold on the glowing O with CRT scanlines
  const PHASE_FADE_END = 22.5;  // quick cut to black → boot

  const t0 = performance.now();

  // ---- Helper: render the full rain scene at a given scale/offset ----
  // Re-renders every frame so the O stays crisp at any zoom level.
  // glowAmount: 0-1 controls how much the target O glows
  function renderRain(w, h, scale, cx, cy, glowAmount) {
    if (glowAmount === undefined) glowAmount = 0;
    ctx.save();
    ctx.translate(w / 2, h / 2);
    ctx.scale(scale, scale);
    ctx.translate(-cx, -cy);

    // Background: solid black (no trails needed when re-rendering)
    const visW = w / scale, visH = h / scale;
    const left = cx - visW / 2, top = cy - visH / 2;
    ctx.fillStyle = '#000';
    ctx.fillRect(left - cellW, top - cellH, visW + cellW * 2, visH + cellH * 2);

    // Only draw columns/rows that are visible in the current viewport
    const cMin = Math.max(0, Math.floor(left / cellW) - 1);
    const cMax = Math.min(cols - 1, Math.ceil((left + visW) / cellW) + 1);
    const rMin = Math.max(0, Math.floor(top / cellH) - 1);
    const rMax = Math.min(rows - 1, Math.ceil((top + visH) / cellH) + 1);

    // Font size — always baseFontSize in world-space (canvas scales it up)
    ctx.font = `${baseFontSize}px 'Share Tech Mono', monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Always ensure the target O cell is within the draw range
    const drawCMin = Math.min(cMin, tCol);
    const drawCMax = Math.max(cMax, tCol);
    const drawRMin = Math.min(rMin, tRow);
    const drawRMax = Math.max(rMax, tRow);

    for (let c = drawCMin; c <= drawCMax; c++) {
      const s = streams[c];
      for (let r = drawRMin; r <= drawRMax; r++) {
        const isTarget = (c === tCol && r === tRow);
        // Skip non-target chars outside the visible viewport
        if (!isTarget && (c < cMin || c > cMax || r < rMin || r > rMax)) continue;
        const dist = s.head - r;

        // Target O: always drawn once the head has reached it (dist >= -0.5)
        // Other chars: only drawn within the trail window
        if (!isTarget && (dist < -0.5 || dist > trailLen)) continue;
        if (isTarget && dist < -0.5) continue; // not yet reached

        const px = c * cellW + cellW / 2;
        const py = r * cellH + cellH / 2;

        if (isTarget) {
          // Nixie One font for a round, warm, retro-tube zero
          if (glowAmount > 0) {
            ctx.shadowColor = '#00ff41';
            ctx.shadowBlur = 8 + glowAmount * 50;
          }
          const gb = Math.floor(200 + 55 * glowAmount);
          const rr = Math.floor(80 + 175 * glowAmount);
          ctx.fillStyle = glowAmount > 0
            ? `rgb(${rr},${gb},${Math.floor(100 + 155 * glowAmount)})`
            : 'rgba(190,255,190,1)';

          // Use Nixie One for the target zero — rounder, more expressive
          ctx.font = `${baseFontSize * 0.85}px 'Nixie One', serif`;

          // Multi-pass bloom for glow
          const passes = glowAmount > 0.3 ? 3 : glowAmount > 0.1 ? 2 : 1;
          for (let p = 0; p < passes; p++) {
            ctx.fillText('0', px, py);
          }

          // Reset shadow & font
          if (glowAmount > 0) {
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
          }
          ctx.font = `${baseFontSize}px 'Share Tech Mono', monospace`;
          continue;
        } else if (dist < 0.5 && dist >= -0.5) {
          ctx.fillStyle = 'rgba(190,255,190,1)';
        } else {
          const fade = Math.max(0, 1 - dist / trailLen);
          const g = Math.floor(130 + 125 * fade);
          const a = fade * s.brightness;
          ctx.fillStyle = `rgba(5,${g},15,${a})`;
        }
        ctx.fillText(s.chars[r], px, py);
      }
    }

    ctx.restore();
  }

  // ---- Main draw function ----
  function drawFrame(now) {
    const sec = (now - t0) / 1000;
    if (sec >= PHASE_FADE_END) return;

    const w = W(), h = H();
    resizeCanvas();

    // ---- Advance rain simulation ----
    // Non-target columns keep animating throughout the zoom until PHASE_RAIN_END
    // Target column freezes once zoom starts
    if (sec < PHASE_RAIN_END) {
      // Gradually decelerate rain as zoom progresses
      let speedMul = 1.0;
      if (sec > PHASE_ZOOM_START) {
        const dt = (sec - PHASE_ZOOM_START) / (PHASE_RAIN_END - PHASE_ZOOM_START);
        speedMul = Math.max(0, 1.0 - dt * dt);
      }

      for (let c = 0; c < cols; c++) {
        // Target column freezes once zoom begins
        if (c === tCol && sec >= PHASE_ZOOM_START) continue;

        const s = streams[c];
        s.head += s.baseSpeed * speedMul;

        if (s.head > rows + trailLen) {
          s.head = -trailLen - Math.random() * rows * 0.5;
          for (let r = 0; r < rows; r++) {
            if (c === tCol && r === tRow) continue;
            s.chars[r] = pick();
          }
        }

        // Char cycling while still moving
        if (speedMul > 0.05 && Math.random() > 0.9) {
          const ri = Math.floor(Math.random() * rows);
          if (!(c === tCol && ri === tRow)) s.chars[ri] = pick();
        }
      }
    }

    // ---- Compute zoom level & render ----
    let scale = 1.0;

    if (sec < PHASE_ZOOM_END) {
      const fadeIn = Math.min(1, sec / 0.8);

      // Zoom ramps up from PHASE_ZOOM_START
      let zt = 0, ease = 0;
      if (sec >= PHASE_ZOOM_START) {
        zt = (sec - PHASE_ZOOM_START) / (PHASE_ZOOM_END - PHASE_ZOOM_START);
        // Quadratic ease-in: starts slow, accelerates to constant speed
        // Integral of a linear speed ramp: ease = zt² for zt<0.5, then linear for the rest
        // This keeps mid and end at the same perceived speed
        if (zt < 0.3) {
          // Quadratic ramp: speed goes from 0 → full over first 30%
          ease = (zt * zt) / (2 * 0.3);
        } else {
          // Linear from here — matched so it's continuous
          ease = (0.3 / 2) + (zt - 0.3);
        }
      }

      // Cap zoom so the O fills ~70% of screen height (stays visible)
      const maxScale = (h * 12) / cellH;
      scale = ease > 0 ? Math.pow(maxScale, ease) : 1;

      // Glow ramps up with zoom
      const glowAmount = ease > 0 ? Math.min(1, ease * 1.5) : 0;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, w, h);

      renderRain(w, h, scale, tX, tY, glowAmount);

      // Fade in overlay
      if (fadeIn < 1) {
        ctx.fillStyle = `rgba(0,0,0,${1 - fadeIn})`;
        ctx.fillRect(0, 0, w, h);
      }

      // Radial glow highlight around the O (early zoom)
      if (ease > 0 && ease < 0.3) {
        const gr = ctx.createRadialGradient(w / 2, h / 2, 0, w / 2, h / 2, 40 / scale);
        gr.addColorStop(0, `rgba(0,255,65,${0.2 * (ease / 0.3)})`);
        gr.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gr;
        ctx.fillRect(0, 0, w, h);
      }

      // Vignette (intensifies with zoom)
      if (ease > 0.05) {
        const vg = ctx.createRadialGradient(w / 2, h / 2, w * 0.15, w / 2, h / 2, w * 0.6);
        vg.addColorStop(0, 'rgba(0,0,0,0)');
        vg.addColorStop(1, `rgba(0,0,0,${0.15 + ease * 0.55})`);
        ctx.fillStyle = vg;
        ctx.fillRect(0, 0, w, h);
      }

      // CRT scanlines — thick dark bands with phosphor-green gaps
      if (zt > 0.1) {
        const scanT = Math.min(1, (zt - 0.1) / 0.7);
        const scanSpacing = Math.max(3, Math.floor(3 + scanT * 5));
        const scanThick = Math.max(1, Math.floor(1 + scanT * 2.5));
        const scanAlpha = 0.15 + scanT * 0.55;

        // Dark scan bands
        ctx.fillStyle = `rgba(0,0,0,${scanAlpha})`;
        for (let sy = 0; sy < h; sy += scanSpacing) {
          ctx.fillRect(0, sy, w, scanThick);
        }

        // Subtle green phosphor glow between scanlines
        if (scanT > 0.3) {
          const phosphorAlpha = (scanT - 0.3) * 0.08;
          ctx.fillStyle = `rgba(0,255,65,${phosphorAlpha})`;
          for (let sy = scanThick; sy < h; sy += scanSpacing) {
            ctx.fillRect(0, sy, w, Math.max(1, scanSpacing - scanThick));
          }
        }

        // Horizontal beam flicker
        if (scanT > 0.4) {
          const beamY = (sec * 60) % h;
          const beamAlpha = (scanT - 0.4) * 0.12;
          const beamH = 30 + scanT * 50;
          const beamGrad = ctx.createLinearGradient(0, beamY - beamH / 2, 0, beamY + beamH / 2);
          beamGrad.addColorStop(0, 'rgba(0,255,65,0)');
          beamGrad.addColorStop(0.5, `rgba(0,255,65,${beamAlpha})`);
          beamGrad.addColorStop(1, 'rgba(0,255,65,0)');
          ctx.fillStyle = beamGrad;
          ctx.fillRect(0, beamY - beamH / 2, w, beamH);
        }
      }
    }

    // ---- HOLD PHASE: sit on the glowing O with CRT scanlines ----
    else if (sec < PHASE_HOLD_END) {
      // Render at final zoom scale with full glow
      const maxScale = (h * 12) / cellH;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, w, h);

      renderRain(w, h, maxScale, tX, tY, 1.0);

      // Vignette
      const vg = ctx.createRadialGradient(w / 2, h / 2, w * 0.15, w / 2, h / 2, w * 0.6);
      vg.addColorStop(0, 'rgba(0,0,0,0)');
      vg.addColorStop(1, 'rgba(0,0,0,0.7)');
      ctx.fillStyle = vg;
      ctx.fillRect(0, 0, w, h);

      // Heavy CRT scanlines
      const scanSpacing = 8;
      const scanThick = 3;
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      for (let sy = 0; sy < h; sy += scanSpacing) {
        ctx.fillRect(0, sy, w, scanThick);
      }

      // Green phosphor between scanlines
      ctx.fillStyle = 'rgba(0,255,65,0.03)';
      for (let sy = scanThick; sy < h; sy += scanSpacing) {
        ctx.fillRect(0, sy, w, scanSpacing - scanThick);
      }

      // Drifting beam
      const beamY = (sec * 60) % h;
      const beamGrad = ctx.createLinearGradient(0, beamY - 40, 0, beamY + 40);
      beamGrad.addColorStop(0, 'rgba(0,255,65,0)');
      beamGrad.addColorStop(0.5, 'rgba(0,255,65,0.07)');
      beamGrad.addColorStop(1, 'rgba(0,255,65,0)');
      ctx.fillStyle = beamGrad;
      ctx.fillRect(0, beamY - 40, w, 80);
    }

    // ---- CUT TO BLACK → BOOT ----
    else {
      const ft = (sec - PHASE_HOLD_END) / (PHASE_FADE_END - PHASE_HOLD_END);
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, w, h);
      canvas.style.opacity = 1 - ft;
    }
  }

  return new Promise(resolve => {
    function tick(now) {
      const sec = (now - t0) / 1000;
      if (sec >= PHASE_FADE_END) {
        canvas.style.display = 'none';
        resolve();
        return;
      }
      drawFrame(now);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  });
}

// --- BOOT SEQUENCE ---
const bootLines = [
  'BIOS v3.31337 (C) N3XUS CORP 2025',
  'Checking quantum entanglement pairs... OK',
  'Neural coprocessor: ONLINE [8 cores @ 4.7THz]',
  'Initializing holographic RAM... 128PB detected',
  'Loading kernel: nexus-core-6.66.0-quantum-amd64',
  '  [  OK  ] Started Quantum Entropy Daemon',
  '  [  OK  ] Started Neural Network Inference Engine',
  '  [  OK  ] Started Dark Web Relay Service',
  '  [  OK  ] Started Encrypted Mesh Network',
  '  [  OK  ] Started AI Threat Detection Module',
  '  [ WARN ] Intrusion Detection: 47 probes blocked',
  '  [  OK  ] Started Zero-Day Exploit Scanner',
  'Establishing TOR circuit... 3 relays connected',
  'Proxy chain: SOCKS5 → VPN → TOR → SATELLITE',
  'Encryption: AES-4096-GCM + Quantum Key Exchange',
  '///////////////////////////////////////////\\\\',
  '  N 3 X U S - C 0 R 3    v 6 . 6 6',
  '  "There is no spoon."',
  '///////////////////////////////////////////\\\\',
  '',
  'SYSTEM READY. ACCESS LEVEL: ROOT [31337]',
  'Type "help" for command list.',
  ''
];

async function bootSequence() {
  const bootText = $('#boot-text');
  const bootScreen = $('#boot-screen');

  for (let i = 0; i < bootLines.length; i++) {
    const line = bootLines[i];
    const div = document.createElement('div');
    div.style.color = line.includes('WARN') ? 'var(--amber)' : line.includes('///') ? 'var(--cyan)' : 'var(--green)';
    div.style.textShadow = 'var(--glow)';
    bootText.appendChild(div);

    for (let j = 0; j < line.length; j++) {
      div.textContent += line[j];
      if (Math.random() > 0.85) await sleep(10);
    }
    div.textContent = line;

    if (i === bootLines.length - 1) {
      const cursor = document.createElement('span');
      cursor.className = 'blink-cursor';
      div.appendChild(cursor);
    }

    bootText.scrollTop = bootText.scrollHeight;
    await sleep(rand(20, 80));
  }

  await sleep(800);
  bootScreen.style.transition = 'opacity 0.8s';
  bootScreen.style.opacity = '0';
  await sleep(800);
  bootScreen.style.display = 'none';
  $('#main-container').style.display = 'flex';
  initAll();
  // Audio starts now — we're in the console
  initAudio();
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// --- MATRIX RAIN BACKGROUND ---
function initMatrix() {
  const canvas = $('#matrix-bg');

  // --- WebGL setup ---
  const gl = canvas.getContext('webgl', { alpha: true, premultipliedAlpha: false }) ||
             canvas.getContext('experimental-webgl', { alpha: true, premultipliedAlpha: false });
  if (!gl) { console.warn('WebGL not available for matrix rain'); return; }

  // --- Build glyph atlas texture from canvas ---
  // Render katakana + half-width kana + digits into a sprite sheet
  const GLYPH_CHARS = 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲンABCDEF0123456789ﾊﾐﾋｰｳｼﾅﾓﾆｻﾜﾂｵﾘｱﾎﾃﾏｹﾒｴｶｷﾑﾕﾗｾﾈｽ';
  const GLYPH_SIZE = 32;
  const ATLAS_COLS = 16;
  const ATLAS_ROWS = Math.ceil(GLYPH_CHARS.length / ATLAS_COLS);
  const atlasCanvas = document.createElement('canvas');
  atlasCanvas.width = ATLAS_COLS * GLYPH_SIZE;
  atlasCanvas.height = ATLAS_ROWS * GLYPH_SIZE;
  const actx = atlasCanvas.getContext('2d');
  actx.fillStyle = '#000';
  actx.fillRect(0, 0, atlasCanvas.width, atlasCanvas.height);
  actx.fillStyle = '#fff';
  actx.font = `${GLYPH_SIZE * 0.75}px monospace`;
  actx.textAlign = 'center';
  actx.textBaseline = 'middle';
  for (let i = 0; i < GLYPH_CHARS.length; i++) {
    const col = i % ATLAS_COLS;
    const row = Math.floor(i / ATLAS_COLS);
    actx.fillText(GLYPH_CHARS[i], col * GLYPH_SIZE + GLYPH_SIZE / 2, row * GLYPH_SIZE + GLYPH_SIZE / 2);
  }

  // Upload atlas as WebGL texture
  const atlasTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, atlasTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, atlasCanvas);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  // --- Create column data texture ---
  // Each column gets: speed, offset, brightness variation, character cycling speed
  const NUM_COLS = 128;
  const colData = new Float32Array(NUM_COLS * 4);
  for (let i = 0; i < NUM_COLS; i++) {
    colData[i * 4 + 0] = 0.3 + Math.random() * 1.2;   // speed
    colData[i * 4 + 1] = Math.random() * 100.0;        // time offset (randomizes start)
    colData[i * 4 + 2] = 0.4 + Math.random() * 0.6;   // brightness multiplier
    colData[i * 4 + 3] = 0.5 + Math.random() * 2.0;   // char cycle speed
  }

  // Pack into a texture (NUM_COLS x 1, RGBA float via UNSIGNED_BYTE encoding)
  // We'll pass as a uniform array instead for simplicity
  // Actually, let's use the shader's built-in hash for per-column randomness - more elegant

  // --- Shaders ---
  const vertSrc = `
    attribute vec2 aPosition;
    varying vec2 vUv;
    void main() {
      vUv = aPosition * 0.5 + 0.5;
      gl_Position = vec4(aPosition, 0.0, 1.0);
    }
  `;

  const fragSrc = `
    precision highp float;
    varying vec2 vUv;
    uniform float uTime;
    uniform vec2 uResolution;
    uniform sampler2D uAtlas;
    uniform float uAtlasCols;
    uniform float uAtlasRows;
    uniform float uNumGlyphs;
    uniform float uDensity;
    uniform float uFontScale;

    // Hash functions for pseudo-random per-column values
    float hash(float n) { return fract(sin(n) * 43758.5453123); }
    float hash2(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }

    void main() {
      // --- Font size: independent control ---
      // uFontScale 0.0..1.0 → cellSize 6..24 pixels
      float cellSize = mix(6.0, 24.0, uFontScale);
      vec2 pixelPos = vUv * uResolution;

      float col = floor(pixelPos.x / cellSize);
      float totalCols = floor(uResolution.x / cellSize);
      float totalRows = floor(uResolution.y / cellSize);
      // Flip row so row 0 is at the TOP (WebGL UV y=0 is bottom)
      float row = totalRows - floor(pixelPos.y / cellSize);

      // --- Column frequency: layered streams ---
      // More layers = more overlapping streams at each column.
      // Layer count: 1 at low density, up to 4 at max density.
      int numLayers = 1;
      if (uDensity > 0.35) numLayers = 2;
      if (uDensity > 0.60) numLayers = 3;
      if (uDensity > 0.80) numLayers = 4;

      // Also skip columns at low densities for sparseness
      float skipThreshold = smoothstep(0.0, 0.4, uDensity);

      float finalAlpha = 0.0;
      vec3 finalColor = vec3(0.0);

      for (int layer = 0; layer < 4; layer++) {
        if (layer >= numLayers) break;

        float layerF = float(layer);

        // Each layer offsets the column seed so streams are independent
        float colSeed = col + 0.5 + layerF * 137.0;

        // Column skip check (different per layer so layers don't all share gaps)
        float colActive = hash(colSeed * 7.77 + layerF * 3.33);
        if (colActive > skipThreshold) continue;

        float speed      = 0.3 + hash(colSeed * 1.17) * 1.4;
        float offset     = hash(colSeed * 2.31) * 80.0;
        float brightness = 0.7 + hash(colSeed * 3.47) * 0.3;
        float cycleSpeed = 1.0 + hash(colSeed * 4.59) * 3.0;
        float trailLen   = 15.0 + hash(colSeed * 5.73) * 25.0;
        float depth      = 0.5 + hash(colSeed * 6.11) * 0.5;

        // Deeper layers are slightly dimmer
        float layerDim = 1.0 - layerF * 0.15;

        float headPos = mod(uTime * speed + offset, totalRows + trailLen + 8.0);
        float distFromHead = headPos - row;

        // Trail fade
        float trail = 0.0;
        if (distFromHead >= 0.0 && distFromHead < trailLen) {
          trail = 1.0 - (distFromHead / trailLen);
          trail = pow(trail, 1.5);
        }

        // Head glow
        float headGlow = 0.0;
        if (distFromHead >= 0.0 && distFromHead < 2.5) {
          headGlow = 1.0 - distFromHead / 2.5;
          headGlow = headGlow * headGlow;
        }

        if (trail <= 0.0 && headGlow <= 0.0) continue;

        // Character selection: unique per layer
        float charIndex = mod(
          floor(hash2(vec2(colSeed, row)) * uNumGlyphs + uTime * cycleSpeed),
          uNumGlyphs
        );
        // Head chars change faster for that "decoding" effect
        if (distFromHead >= 0.0 && distFromHead < 3.0) {
          charIndex = mod(floor(hash(colSeed * 17.0 + row * 31.0 + uTime * 12.0) * uNumGlyphs), uNumGlyphs);
        }

        // UV into the glyph atlas
        float glyphCol = mod(charIndex, uAtlasCols);
        float glyphRow = floor(charIndex / uAtlasCols);

        vec2 cellUv = fract(pixelPos / cellSize);
        cellUv.y = 1.0 - cellUv.y;
        cellUv = cellUv * 0.85 + 0.075;

        vec2 atlasUv = vec2(
          (glyphCol + cellUv.x) / uAtlasCols,
          (glyphRow + cellUv.y) / uAtlasRows
        );

        float glyphAlpha = texture2D(uAtlas, atlasUv).r;

        // Combine: trail × glyph × brightness × depth × layer dimming
        float alpha = trail * glyphAlpha * brightness * depth * layerDim;

        // Color: rich deep green base, whiter/brighter at the head
        vec3 green = vec3(0.05, 0.85, 0.15);
        vec3 brightGreen = vec3(0.2, 1.0, 0.3);
        vec3 white = vec3(0.75, 1.0, 0.85);
        vec3 color = mix(green, brightGreen, trail * 0.5);
        color = mix(color, white, headGlow * 0.9);

        alpha += headGlow * glyphAlpha * 1.0 * layerDim;

        // Flash
        float flashPhase = sin(uTime * 0.3 + colSeed * 0.7);
        if (flashPhase > 0.95) {
          alpha *= 1.8;
          color = mix(color, white, 0.4);
        }

        // Composite layer using additive-ish blend (screen-like)
        finalColor = finalColor + color * alpha * (1.0 - finalAlpha);
        finalAlpha = finalAlpha + alpha * (1.0 - finalAlpha);

      } // end layer loop

      // Subtle scanline darkening on even rows
      float scanline = 0.92 + 0.08 * mod(row, 2.0);
      finalAlpha *= scanline;
      finalColor *= scanline;

      // Final boost
      finalAlpha *= 1.4;
      finalColor *= 1.4;

      gl_FragColor = vec4(finalColor, finalAlpha);
    }
  `;

  // --- Compile shaders ---
  function compileShader(src, type) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      console.error('Shader compile error:', gl.getShaderInfoLog(s));
      return null;
    }
    return s;
  }

  const vertShader = compileShader(vertSrc, gl.VERTEX_SHADER);
  const fragShader = compileShader(fragSrc, gl.FRAGMENT_SHADER);
  const program = gl.createProgram();
  gl.attachShader(program, vertShader);
  gl.attachShader(program, fragShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
    return;
  }
  gl.useProgram(program);

  // --- Full-screen quad ---
  const quad = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
  const aPos = gl.getAttribLocation(program, 'aPosition');
  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

  // --- Uniforms ---
  const uTime = gl.getUniformLocation(program, 'uTime');
  const uRes = gl.getUniformLocation(program, 'uResolution');
  const uAtlas = gl.getUniformLocation(program, 'uAtlas');
  const uAtlasCols = gl.getUniformLocation(program, 'uAtlasCols');
  const uAtlasRows = gl.getUniformLocation(program, 'uAtlasRows');
  const uNumGlyphs = gl.getUniformLocation(program, 'uNumGlyphs');
  const uDensityLoc = gl.getUniformLocation(program, 'uDensity');
  const uFontScaleLoc = gl.getUniformLocation(program, 'uFontScale');

  gl.uniform1i(uAtlas, 0);
  gl.uniform1f(uAtlasCols, ATLAS_COLS);
  gl.uniform1f(uAtlasRows, ATLAS_ROWS);
  gl.uniform1f(uNumGlyphs, GLYPH_CHARS.length);

  // Density: 0.0 = sparse, 1.0 = max streams (4 layers, all columns)
  let matrixDensity = 0.55;
  // Font scale: 0.0 = tiny (6px), 1.0 = large (24px)
  let matrixFontScale = 0.45;
  gl.uniform1f(uDensityLoc, matrixDensity);
  gl.uniform1f(uFontScaleLoc, matrixFontScale);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, atlasTexture);

  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

  // --- Resize handling ---
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
  }
  resize();
  window.addEventListener('resize', resize);

  // Expose setters for the UI sliders
  window.setMatrixDensity = function(v) { matrixDensity = v; };
  window.setMatrixFontScale = function(v) { matrixFontScale = v; };

  // --- Render loop ---
  const startTime = Date.now();
  function draw() {
    const t = (Date.now() - startTime) / 1000.0;
    gl.uniform1f(uTime, t);
    gl.uniform1f(uDensityLoc, matrixDensity);
    gl.uniform1f(uFontScaleLoc, matrixFontScale);
    gl.uniform2f(uRes, canvas.width, canvas.height);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(draw);
  }
  draw();
}

// --- PANEL MANAGEMENT ---
let panelZIndex = 10;
let panels = [];

function createPanel(config) {
  const panel = document.createElement('div');
  panel.className = 'panel';
  panel.id = config.id || 'panel-' + Date.now();
  panel.style.left = config.x + 'px';
  panel.style.top = config.y + 'px';
  panel.style.width = config.w + 'px';
  panel.style.height = config.h + 'px';

  const header = document.createElement('div');
  header.className = 'panel-header';
  header.innerHTML = `
    <span class="title">${config.title}</span>
    <div class="controls">
      <div class="ctrl-btn ctrl-min"></div>
      <div class="ctrl-btn ctrl-max"></div>
      <div class="ctrl-btn ctrl-close"></div>
    </div>
  `;

  let tabs = '';
  if (config.tabs) {
    const tabsDiv = document.createElement('div');
    tabsDiv.className = 'panel-tabs';
    config.tabs.forEach((t, i) => {
      const tab = document.createElement('div');
      tab.className = 'panel-tab' + (i === 0 ? ' active' : '');
      tab.textContent = t;
      tab.onclick = (e) => {
        tabsDiv.querySelectorAll('.panel-tab').forEach(x => x.classList.remove('active'));
        tab.classList.add('active');
        notify(`Switched to ${t}`);
      };
      tabsDiv.appendChild(tab);
    });
    tabs = tabsDiv;
  }

  const body = document.createElement('div');
  body.className = 'panel-body';

  const resize = document.createElement('div');
  resize.className = 'resize-handle';

  panel.appendChild(header);
  if (tabs) panel.appendChild(tabs);
  panel.appendChild(body);
  panel.appendChild(resize);

  // Drag
  let isDragging = false, dragX, dragY;
  header.addEventListener('mousedown', e => {
    if (e.target.classList.contains('ctrl-btn')) return;
    isDragging = true;
    dragX = e.clientX - panel.offsetLeft;
    dragY = e.clientY - panel.offsetTop;
    panel.style.zIndex = ++panelZIndex;
    panels.forEach(p => p.el.classList.remove('focused'));
    panel.classList.add('focused');
  });

  document.addEventListener('mousemove', e => {
    if (!isDragging) return;
    panel.style.left = (e.clientX - dragX) + 'px';
    panel.style.top = (e.clientY - dragY) + 'px';
  });

  document.addEventListener('mouseup', () => { isDragging = false; });

  // Resize
  let isResizing = false, rStartX, rStartY, rStartW, rStartH;
  resize.addEventListener('mousedown', e => {
    isResizing = true;
    rStartX = e.clientX;
    rStartY = e.clientY;
    rStartW = panel.offsetWidth;
    rStartH = panel.offsetHeight;
    e.stopPropagation();
  });

  document.addEventListener('mousemove', e => {
    if (!isResizing) return;
    panel.style.width = Math.max(150, rStartW + e.clientX - rStartX) + 'px';
    panel.style.height = Math.max(100, rStartH + e.clientY - rStartY) + 'px';
  });

  document.addEventListener('mouseup', () => { isResizing = false; });

  // Focus on click
  panel.addEventListener('mousedown', () => {
    panel.style.zIndex = ++panelZIndex;
    panels.forEach(p => p.el.classList.remove('focused'));
    panel.classList.add('focused');
  });

  // Close
  header.querySelector('.ctrl-close').addEventListener('click', () => {
    panel.style.transition = 'opacity 0.3s, transform 0.3s';
    panel.style.opacity = '0';
    panel.style.transform = 'scale(0.9)';
    setTimeout(() => panel.remove(), 300);
  });

  // Maximize
  let isMaximized = false, prevBounds;
  header.querySelector('.ctrl-max').addEventListener('click', () => {
    if (!isMaximized) {
      prevBounds = { left: panel.style.left, top: panel.style.top, width: panel.style.width, height: panel.style.height };
      const ws = $('#workspace');
      panel.style.left = '0px'; panel.style.top = '0px';
      panel.style.width = ws.offsetWidth + 'px';
      panel.style.height = ws.offsetHeight + 'px';
    } else {
      Object.assign(panel.style, prevBounds);
    }
    isMaximized = !isMaximized;
  });

  // Minimize
  header.querySelector('.ctrl-min').addEventListener('click', () => {
    body.style.display = body.style.display === 'none' ? '' : 'none';
    if (tabs) tabs.style.display = tabs.style.display === 'none' ? '' : 'none';
    resize.style.display = resize.style.display === 'none' ? '' : 'none';
    if (body.style.display === 'none') {
      panel.style.height = '24px';
    } else {
      panel.style.height = config.h + 'px';
    }
  });

  $('#workspace').appendChild(panel);
  const pObj = { el: panel, body, config, id: panel.id };
  panels.push(pObj);
  return pObj;
}

// --- TERMINAL ---
const terminalCommands = {
  help: () => [
    { text: 'Available commands:', cls: 'term-cyan' },
    { text: '  help          - Show this message', cls: 'term-info' },
    { text: '  scan <target> - Scan target system', cls: 'term-info' },
    { text: '  exploit       - Run exploit framework', cls: 'term-info' },
    { text: '  decrypt       - Decrypt intercepted data', cls: 'term-info' },
    { text: '  trace         - Trace network route', cls: 'term-info' },
    { text: '  dump          - Dump memory contents', cls: 'term-info' },
    { text: '  connect       - Connect to remote node', cls: 'term-info' },
    { text: '  status        - System status', cls: 'term-info' },
    { text: '  hack          - You know what this does', cls: 'term-purple' },
    { text: '  clear         - Clear terminal', cls: 'term-info' },
  ],
  scan: () => {
    const results = [];
    results.push({ text: `Scanning subnet ${randInt(10,192)}.${randInt(0,255)}.${randInt(0,255)}.0/24...`, cls: 'term-info' });
    const count = randInt(5, 15);
    for (let i = 0; i < count; i++) {
      const ports = Array.from({length: randInt(1,5)}, () => pick([22,80,443,3306,5432,8080,8443,27017,6379,9200]));
      results.push({ text: `  [+] ${ipAddr()} - Ports: ${ports.join(', ')} - ${pick(['Linux','Windows','FreeBSD','RouterOS'])}`, cls: Math.random()>0.7 ? 'term-warn' : 'term-info' });
    }
    results.push({ text: `Scan complete. ${count} hosts found.`, cls: 'term-blue' });
    return results;
  },
  exploit: () => [
    { text: 'Loading exploit framework v4.2.0...', cls: 'term-info' },
    { text: `[*] Target: ${ipAddr()}`, cls: 'term-info' },
    { text: '[*] Payload: reverse_tcp_quantum_shell', cls: 'term-info' },
    { text: '[*] Encoder: polymorphic/shikata_ga_nai', cls: 'term-warn' },
    { text: `[+] Exploit sent (${randInt(200,2000)} bytes)`, cls: 'term-info' },
    { text: `[+] ${Math.random()>0.3 ? 'Session opened!' : 'Exploit failed - target patched'}`, cls: Math.random()>0.3 ? 'term-info' : 'term-error' },
  ],
  decrypt: () => {
    const lines = [{ text: 'Decrypting intercepted transmission...', cls: 'term-info' }];
    for (let i = 0; i < 3; i++) {
      lines.push({ text: `  Block ${i}: ${Array.from({length:8}, hexWord).join(' ')}`, cls: 'term-warn' });
    }
    lines.push({ text: pick([
      'Decrypted: "The eagle has left the building"',
      'Decrypted: "Rendezvous at coordinates 41.40338, 2.17403"',
      'Decrypted: "Operation BLACKOUT is a go"',
      'Decrypted: "All your base are belong to us"',
      'Decrypted: "The cake is a lie"',
      'Decrypted: "HACK THE PLANET"',
    ]), cls: 'term-purple' });
    return lines;
  },
  trace: () => {
    const lines = [{ text: `Tracing route to ${ipAddr()}...`, cls: 'term-info' }];
    const hops = randInt(8, 16);
    for (let i = 1; i <= hops; i++) {
      lines.push({ text: `  ${i.toString().padStart(2)}  ${ipAddr()}  ${randInt(1,200)}ms ${i===hops ? '*** TARGET REACHED ***' : ''}`, cls: i===hops ? 'term-purple' : 'term-info' });
    }
    return lines;
  },
  dump: () => {
    const lines = [{ text: 'Memory dump @ 0x' + Array.from({length:4}, hex).join(''), cls: 'term-info' }];
    for (let i = 0; i < 8; i++) {
      const addr = (0x7fff0000 + i * 16).toString(16);
      const bytes = Array.from({length:16}, () => hex()).join(' ');
      const ascii = Array.from({length:16}, () => String.fromCharCode(randInt(33, 126))).join('');
      lines.push({ text: `  ${addr}: ${bytes}  |${ascii}|`, cls: 'term-info' });
    }
    return lines;
  },
  connect: () => {
    const ip = ipAddr();
    return [
      { text: `Connecting to ${ip}:${pick([22,443,8080])}...`, cls: 'term-info' },
      { text: 'SSH-2.0-OpenSSH_8.9 Quantum Edition', cls: 'term-info' },
      { text: `Authenticating with RSA-4096 key...`, cls: 'term-warn' },
      { text: `Welcome to ${pick(['darknode','shadowbox','ghostserver','blacksite'])}-${randInt(1,99)}`, cls: 'term-purple' },
      { text: `root@${ip}:~# `, cls: 'term-info' },
    ];
  },
  status: () => [
    { text: '=== SYSTEM STATUS ===', cls: 'term-cyan' },
    { text: `  CPU: ${randInt(30,95)}% | Cores: 8 | Freq: ${(rand(3.5,5.2)).toFixed(1)} THz`, cls: 'term-info' },
    { text: `  RAM: ${randInt(40,90)}% | ${randInt(50,100)}PB / 128PB`, cls: 'term-info' },
    { text: `  NET: ↑${(rand(1,50)).toFixed(1)}MB/s ↓${(rand(5,200)).toFixed(1)}MB/s`, cls: 'term-info' },
    { text: `  TOR: ${randInt(3,7)} relays | Latency: ${randInt(50,300)}ms`, cls: 'term-info' },
    { text: `  Active sessions: ${randInt(5,30)}`, cls: 'term-info' },
    { text: `  Threats blocked: ${randInt(100,9999)}`, cls: 'term-warn' },
  ],
  hack: () => [
    { text: '> INITIATING HACK SEQUENCE', cls: 'term-error' },
    { text: '> ...', cls: 'term-info' },
    { text: `> ACCESS GRANTED. Welcome, ${pick(['Neo','Trinity','Morpheus','Zero Cool','Crash Override','Acid Burn','The Plague','L0rd N1k0n','Zer0 C00l','c3r34lk1ll3r'])}`, cls: 'term-purple' },
  ],
  clear: () => 'CLEAR',
};

function createTerminal(body) {
  const output = document.createElement('div');
  output.className = 'terminal-output';
  output.innerHTML = `<div class="term-line term-cyan">root@nexus-core:~# Welcome to N3XUS Terminal</div>`;

  const inputLine = document.createElement('div');
  inputLine.className = 'term-input-line';
  inputLine.innerHTML = `<span>root@nexus:~# </span>`;
  const input = document.createElement('input');
  input.className = 'term-input';
  input.spellcheck = false;
  inputLine.appendChild(input);

  body.style.display = 'flex';
  body.style.flexDirection = 'column';
  body.appendChild(output);
  body.appendChild(inputLine);

  input.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      const cmd = input.value.trim().toLowerCase();
      addTermLine(output, `root@nexus:~# ${input.value}`, 'term-prompt');
      input.value = '';

      if (cmd === '') return;

      const basecmd = cmd.split(' ')[0];
      if (terminalCommands[basecmd]) {
        const result = terminalCommands[basecmd]();
        if (result === 'CLEAR') {
          output.innerHTML = '';
          return;
        }
        result.forEach(l => addTermLine(output, l.text, l.cls));
      } else {
        addTermLine(output, `bash: ${basecmd}: command not found. Try 'help'`, 'term-error');
      }
    }
  });

  input.focus();
  body.addEventListener('click', () => input.focus());
  return { output, input };
}

function addTermLine(container, text, cls) {
  const line = document.createElement('div');
  line.className = `term-line ${cls || ''}`;
  line.textContent = text;
  container.appendChild(line);
  container.scrollTop = container.scrollHeight;
}

// --- LIVE LOG FEED ---
function createLogFeed(body) {
  const output = document.createElement('div');
  output.className = 'terminal-output';
  body.appendChild(output);

  const logTypes = [
    () => ({ text: `[${timestamp()}] INFO  Connection from ${ipAddr()}:${randInt(1024,65535)}`, cls: 'term-info' }),
    () => ({ text: `[${timestamp()}] WARN  Brute force detected: ${ipAddr()} (attempt ${randInt(1,999)})`, cls: 'term-warn' }),
    () => ({ text: `[${timestamp()}] ERROR Segfault at 0x${Array.from({length:4},hex).join('')}`, cls: 'term-error' }),
    () => ({ text: `[${timestamp()}] INFO  Packet intercepted: ${randInt(64,1500)} bytes from ${ipAddr()}`, cls: 'term-info' }),
    () => ({ text: `[${timestamp()}] DEBUG Auth token: ${uuid().substring(0,8)}...`, cls: 'term-blue' }),
    () => ({ text: `[${timestamp()}] WARN  SSL cert mismatch on ${pick(['api','cdn','auth','db'])}.${pick(['shadow','dark','black','ghost'])}.net`, cls: 'term-warn' }),
    () => ({ text: `[${timestamp()}] INFO  Encrypted tunnel ${randInt(1,99)} active: ${randInt(100,9999)} packets`, cls: 'term-info' }),
    () => ({ text: `[${timestamp()}] CRIT  Intrusion attempt from ${ipAddr()} - BLOCKED`, cls: 'term-error' }),
    () => ({ text: `[${timestamp()}] INFO  DNS query: ${pick(['mx','ns','a','aaaa','cname'])}.${pick(['target','evil','shadow'])}.${pick(['com','net','onion'])}`, cls: 'term-info' }),
    () => ({ text: `[${timestamp()}] DEBUG Decrypted payload: ${randInt(1,500)}KB [${pick(['AES-256','ChaCha20','Quantum'])}]`, cls: 'term-purple' }),
  ];

  function addLog() {
    if (!document.body.contains(output)) return;
    const log = pick(logTypes)();
    addTermLine(output, log.text, log.cls);
    if (output.children.length > 200) output.removeChild(output.firstChild);
    setTimeout(addLog, rand(100, 800));
  }
  addLog();
}

function timestamp() {
  const d = new Date();
  return d.toTimeString().split(' ')[0] + '.' + d.getMilliseconds().toString().padStart(3, '0');
}

// ============================================================
// WEBGL PANEL HELPER — reusable full-screen-quad shader runner
// ============================================================
function createGLPanel(body, fragSrc, opts = {}) {
  const canvas = document.createElement('canvas');
  canvas.className = 'graph-canvas';
  body.appendChild(canvas);

  const gl = canvas.getContext('webgl', { alpha: true, premultipliedAlpha: false, antialias: false }) ||
             canvas.getContext('experimental-webgl', { alpha: true, premultipliedAlpha: false });
  if (!gl) { console.warn('WebGL unavailable for panel'); return null; }

  const vertSrc = `attribute vec2 a;varying vec2 v;void main(){v=a*.5+.5;gl_Position=vec4(a,0,1);}`;

  function compile(src, type) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      console.error('Shader error:', gl.getShaderInfoLog(s), src.split('\\n').slice(0,5));
      return null;
    }
    return s;
  }
  const vs = compile(vertSrc, gl.VERTEX_SHADER);
  const fs = compile(fragSrc, gl.FRAGMENT_SHADER);
  if (!vs || !fs) return null;
  const prog = gl.createProgram();
  gl.attachShader(prog, vs); gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
    console.error('Link error:', gl.getProgramInfoLog(prog)); return null;
  }
  gl.useProgram(prog);

  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
  const a = gl.getAttribLocation(prog, 'a');
  gl.enableVertexAttribArray(a);
  gl.vertexAttribPointer(a, 2, gl.FLOAT, false, 0, 0);

  const uTime = gl.getUniformLocation(prog, 'T');
  const uRes = gl.getUniformLocation(prog, 'R');

  // Extra uniforms
  const extraLocs = {};
  if (opts.uniforms) {
    for (const name of opts.uniforms) {
      extraLocs[name] = gl.getUniformLocation(prog, name);
    }
  }

  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

  const t0 = Date.now();
  function frame() {
    if (!document.body.contains(canvas)) return;
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    if (w === 0 || h === 0) { requestAnimationFrame(frame); return; }
    canvas.width = w; canvas.height = h;
    gl.viewport(0, 0, w, h);
    gl.useProgram(prog);
    gl.uniform1f(uTime, (Date.now() - t0) / 1000.0);
    gl.uniform2f(uRes, w, h);
    if (opts.onFrame) opts.onFrame(gl, extraLocs);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(frame);
  }
  frame();
  return { canvas, gl, prog, extraLocs };
}

// --- NETWORK TRAFFIC MONITOR (Three.js 3D Layered Cube) ---
function createNetworkGraph(body) {
  const container = document.createElement('div');
  container.style.cssText = 'width:100%;height:100%;position:relative;overflow:hidden;';
  body.appendChild(container);

  // HUD overlay canvas
  const hudCanvas = document.createElement('canvas');
  hudCanvas.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:2;';
  container.appendChild(hudCanvas);

  // Three.js setup
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
  camera.position.z = 6;

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setClearColor(0x000000, 0);
  container.insertBefore(renderer.domElement, hudCanvas);
  renderer.domElement.style.cssText = 'width:100%;height:100%;position:absolute;top:0;left:0;';

  const cubeGroup = new THREE.Group();
  scene.add(cubeGroup);

  let sampleRate = 0.5;

  // --- Constants ---
  const LAYERS = 4, GRID = 4;
  const SPACING = 0.7, LAYER_GAP = 1.0;
  const NODE_COUNT = LAYERS * GRID * GRID;
  const nColors = [0x00ff41, 0x00ffff, 0xffbf00, 0xff0040, 0xbf00ff];

  // --- Nodes ---
  const nodes = [];
  for (let layer = 0; layer < LAYERS; layer++) {
    for (let row = 0; row < GRID; row++) {
      for (let col = 0; col < GRID; col++) {
        const id = layer * GRID * GRID + row * GRID + col;
        const x = (col - (GRID - 1) / 2) * SPACING;
        const y = (layer - (LAYERS - 1) / 2) * LAYER_GAP;
        const z = (row - (GRID - 1) / 2) * SPACING;

        const geom = (id % 3 === 0)
          ? new THREE.OctahedronGeometry(0.06, 0)
          : (id % 3 === 1)
            ? new THREE.IcosahedronGeometry(0.06, 0)
            : new THREE.TetrahedronGeometry(0.07, 0);

        const color = nColors[id % nColors.length];
        const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.9 });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.set(x, y, z);
        cubeGroup.add(mesh);

        nodes.push({ id, layer, row, col, position: new THREE.Vector3(x, y, z), mesh, color, pulsePhase: Math.random() * Math.PI * 2 });
      }
    }
  }

  // --- Edges / Rods ---
  const edges = [];

  function getNode(l, r, c) {
    if (l < 0 || l >= LAYERS || r < 0 || r >= GRID || c < 0 || c >= GRID) return null;
    return nodes[l * GRID * GRID + r * GRID + c];
  }

  function createRod(a, b, color, opacity) {
    const dir = new THREE.Vector3().subVectors(b, a);
    const len = dir.length();
    if (len < 0.001) return null;
    const mid = new THREE.Vector3().addVectors(a, b).multiplyScalar(0.5);
    const geom = new THREE.CylinderGeometry(0.012, 0.012, len, 4, 1);
    const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity, depthWrite: false });
    const mesh = new THREE.Mesh(geom, mat);
    mesh.position.copy(mid);
    mesh.lookAt(b);
    mesh.rotateX(Math.PI / 2);
    cubeGroup.add(mesh);
    return mesh;
  }

  function addEdge(nA, nB, color, opacity) {
    if (!nA || !nB) return;
    const rod = createRod(nA.position, nB.position, color, opacity);
    if (rod) edges.push({ from: nA, to: nB, rod, length: nA.position.distanceTo(nB.position) });
  }

  // Intra-layer: right + down neighbors
  for (let l = 0; l < LAYERS; l++) {
    for (let r = 0; r < GRID; r++) {
      for (let c = 0; c < GRID; c++) {
        addEdge(getNode(l, r, c), getNode(l, r, c + 1), 0x00ff41, 0.15);
        addEdge(getNode(l, r, c), getNode(l, r + 1, c), 0x00ff41, 0.15);
      }
    }
  }

  // Inter-layer: vertical connections
  for (let l = 0; l < LAYERS - 1; l++) {
    for (let r = 0; r < GRID; r++) {
      for (let c = 0; c < GRID; c++) {
        addEdge(getNode(l, r, c), getNode(l + 1, r, c), 0x004400, 0.12);
      }
    }
  }

  // Random diagonal cross-connections
  for (let i = 0; i < 12; i++) {
    const l = Math.floor(Math.random() * (LAYERS - 1));
    const fromN = getNode(l, Math.floor(Math.random() * GRID), Math.floor(Math.random() * GRID));
    const toN = getNode(l + 1, Math.floor(Math.random() * GRID), Math.floor(Math.random() * GRID));
    addEdge(fromN, toN, 0x00ffff, 0.08);
  }

  // --- Decorative: wireframe bounding box ---
  const bw = (GRID - 1) * SPACING + 0.4;
  const bh = (LAYERS - 1) * LAYER_GAP + 0.4;
  const boxEdgesGeom = new THREE.EdgesGeometry(new THREE.BoxGeometry(bw, bh, bw));
  cubeGroup.add(new THREE.LineSegments(boxEdgesGeom, new THREE.LineBasicMaterial({ color: 0x003300, transparent: true, opacity: 0.3 })));

  // Layer grid planes
  for (let l = 0; l < LAYERS; l++) {
    const yy = (l - (LAYERS - 1) / 2) * LAYER_GAP;
    const gh = new THREE.GridHelper((GRID - 1) * SPACING + 0.2, GRID, 0x003300, 0x001a00);
    gh.position.y = yy;
    const mats = Array.isArray(gh.material) ? gh.material : [gh.material];
    mats.forEach(m => { m.transparent = true; m.opacity = 0.15; });
    cubeGroup.add(gh);
  }

  // --- Data Packets (object pool) ---
  const MAX_PACKETS = 80;
  const packetPool = [];
  const activePackets = [];

  for (let i = 0; i < MAX_PACKETS; i++) {
    const geom = new THREE.SphereGeometry(0.025, 6, 6);
    const mat = new THREE.MeshBasicMaterial({ color: (i % 2 === 0) ? 0x00ffff : 0x00ff41, transparent: true, opacity: 0.9 });
    const mesh = new THREE.Mesh(geom, mat);
    mesh.visible = false;
    cubeGroup.add(mesh);
    packetPool.push({ mesh, mat, active: false, edge: null, progress: 0, reverse: false, speed: 0 });
  }

  function spawnPacket() {
    const pkt = packetPool.find(p => !p.active);
    if (!pkt || edges.length === 0) return;
    const edge = edges[Math.floor(Math.random() * edges.length)];
    pkt.active = true;
    pkt.edge = edge;
    pkt.progress = 0;
    pkt.reverse = Math.random() > 0.5;
    pkt.speed = 0.005 + Math.random() * 0.015;
    pkt.mesh.visible = true;
    pkt.mesh.material.color.setHex(Math.random() > 0.5 ? 0x00ffff : 0x00ff41);
    activePackets.push(pkt);
  }

  function updatePackets(time) {
    const speedMult = 0.3 + sampleRate * 2.0;
    for (let i = activePackets.length - 1; i >= 0; i--) {
      const pkt = activePackets[i];
      pkt.progress += pkt.speed * speedMult;
      if (pkt.progress >= 1) {
        pkt.active = false;
        pkt.mesh.visible = false;
        activePackets.splice(i, 1);
        continue;
      }
      const t = pkt.reverse ? (1 - pkt.progress) : pkt.progress;
      pkt.mesh.position.lerpVectors(pkt.edge.from.position, pkt.edge.to.position, t);
      const pulse = 1 + Math.sin(time * 10 + pkt.progress * 20) * 0.3;
      pkt.mesh.scale.setScalar(pulse);
    }
    const target = Math.floor(20 + sampleRate * 40);
    while (activePackets.length < target && Math.random() > 0.3) {
      spawnPacket();
    }
  }

  // --- Mouse interaction (same as globe) ---
  let isDragging = false;
  let prevMouse = { x: 0, y: 0 };
  let rotVel = { x: 0, y: 0.003 };

  renderer.domElement.style.pointerEvents = 'auto';
  renderer.domElement.addEventListener('mousedown', e => {
    isDragging = true;
    prevMouse = { x: e.clientX, y: e.clientY };
  });
  renderer.domElement.addEventListener('mousemove', e => {
    if (!isDragging) return;
    rotVel.y = (e.clientX - prevMouse.x) * 0.003;
    rotVel.x = (e.clientY - prevMouse.y) * 0.002;
    prevMouse = { x: e.clientX, y: e.clientY };
  });
  renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });
  renderer.domElement.addEventListener('mouseleave', () => { isDragging = false; });
  renderer.domElement.addEventListener('wheel', e => {
    e.preventDefault();
    camera.position.z = Math.max(3, Math.min(10, camera.position.z + e.deltaY * 0.003));
  }, { passive: false });

  // --- HUD ---
  function drawHUD(w, h, time) {
    const hctx = hudCanvas.getContext('2d');
    hctx.clearRect(0, 0, w, h);

    hctx.font = '9px "Share Tech Mono", monospace';
    hctx.fillStyle = 'rgba(0,255,65,0.5)';
    hctx.fillText('NODES: ' + NODE_COUNT + '  EDGES: ' + edges.length + '  PKTS: ' + activePackets.length, 6, h - 12);

    // Throughput bar
    const barH = 4;
    const fill = Math.max(0.05, Math.min(0.95, 0.3 + 0.3 * Math.sin(time * (0.3 + sampleRate * 2) * 2) + 0.2 * Math.sin(time * (0.3 + sampleRate * 2) * 5.7)));
    const grad = hctx.createLinearGradient(0, 0, w * fill, 0);
    grad.addColorStop(0, 'rgba(0,255,65,0.3)');
    grad.addColorStop(1, 'rgba(255,0,64,0.3)');
    hctx.fillStyle = grad;
    hctx.fillRect(0, h - barH, w * fill, barH);

    // Corner brackets
    hctx.strokeStyle = 'rgba(0,255,65,0.2)';
    hctx.lineWidth = 1;
    const cs = 12;
    hctx.beginPath(); hctx.moveTo(0, cs); hctx.lineTo(0, 0); hctx.lineTo(cs, 0); hctx.stroke();
    hctx.beginPath(); hctx.moveTo(w - cs, 0); hctx.lineTo(w, 0); hctx.lineTo(w, cs); hctx.stroke();
    hctx.beginPath(); hctx.moveTo(0, h - cs); hctx.lineTo(0, h); hctx.lineTo(cs, h); hctx.stroke();
    hctx.beginPath(); hctx.moveTo(w - cs, h); hctx.lineTo(w, h); hctx.lineTo(w, h - cs); hctx.stroke();

    // Layer labels
    hctx.font = '8px "Share Tech Mono", monospace';
    hctx.fillStyle = 'rgba(0,255,255,0.5)';
    for (let ll = 0; ll < LAYERS; ll++) {
      const yy = (ll - (LAYERS - 1) / 2) * LAYER_GAP;
      const lp = new THREE.Vector3(-(GRID - 1) * SPACING / 2 - 0.5, yy, 0);
      lp.applyMatrix4(cubeGroup.matrixWorld);
      const proj = lp.clone().project(camera);
      const sx = (proj.x * 0.5 + 0.5) * w;
      const sy = (-proj.y * 0.5 + 0.5) * h;
      if (sx > -20 && sx < w + 20 && sy > 0 && sy < h) {
        hctx.fillText('L' + ll, sx, sy);
      }
    }
  }

  // --- Animation loop ---
  function animate() {
    if (!document.body.contains(container)) return;
    requestAnimationFrame(animate);

    const w = container.clientWidth;
    const h = container.clientHeight;
    if (w === 0 || h === 0) return;

    renderer.setSize(w, h);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    hudCanvas.width = w;
    hudCanvas.height = h;

    const time = Date.now() / 1000;

    // Rotate
    if (!isDragging) {
      rotVel.y += (0.003 - rotVel.y) * 0.02;
      rotVel.x *= 0.95;
    }
    cubeGroup.rotation.y += rotVel.y;
    cubeGroup.rotation.x += rotVel.x;
    cubeGroup.rotation.x = Math.max(-1.2, Math.min(1.2, cubeGroup.rotation.x));
    if (!isDragging) rotVel.y *= 0.99;

    // Pulse nodes
    nodes.forEach(n => {
      const pulse = 1 + Math.sin(time * 3 + n.pulsePhase) * 0.15;
      n.mesh.scale.setScalar(pulse);
      n.mesh.rotation.y = time * 0.5 + n.id;
      n.mesh.rotation.x = time * 0.3;
    });

    updatePackets(time);
    renderer.render(scene, camera);
    drawHUD(w, h, time);
  }
  animate();

  // --- SMPL RATE slider overlay ---
  const ctrl = document.createElement('div');
  ctrl.style.cssText = `
    position:absolute; top:4px; right:4px; z-index:5;
    background:rgba(0,10,0,0.88); border:1px solid rgba(0,255,65,0.3);
    padding:5px 8px; font-size:8px; color:#00ff41;
    font-family:'Share Tech Mono',monospace; pointer-events:auto;
    box-shadow:0 0 8px rgba(0,255,65,0.1); display:flex; align-items:center; gap:6px;
  `;
  ctrl.innerHTML = `
    <span style="color:#00ffff;letter-spacing:1px;font-size:7px;">SMPL RATE</span>
    <input type="range" min="0" max="100" value="50"
      style="width:60px;accent-color:#00ff41;height:2px;cursor:pointer;-webkit-appearance:none;
      background:linear-gradient(90deg,#003300,#00ff41);border-radius:1px;outline:none;">
    <span style="min-width:38px;text-align:right;color:#00ffff;font-size:8px;">1.2kHz</span>
  `;
  container.appendChild(ctrl);
  ctrl.addEventListener('mousedown', e => e.stopPropagation());

  const slider = ctrl.querySelector('input');
  const valSpan = ctrl.querySelector('span:last-child');
  const freqLabels = ['0.1kHz','0.3kHz','0.6kHz','1.2kHz','2.4kHz','4.8kHz','9.6kHz','19.2k','38.4k','48.0k','96.0k'];
  slider.addEventListener('input', () => {
    sampleRate = parseInt(slider.value) / 100;
    const idx = Math.min(Math.floor(sampleRate * 10), 10);
    valSpan.textContent = freqLabels[idx];
  });
}

// --- GRAPHIC EQ (WebGL) ---
function createEQ(body) {
  createGLPanel(body, `
    precision highp float;
    varying vec2 v;
    uniform float T;
    uniform vec2 R;
    float hash(float n){return fract(sin(n)*43758.5453);}
    void main(){
      vec2 uv=v;
      float px=1.0/R.y;
      float pxX=1.0/R.x;
      vec3 col=vec3(0.0);
      float numBars=48.0;
      float gap=2.0/R.x;
      float totalW=1.0;
      float barW=(totalW-gap*(numBars-1.0))/numBars;
      float idx=floor(uv.x/(barW+gap));
      float localX=uv.x-idx*(barW+gap);
      if(idx>=0.0 && idx<numBars && localX<barW && localX>0.0){
        float fi=idx;
        // Animated height matching original: abs(sin)*0.6+abs(sin)*0.3+random*0.1
        float h=abs(sin(T*3.0+fi*0.3))*0.6
               +abs(sin(T*7.0+fi*0.5))*0.3
               +hash(fi+floor(T*12.0))*0.1;
        h=clamp(h,0.02,0.98);
        if(uv.y<h){
          float gradT=uv.y/h;
          // Gradient: green(bottom) → cyan(mid) → red(top)
          vec3 barCol;
          if(gradT<0.5){
            barCol=mix(vec3(0.0,1.0,0.25),vec3(0.0,1.0,1.0),gradT*2.0);
          }else{
            barCol=mix(vec3(0.0,1.0,1.0),vec3(1.0,0.0,0.25),(gradT-0.5)*2.0);
          }
          col=barCol*0.85;
          // Slight glow at the top of each bar
          col+=barCol*0.3*smoothstep(4.0*px,0.0,abs(uv.y-h));
          // Rounded top cap
          col*=smoothstep(0.0,2.0*px,h-uv.y+1.5*px);
        }
        // Bright top edge glow even above bar
        float fi2=idx;
        float h2=abs(sin(T*3.0+fi2*0.3))*0.6
                +abs(sin(T*7.0+fi2*0.5))*0.3
                +hash(fi2+floor(T*12.0))*0.1;
        h2=clamp(h2,0.02,0.98);
        col+=vec3(1.0,1.0,1.0)*0.15*smoothstep(3.0*px,0.0,abs(uv.y-h2));
      }
      gl_FragColor=vec4(col,1.0);
    }
  `);
}

// --- WAVEFORM (WebGL) ---
function createWaveform(body) {
  createGLPanel(body, `
    precision highp float;
    varying vec2 v;
    uniform float T;
    uniform vec2 R;
    void main(){
      vec2 uv=v; float px=1.0/R.y;
      // Grid
      vec2 g=mod(uv*R,20.0);
      float grid=step(g.x,1.0)+step(g.y,1.0);
      vec3 col=vec3(0.0,0.27,0.0)*grid*0.3;
      // Center line
      col+=vec3(0.0,0.27,0.0)*0.6*smoothstep(1.5*px,0.0,abs(uv.y-0.5));
      // Waves
      float y=uv.y;
      // Wave 1: green
      float w1=0.5+sin(uv.x*6.28*3.0+T*3.0)*0.3+sin(uv.x*3.14*3.0+T*2.0)*0.15;
      col+=vec3(0.0,1.0,0.25)*0.8*smoothstep(2.5*px,0.0,abs(y-w1));
      // Wave 2: cyan
      float w2=0.5+sin(uv.x*6.28*5.0+T*5.0)*0.2+sin(uv.x*3.14*5.0+T*2.0)*0.1;
      col+=vec3(0.0,1.0,1.0)*0.6*smoothstep(2.0*px,0.0,abs(y-w2));
      // Wave 3: red
      float w3=0.5+sin(uv.x*6.28*8.0+T*8.0)*0.15+sin(uv.x*3.14*8.0+T*2.0)*0.075;
      col+=vec3(1.0,0.0,0.25)*0.4*smoothstep(1.5*px,0.0,abs(y-w3));
      // Wave 4: purple
      float w4=0.5+sin(uv.x*6.28*12.0+T*12.0)*0.1+sin(uv.x*3.14*12.0+T*2.0)*0.05;
      col+=vec3(0.75,0.0,1.0)*0.3*smoothstep(1.5*px,0.0,abs(y-w4));
      // Measurement crosshair
      float cx=0.5+0.3*sin(T*0.5);
      float dash=step(0.5,fract(uv.y*R.y/6.0));
      col+=vec3(1.0,0.75,0.0)*0.4*smoothstep(1.5*px,0.0,abs(uv.x-cx))*dash;
      gl_FragColor=vec4(col,1.0);
    }
  `);
}

// --- LIVE CHART (WebGL) ---
function createLiveChart(body, opts = {}) {
  const wrapper = document.createElement('div');
  wrapper.style.cssText = 'width:100%;height:100%;position:relative;overflow:hidden;';
  body.appendChild(wrapper);

  // --- D3 SVG setup ---
  const margin = { top: 6, right: 54, bottom: 18, left: 32 };
  const svg = d3.select(wrapper).append('svg')
    .attr('width', '100%').attr('height', '100%')
    .style('position', 'absolute').style('top', '0').style('left', '0');

  const defs = svg.append('defs');
  // Glow filter
  const glow = defs.append('filter').attr('id', 'chartGlow').attr('x', '-20%').attr('y', '-20%').attr('width', '140%').attr('height', '140%');
  glow.append('feGaussianBlur').attr('stdDeviation', '2').attr('result', 'blur');
  const merge = glow.append('feMerge');
  merge.append('feMergeNode').attr('in', 'blur');
  merge.append('feMergeNode').attr('in', 'SourceGraphic');

  const g = svg.append('g');

  // Data
  const maxPts = 200;
  const seriesDef = [
    { key: 'bw',   color: '#00ff41', fillColor: 'rgba(0,255,65,0.07)',  label: 'BW',   base: 0.45, amp: 0.35, spike: 0.10 },
    { key: 'pkt',  color: '#00ffff', fillColor: 'rgba(0,255,255,0.05)', label: 'PKT',  base: 0.35, amp: 0.25, spike: 0.07 },
    { key: 'drop', color: '#ff0040', fillColor: null,                    label: 'DROP', base: 0.12, amp: 0.12, spike: 0.18 },
  ];
  const data = [];
  let tick = 0;
  // Pre-fill
  for (let i = 0; i < maxPts; i++) {
    const pt = { t: i };
    for (const s of seriesDef) {
      pt[s.key] = s.base + (Math.random() - 0.3) * s.amp;
    }
    data.push(pt);
    tick = i;
  }

  // Scales
  const x = d3.scaleLinear();
  const y = d3.scaleLinear().domain([0, 1]);

  // Axes
  const xAxisG = g.append('g').attr('class', 'd3-axis');
  const yAxisG = g.append('g').attr('class', 'd3-axis');

  // Grid
  const gridG = g.append('g');

  // Area + line groups per series (draw order: drop, pkt, bw)
  const drawOrder = [2, 1, 0];
  const areas = [], lines = [], dots = [], labels = [], dashLines = [];
  for (let i = 0; i < seriesDef.length; i++) {
    const s = seriesDef[i];
    if (s.fillColor) {
      areas[i] = g.append('path').attr('fill', s.fillColor).attr('stroke', 'none');
    }
    lines[i] = g.append('path').attr('fill', 'none').attr('stroke', s.color)
      .attr('stroke-width', 1.5).attr('filter', 'url(#chartGlow)');
    dashLines[i] = g.append('line').attr('stroke', s.color).attr('stroke-width', 0.5)
      .attr('stroke-dasharray', '3,3').attr('opacity', 0.4);
    dots[i] = g.append('circle').attr('r', 3).attr('fill', s.color)
      .attr('filter', 'url(#chartGlow)');
    labels[i] = g.append('text').attr('fill', s.color)
      .attr('font-size', '9px').attr('font-family', 'Share Tech Mono, monospace');
  }

  // Speed
  let speed = 50;
  let lastPush = 0;

  function pushSample(now) {
    if (now - lastPush < speed) return;
    lastPush = now;
    tick++;
    const pt = { t: tick };
    for (const s of seriesDef) {
      const prev = data[data.length - 1][s.key];
      let next = prev + (Math.random() - 0.48) * s.amp * 0.4;
      if (Math.random() < s.spike) next += (Math.random() - 0.3) * s.amp * 1.5;
      next += (s.base - next) * 0.03;
      pt[s.key] = Math.max(0.02, Math.min(0.98, next));
    }
    data.push(pt);
    if (data.length > maxPts) data.shift();
  }

  function render(now) {
    if (!document.body.contains(wrapper)) return;
    const W = wrapper.clientWidth;
    const H = wrapper.clientHeight;
    if (W === 0 || H === 0) { requestAnimationFrame(render); return; }

    pushSample(now);

    const w = W - margin.left - margin.right;
    const h = H - margin.top - margin.bottom;
    g.attr('transform', `translate(${margin.left},${margin.top})`);

    // Update scales
    const tMin = data[0].t, tMax = data[data.length - 1].t;
    x.domain([tMin, tMax]).range([0, w]);
    y.range([h, 0]);

    // Grid lines
    const yTicks = y.ticks(5);
    const gridSel = gridG.selectAll('line.hgrid').data(yTicks);
    gridSel.enter().append('line').attr('class', 'hgrid')
      .attr('stroke', '#003b00').attr('stroke-width', 0.5)
      .merge(gridSel)
      .attr('x1', 0).attr('x2', w).attr('y1', d => y(d)).attr('y2', d => y(d));
    gridSel.exit().remove();

    // Y axis
    const yAxis = d3.axisLeft(y).ticks(5).tickFormat(d => (d * 100).toFixed(0) + '%').tickSize(0);
    yAxisG.call(yAxis);
    yAxisG.selectAll('text').attr('fill', '#005500').attr('font-size', '7px').attr('font-family', 'Share Tech Mono, monospace');
    yAxisG.selectAll('.domain').attr('stroke', '#004400');

    // X axis (time ticks)
    const xAxis = d3.axisBottom(x).ticks(6).tickFormat(d => '-' + (tMax - d).toFixed(0)).tickSize(0);
    xAxisG.attr('transform', `translate(0,${h})`).call(xAxis);
    xAxisG.selectAll('text').attr('fill', '#005500').attr('font-size', '7px').attr('font-family', 'Share Tech Mono, monospace');
    xAxisG.selectAll('.domain').attr('stroke', '#004400');

    // Line + area generators
    for (const si of drawOrder) {
      const s = seriesDef[si];
      const lineGen = d3.line().x(d => x(d.t)).y(d => y(d[s.key]));
      lines[si].attr('d', lineGen(data));

      if (areas[si]) {
        const areaGen = d3.area().x(d => x(d.t)).y0(h).y1(d => y(d[s.key]));
        areas[si].attr('d', areaGen(data));
      }

      // Current value indicators
      const last = data[data.length - 1];
      const lx = x(last.t), ly = y(last[s.key]);
      dots[si].attr('cx', lx).attr('cy', ly);
      dashLines[si].attr('x1', w * 0.6).attr('y1', ly).attr('x2', lx).attr('y2', ly);
      labels[si].attr('x', w + 4).attr('y', ly + 3).text(s.label + ' ' + (last[s.key] * 100).toFixed(0) + '%');
    }

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

  // --- SMPL RATE control ---
  const ctrl = document.createElement('div');
  ctrl.style.cssText = `
    position:absolute; top:4px; right:4px; z-index:5;
    background:rgba(0,10,0,0.88); border:1px solid rgba(0,255,65,0.3);
    padding:5px 8px; font-size:8px; color:#00ff41;
    font-family:'Share Tech Mono',monospace; pointer-events:auto;
    box-shadow:0 0 8px rgba(0,255,65,0.1); display:flex; align-items:center; gap:6px;
  `;
  ctrl.innerHTML = `
    <span style="color:#00ffff;letter-spacing:1px;font-size:7px;">SMPL RATE</span>
    <input type="range" min="0" max="100" value="50"
      style="width:60px;accent-color:#00ff41;height:2px;cursor:pointer;-webkit-appearance:none;
      background:linear-gradient(90deg,#003300,#00ff41);border-radius:1px;outline:none;">
    <span style="min-width:38px;text-align:right;color:#00ffff;font-size:8px;">1.2kHz</span>
  `;
  wrapper.appendChild(ctrl);

  const slider = ctrl.querySelector('input');
  const valSpan = ctrl.querySelector('span:last-child');
  const freqLabels = ['0.1kHz','0.3kHz','0.6kHz','1.2kHz','2.4kHz','4.8kHz','9.6kHz','19.2k','38.4k','48.0k','96.0k'];
  slider.addEventListener('input', () => {
    const pct = parseInt(slider.value) / 100;
    speed = Math.round(200 - pct * 192);
    const idx = Math.min(Math.floor(pct * 10), 10);
    valSpan.textContent = freqLabels[idx];
  });
}

// --- HEX DUMP ---
function createHexDump(body) {
  const container = document.createElement('div');
  container.className = 'hex-dump';
  body.appendChild(container);

  function updateHex() {
    if (!document.body.contains(container)) return;
    let html = '';
    const baseAddr = randInt(0x10000000, 0x7FFFFFFF);
    for (let i = 0; i < 30; i++) {
      const addr = (baseAddr + i * 16).toString(16).padStart(8, '0');
      const bytes = Array.from({length: 16}, () => hex());
      const ascii = bytes.map(b => {
        const c = parseInt(b, 16);
        return (c >= 32 && c <= 126) ? String.fromCharCode(c) : '.';
      }).join('');

      // Highlight some bytes randomly
      const highlighted = bytes.map(b =>
        Math.random() > 0.92 ? `<span style="color:var(--red)">${b}</span>` :
        Math.random() > 0.95 ? `<span style="color:var(--cyan)">${b}</span>` : b
      );

      html += `<span style="color:var(--cyan)">${addr}</span>  <span style="color:var(--green)">${highlighted.join(' ')}</span>  <span style="color:#666">${ascii}</span>\n`;
    }
    container.innerHTML = html;
    setTimeout(updateHex, 500);
  }
  updateHex();
}

// --- RADAR (WebGL) ---
function createRadar(body) {
  createGLPanel(body, `
    precision highp float;
    varying vec2 v;
    uniform float T;
    uniform vec2 R;
    float hash(float n){return fract(sin(n)*43758.5453);}
    #define PI 3.14159265
    #define TAU 6.28318530
    void main(){
      float aspect=R.x/R.y;
      vec2 uv=(v-0.5)*vec2(aspect,1.0);
      float dist=length(uv);
      float maxR=min(aspect,1.0)*0.5-0.05;
      float angle=atan(uv.y,uv.x);
      float px=1.0/R.y;
      vec3 col=vec3(0.0);
      // Rings
      for(int i=1;i<=4;i++){
        float r=maxR*float(i)/4.0;
        col+=vec3(0.0,1.0,0.25)*0.2*smoothstep(1.5*px,0.0,abs(dist-r));
      }
      // Cross
      float onDisk=step(dist,maxR);
      col+=vec3(0.0,1.0,0.25)*0.12*smoothstep(1.0*px,0.0,abs(uv.x))*onDisk;
      col+=vec3(0.0,1.0,0.25)*0.12*smoothstep(1.0*px,0.0,abs(uv.y))*onDisk;
      // Sweep
      float sweep=mod(T*0.8,TAU);
      float a=mod(angle-sweep+TAU,TAU);
      float sweepTrail=smoothstep(0.6,0.0,a)*0.2*step(dist,maxR);
      col+=vec3(0.0,1.0,0.25)*sweepTrail;
      // Sweep line
      float sweepLine=smoothstep(2.5*px,0.0,abs(a))*step(dist,maxR)*smoothstep(0.0,0.01,dist);
      col+=vec3(0.0,1.0,0.25)*0.8*sweepLine;
      // Blips (12 procedural)
      for(int i=0;i<12;i++){
        float fi=float(i);
        float ba=hash(fi*1.17)*TAU+sin(T*0.05+fi)*0.3;
        float bd=0.15+hash(fi*2.31)*0.7;
        vec2 bp=vec2(cos(ba),sin(ba))*bd*maxR;
        float bDist=length(uv-bp);
        // Fade from sweep
        float diff=mod(sweep-ba+TAU,TAU);
        float alpha=max(0.0,1.0-diff/(PI*1.5));
        bool threat=hash(fi*3.47)>0.7;
        vec3 bc=threat?vec3(1.0,0.0,0.25):vec3(0.0,1.0,0.25);
        col+=bc*alpha*smoothstep(4.0*px,0.0,bDist);
      }
      // Center dot
      col+=vec3(0.0,1.0,0.25)*smoothstep(3.0*px,0.0,dist);
      // Clip to disk
      col*=smoothstep(maxR+px,maxR-px,dist);
      gl_FragColor=vec4(col,1.0);
    }
  `);
}

// --- FAKE VIDEO FEED (WebGL) ---
function createVideoFeed(body, label) {
  const container = document.createElement('div');
  container.className = 'video-feed';

  const feedBody = document.createElement('div');
  feedBody.style.cssText = 'width:100%;height:100%;position:relative;';
  container.appendChild(feedBody);

  const overlay = document.createElement('div');
  overlay.className = 'video-overlay rec';
  overlay.textContent = `REC ${label || 'CAM-' + randInt(1,12)}`;
  container.appendChild(overlay);

  const overlay2 = document.createElement('div');
  overlay2.className = 'video-overlay';
  overlay2.style.cssText = 'bottom:4px;top:auto;right:4px;left:auto;color:var(--green);text-shadow:none;font-size:8px;';
  container.appendChild(overlay2);

  body.appendChild(container);

  // Update timestamp with DOM (cheap)
  setInterval(() => {
    if (!document.body.contains(overlay2)) return;
    overlay2.textContent = `${new Date().toISOString()} | ${randInt(24,30)}fps`;
  }, 500);

  createGLPanel(feedBody, `
    precision highp float;
    varying vec2 v;
    uniform float T;
    uniform vec2 R;
    float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
    void main(){
      vec2 uv=v;
      // Noise background (GPU noise — replaces CPU per-pixel loop)
      float n=hash(uv*R+T*100.0)*0.1;
      vec3 col=vec3(n*0.8,n+hash(uv*R+T*77.0)*0.04,n*0.8);
      // 3 thermal blobs
      for(int i=0;i<3;i++){
        float fi=float(i);
        vec2 bp=vec2(0.3+0.4*sin(T*0.3+fi*2.0),0.3+0.3*cos(T*0.2+fi*3.0));
        float d=length(uv-bp);
        float r=0.08+sin(T+fi)*0.03;
        float blob=smoothstep(r,0.0,d)*0.3;
        col+=vec3(0.0,blob,blob*0.4);
        // Target box
        vec2 diff=abs(uv-bp);
        float boxS=0.07;
        float px=1.0/R.y;
        float box=smoothstep(1.5*px,0.0,abs(diff.x-boxS))*step(diff.y,boxS)
                  +smoothstep(1.5*px,0.0,abs(diff.y-boxS))*step(diff.x,boxS);
        col+=vec3(1.0,0.0,0.25)*0.6*box;
      }
      // Crosshair
      float px=1.0/R.y;
      col+=vec3(0.0,1.0,1.0)*0.3*smoothstep(1.0*px,0.0,abs(uv.x-0.5));
      col+=vec3(0.0,1.0,1.0)*0.3*smoothstep(1.0*px,0.0,abs(uv.y-0.5));
      float cd=abs(length((uv-0.5)*vec2(R.x/R.y,1.0))-0.08);
      col+=vec3(0.0,1.0,1.0)*0.25*smoothstep(1.5*px,0.0,cd);
      // Scanline
      float scanY=fract(T*0.15);
      col+=vec3(0.0,1.0,0.25)*0.05*smoothstep(3.0*px,0.0,abs(uv.y-scanY));
      gl_FragColor=vec4(col,1.0);
    }
  `);
}

// --- DATA TABLE ---
function createDataTable(body) {
  const table = document.createElement('table');
  table.className = 'data-table';
  const thead = document.createElement('thead');
  thead.innerHTML = '<tr><th>IP</th><th>PORT</th><th>PROTO</th><th>STATUS</th><th>LATENCY</th><th>COUNTRY</th></tr>';
  table.appendChild(thead);
  const tbody = document.createElement('tbody');
  table.appendChild(tbody);

  const wrapper = document.createElement('div');
  wrapper.style.cssText = 'overflow-y:auto;height:100%;';
  wrapper.appendChild(table);
  body.appendChild(wrapper);

  const countries = ['US','RU','CN','DE','JP','BR','UK','FR','KR','IN','AU','NL','SE','UA','IR'];
  const statuses = ['OPEN','CLOSED','FILTERED','HONEYPOT','COMPROMISED'];
  const protocols = ['TCP','UDP','ICMP','SSH','HTTPS','DNS','FTP','SMTP'];
  const statusColors = { OPEN: 'var(--green)', CLOSED: '#666', FILTERED: 'var(--amber)', HONEYPOT: 'var(--red)', COMPROMISED: 'var(--purple)' };

  function addRow() {
    if (!document.body.contains(tbody)) return;
    const status = pick(statuses);
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${ipAddr()}</td>
      <td>${pick([22,80,443,3306,5432,8080,8443,27017,6379])}</td>
      <td>${pick(protocols)}</td>
      <td style="color:${statusColors[status]}">${status}</td>
      <td>${randInt(1,500)}ms</td>
      <td>${pick(countries)}</td>
    `;
    tr.style.cursor = 'pointer';
    tr.addEventListener('click', () => {
      notify(`Targeting ${tr.children[0].textContent}:${tr.children[1].textContent}`);
      $$('.data-table tr').forEach(r => r.style.background = '');
      tr.style.background = 'rgba(0,255,65,0.1)';
    });
    tbody.insertBefore(tr, tbody.firstChild);
    if (tbody.children.length > 50) tbody.removeChild(tbody.lastChild);
    setTimeout(addRow, rand(300, 1500));
  }
  addRow();
}

// --- SPECTRUM / HEATMAP (WebGL) ---
function createSpectrum(body) {
  createGLPanel(body, `
    precision highp float;
    varying vec2 v;
    uniform float T;
    uniform vec2 R;
    float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
    void main(){
      vec2 uv=v;
      // Waterfall: x = frequency bin, y = time (scrolling down)
      float freq=uv.x*64.0;
      float timeRow=uv.y*60.0-T*4.0;
      // Procedural spectrum intensity
      float val=abs(sin(timeRow*0.2+freq*0.2))*0.5
               +abs(sin(timeRow*0.5+freq*0.5))*0.3
               +hash(vec2(floor(freq),floor(timeRow)))*0.2;
      val=clamp(val,0.0,1.0);
      // Heatmap color: black→green→yellow→red
      vec3 col;
      if(val<0.33){col=mix(vec3(0.0),vec3(0.0,1.0,0.0),val*3.0);}
      else if(val<0.66){col=mix(vec3(0.0,1.0,0.0),vec3(1.0,1.0,0.0),(val-0.33)*3.0);}
      else{col=mix(vec3(1.0,1.0,0.0),vec3(1.0,0.0,0.0),(val-0.66)*3.0);}
      col*=0.8;
      gl_FragColor=vec4(col,1.0);
    }
  `);
}

// --- PIE/DONUT CHART (WebGL) ---
function createDonutChart(body) {
  createGLPanel(body, `
    precision highp float;
    varying vec2 v;
    uniform float T;
    uniform vec2 R;
    #define PI 3.14159265
    #define TAU 6.28318530
    void main(){
      float aspect=R.x/R.y;
      // Center donut on left 60% of panel
      vec2 center=vec2(0.35,0.5);
      vec2 uv=(v-center)*vec2(aspect,1.0);
      float dist=length(uv);
      float angle=mod(atan(uv.y,uv.x)+PI*2.5+sin(T*0.5)*0.1,TAU);
      float maxR=0.38;
      float innerR=maxR*0.55;
      float px=1.0/R.y;
      vec3 col=vec3(0.0);
      // 5 segments with fixed proportions (42,23,15,12,8 out of 100)
      float cuts[6];
      cuts[0]=0.0;cuts[1]=0.42;cuts[2]=0.65;cuts[3]=0.80;cuts[4]=0.92;cuts[5]=1.0;
      // Wobble cuts slightly
      float w1=sin(T*0.7)*0.01;float w2=sin(T*1.1)*0.01;
      cuts[1]+=w1;cuts[2]+=w2;cuts[3]-=w1;cuts[4]+=w2;
      vec3 colors[5];
      colors[0]=vec3(0.0,1.0,0.25);  // green
      colors[1]=vec3(1.0,0.75,0.0);  // amber
      colors[2]=vec3(1.0,0.0,0.25);  // red
      colors[3]=vec3(0.75,0.0,1.0);  // purple
      colors[4]=vec3(0.0,0.5,1.0);   // blue
      float angleNorm=angle/TAU;
      if(dist>innerR && dist<maxR){
        for(int i=0;i<5;i++){
          if(angleNorm>=cuts[i] && angleNorm<cuts[i+1]){
            col=colors[i]*0.8;
            // Gap between segments
            float gapA=smoothstep(0.0,0.008,angleNorm-cuts[i]);
            float gapB=smoothstep(0.0,0.008,cuts[i+1]-angleNorm);
            col*=gapA*gapB;
          }
        }
        // Edge anti-alias
        col*=smoothstep(innerR-px,innerR+px,dist)*smoothstep(maxR+px,maxR-px,dist);
      }
      // Legend dots on the right side
      float lx=0.72*aspect;
      for(int i=0;i<5;i++){
        float fi=float(i);
        vec2 lp=vec2(lx,(0.2+fi*0.14));
        vec2 luv=(v-vec2(lp.x/aspect,lp.y))*vec2(aspect,1.0);
        if(abs(luv.x)<0.012 && abs(luv.y)<0.012) col=colors[i];
      }
      gl_FragColor=vec4(col,1.0);
    }
  `);
}

// --- BAR CHART (WebGL) ---
function createBarChart(body) {
  createGLPanel(body, `
    precision highp float;
    varying vec2 v;
    uniform float T;
    uniform vec2 R;
    float hash(float n){return fract(sin(n)*43758.5453);}
    void main(){
      vec2 uv=v;
      float px=1.0/R.y;
      vec3 col=vec3(0.0);
      // Grid lines
      for(int i=0;i<5;i++){
        float gy=0.1+float(i)*0.17;
        col+=vec3(0.0,0.27,0.0)*0.3*smoothstep(1.0*px,0.0,abs(uv.y-gy));
      }
      // 8 bars
      vec3 colors[8];
      colors[0]=vec3(0.0,1.0,0.25);colors[1]=vec3(0.0,1.0,1.0);
      colors[2]=vec3(1.0,0.75,0.0);colors[3]=vec3(1.0,0.0,0.25);
      colors[4]=vec3(0.75,0.0,1.0);colors[5]=vec3(0.0,0.5,1.0);
      colors[6]=vec3(0.0,1.0,0.25);colors[7]=vec3(1.0,0.75,0.0);
      float barW=1.0/8.0;
      float margin=0.08;
      for(int i=0;i<8;i++){
        float fi=float(i);
        float bx=margin+fi*(1.0-margin*2.0)/8.0;
        float bw=(1.0-margin*2.0)/8.0*0.7;
        // Animated height
        float h=0.3+hash(fi*1.17)*0.5+sin(T*1.5+fi*0.7)*0.1+sin(T*3.7+fi*1.3)*0.05;
        h=clamp(h,0.05,0.9);
        // Bar body
        if(uv.x>bx && uv.x<bx+bw && uv.y<h && uv.y>0.02){
          float gradT=(uv.y)/h;
          col+=colors[i]*(0.3+gradT*0.6);
          // Glow at top
          col+=colors[i]*0.4*smoothstep(3.0*px,0.0,abs(uv.y-h));
        }
        // Top cap glow
        if(uv.x>bx-0.005 && uv.x<bx+bw+0.005){
          col+=colors[i]*0.3*smoothstep(4.0*px,0.0,abs(uv.y-h));
        }
      }
      gl_FragColor=vec4(col,1.0);
    }
  `);
}

// --- WORLD MAP (ASCII-ish) ---
function createWorldMap(body) {
  const container = document.createElement('div');
  container.style.cssText = 'width:100%;height:100%;position:relative;overflow:hidden;';
  body.appendChild(container);

  // --- HUD overlay canvas for labels/stats ---
  const hudCanvas = document.createElement('canvas');
  hudCanvas.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:2;';
  container.appendChild(hudCanvas);

  // --- Three.js setup ---
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
  camera.position.z = 3.2;

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setClearColor(0x000000, 0);
  container.insertBefore(renderer.domElement, hudCanvas);
  renderer.domElement.style.cssText = 'width:100%;height:100%;position:absolute;top:0;left:0;';

  const globeGroup = new THREE.Group();
  scene.add(globeGroup);

  const GLOBE_R = 1.0;

  // --- Wireframe sphere (latitude/longitude lines) ---
  function buildWireframeGlobe() {
    const material = new THREE.LineBasicMaterial({ color: 0x004400, transparent: true, opacity: 0.5 });
    const brightMat = new THREE.LineBasicMaterial({ color: 0x00ff41, transparent: true, opacity: 0.15 });

    // Latitude lines
    for (let lat = -80; lat <= 80; lat += 20) {
      const phi = (90 - lat) * Math.PI / 180;
      const r = GLOBE_R * Math.sin(phi);
      const y = GLOBE_R * Math.cos(phi);
      const pts = [];
      for (let i = 0; i <= 72; i++) {
        const theta = (i / 72) * Math.PI * 2;
        pts.push(new THREE.Vector3(r * Math.cos(theta), y, r * Math.sin(theta)));
      }
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      globeGroup.add(new THREE.Line(geom, lat === 0 ? brightMat : material));
    }

    // Longitude lines
    for (let lon = 0; lon < 360; lon += 20) {
      const theta = lon * Math.PI / 180;
      const pts = [];
      for (let i = 0; i <= 72; i++) {
        const phi = (i / 72) * Math.PI;
        pts.push(new THREE.Vector3(
          GLOBE_R * Math.sin(phi) * Math.cos(theta),
          GLOBE_R * Math.cos(phi),
          GLOBE_R * Math.sin(phi) * Math.sin(theta)
        ));
      }
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      globeGroup.add(new THREE.Line(geom, (lon === 0 || lon === 180) ? brightMat : material));
    }

    // Outer glow ring (equator emphasis)
    const glowMat = new THREE.LineBasicMaterial({ color: 0x00ff41, transparent: true, opacity: 0.08 });
    for (let offset = 0.01; offset <= 0.03; offset += 0.01) {
      const pts = [];
      for (let i = 0; i <= 72; i++) {
        const theta = (i / 72) * Math.PI * 2;
        pts.push(new THREE.Vector3((GLOBE_R + offset) * Math.cos(theta), 0, (GLOBE_R + offset) * Math.sin(theta)));
      }
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      globeGroup.add(new THREE.Line(geom, glowMat));
    }
  }
  buildWireframeGlobe();

  // --- Atmosphere shell ---
  const atmosGeom = new THREE.SphereGeometry(GLOBE_R * 1.02, 32, 32);
  const atmosMat = new THREE.MeshBasicMaterial({
    color: 0x00ff41, transparent: true, opacity: 0.03, side: THREE.BackSide
  });
  globeGroup.add(new THREE.Mesh(atmosGeom, atmosMat));

  // --- lat/lon → 3D helper ---
  function latLonToVec3(lat, lon, radius) {
    const phi = (90 - lat) * Math.PI / 180;
    const theta = (lon + 180) * Math.PI / 180;
    return new THREE.Vector3(
      -radius * Math.sin(phi) * Math.cos(theta),
      radius * Math.cos(phi),
      radius * Math.sin(phi) * Math.sin(theta)
    );
  }

  // --- Depth-fade shader for coastlines ---
  // Vertices on the far side of the globe (facing away from camera) dim out
  const depthFadeVertexShader = `
    varying vec3 vWorldPosition;
    varying vec3 vWorldNormal;
    void main() {
      vec4 worldPos = modelMatrix * vec4(position, 1.0);
      vWorldPosition = worldPos.xyz;
      // For lines on a sphere, the "normal" is just the normalized position (points outward from center)
      vWorldNormal = normalize((modelMatrix * vec4(normalize(position), 0.0)).xyz);
      gl_Position = projectionMatrix * viewMatrix * worldPos;
    }
  `;

  function makeDepthFadeFragShader(r, g, b, baseOpacity) {
    return `
      uniform vec3 uCameraPos;
      uniform float uFalloff;
      uniform float uMinOpacity;
      varying vec3 vWorldPosition;
      varying vec3 vWorldNormal;
      void main() {
        vec3 toCamera = normalize(uCameraPos - vWorldPosition);
        // dot = 1.0 when facing camera, -1.0 when facing away
        float facing = dot(vWorldNormal, toCamera);
        // Remap: 0..1 range for front-facing, clamp back-facing
        float facingNorm = clamp(facing, 0.0, 1.0);
        // Apply power curve for falloff control: higher = sharper cutoff
        float fade = pow(facingNorm, uFalloff);
        // Mix between min opacity and full opacity
        float alpha = mix(uMinOpacity, ${baseOpacity.toFixed(2)}, fade);
        gl_FragColor = vec4(${(r/255).toFixed(3)}, ${(g/255).toFixed(3)}, ${(b/255).toFixed(3)}, alpha);
      }
    `;
  }

  // Shared uniforms (updated every frame)
  const depthFadeUniforms = {
    uCameraPos: { value: new THREE.Vector3(0, 0, 3.2) },
    uFalloff: { value: 2.5 },
    uMinOpacity: { value: 0.03 },
  };

  function makeDepthFadeMaterial(r, g, b, baseOpacity) {
    return new THREE.ShaderMaterial({
      vertexShader: depthFadeVertexShader,
      fragmentShader: makeDepthFadeFragShader(r, g, b, baseOpacity),
      uniforms: {
        uCameraPos: depthFadeUniforms.uCameraPos,
        uFalloff: depthFadeUniforms.uFalloff,
        uMinOpacity: depthFadeUniforms.uMinOpacity,
      },
      transparent: true,
      depthWrite: false,
    });
  }

  // Materials using the depth-fade shader
  const coastMat = makeDepthFadeMaterial(0, 255, 65, 0.8);       // bright green coastlines
  const coastGlowMat = makeDepthFadeMaterial(0, 255, 65, 0.2);   // subtle inner glow
  const borderMat = makeDepthFadeMaterial(0, 68, 0, 0.35);       // dim country borders

  // Upgrade wireframe grid lines to use depth-fade too
  const gridFadeMat = makeDepthFadeMaterial(0, 68, 0, 0.5);      // dark grid lines
  const gridBrightFadeMat = makeDepthFadeMaterial(0, 255, 65, 0.15); // equator/prime meridian
  const gridGlowFadeMat = makeDepthFadeMaterial(0, 255, 65, 0.08);  // outer glow rings
  globeGroup.children.forEach(child => {
    if (child.isLine && child.material) {
      const c = child.material.color;
      const o = child.material.opacity;
      if (!child.material.isShaderMaterial) {
        // Match by color/opacity to the right replacement
        if (c && c.r < 0.02 && c.g < 0.28 && o >= 0.4) {
          child.material = gridFadeMat; // dark green grid
        } else if (c && c.g > 0.9 && o < 0.12) {
          child.material = gridGlowFadeMat; // glow rings
        } else if (c && c.g > 0.9 && o < 0.2) {
          child.material = gridBrightFadeMat; // bright lines (equator etc)
        }
      }
    }
  });

  // --- HUD control panel (slider) ---
  const controlPanel = document.createElement('div');
  controlPanel.style.cssText = `
    position:absolute; bottom:6px; right:6px; z-index:5;
    background: rgba(0,10,0,0.85); border:1px solid rgba(0,255,65,0.3);
    padding: 8px 10px; font-size:9px; color:#00ff41;
    font-family:'Share Tech Mono',monospace; pointer-events:auto;
    box-shadow: 0 0 10px rgba(0,255,65,0.1); min-width: 150px;
  `;
  controlPanel.innerHTML = `
    <div style="color:#00ffff;letter-spacing:1px;margin-bottom:6px;font-size:8px;">◆ RENDER CTRL</div>
    <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
      <span style="white-space:nowrap;min-width:56px;">FALLOFF</span>
      <input type="range" id="globe-falloff" min="0" max="80" value="25"
        style="flex:1;accent-color:#00ff41;height:3px;cursor:pointer;-webkit-appearance:none;
        background:linear-gradient(90deg,#003300,#00ff41);border-radius:2px;outline:none;">
      <span id="globe-falloff-val" style="min-width:28px;text-align:right;color:#00ffff;">2.5</span>
    </div>
    <div style="display:flex;align-items:center;gap:6px;">
      <span style="white-space:nowrap;min-width:56px;">MIN <span style="font-size:7px;color:#666;">OPACITY</span></span>
      <input type="range" id="globe-minopac" min="0" max="100" value="3"
        style="flex:1;accent-color:#00ff41;height:3px;cursor:pointer;-webkit-appearance:none;
        background:linear-gradient(90deg,#003300,#00ff41);border-radius:2px;outline:none;">
      <span id="globe-minopac-val" style="min-width:28px;text-align:right;color:#00ffff;">0.03</span>
    </div>
  `;
  container.appendChild(controlPanel);

  // Wire up slider events
  const falloffSlider = controlPanel.querySelector('#globe-falloff');
  const falloffVal = controlPanel.querySelector('#globe-falloff-val');
  const minopacSlider = controlPanel.querySelector('#globe-minopac');
  const minopacVal = controlPanel.querySelector('#globe-minopac-val');

  falloffSlider.addEventListener('input', () => {
    const v = parseFloat(falloffSlider.value) / 10;
    depthFadeUniforms.uFalloff.value = v;
    falloffVal.textContent = v.toFixed(1);
  });
  minopacSlider.addEventListener('input', () => {
    const v = parseFloat(minopacSlider.value) / 100;
    depthFadeUniforms.uMinOpacity.value = v;
    minopacVal.textContent = v.toFixed(2);
  });

  // Prevent panel drag when interacting with sliders
  controlPanel.addEventListener('mousedown', e => e.stopPropagation());

  // --- Real coastline outlines from Natural Earth 110m ---
  const coastlineGroup = new THREE.Group();
  globeGroup.add(coastlineGroup);

  fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')
    .then(r => r.json())
    .then(world => {
      const land = topojson.feature(world, world.objects.land);

      // Process each polygon/multipolygon
      const geometries = land.type === 'FeatureCollection' ? land.features.map(f => f.geometry) : [land.geometry || land];

      geometries.forEach(geom => {
        let rings = [];
        if (geom.type === 'Polygon') {
          rings = geom.coordinates;
        } else if (geom.type === 'MultiPolygon') {
          geom.coordinates.forEach(poly => {
            rings = rings.concat(poly);
          });
        }

        rings.forEach(ring => {
          const points = [];
          const innerPoints = [];

          for (let i = 0; i < ring.length; i++) {
            const [lon, lat] = ring[i];
            points.push(latLonToVec3(lat, lon, GLOBE_R * 1.003));
            innerPoints.push(latLonToVec3(lat, lon, GLOBE_R * 1.001));
          }

          if (points.length < 2) return;

          // Main coastline outline (depth-faded)
          const lineGeom = new THREE.BufferGeometry().setFromPoints(points);
          coastlineGroup.add(new THREE.Line(lineGeom, coastMat));

          // Inner glow line (depth-faded, dimmer)
          const glowGeom = new THREE.BufferGeometry().setFromPoints(innerPoints);
          coastlineGroup.add(new THREE.Line(glowGeom, coastGlowMat));
        });
      });

      // Also load country borders for extra detail
      return fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
    })
    .then(r => r.json())
    .then(world => {
      const borders = topojson.mesh(world, world.objects.countries, (a, b) => a !== b);

      if (borders.type === 'MultiLineString') {
        borders.coordinates.forEach(line => {
          const points = [];
          for (let i = 0; i < line.length; i++) {
            const [lon, lat] = line[i];
            points.push(latLonToVec3(lat, lon, GLOBE_R * 1.002));
          }
          if (points.length >= 2) {
            const geom = new THREE.BufferGeometry().setFromPoints(points);
            coastlineGroup.add(new THREE.Line(geom, borderMat));
          }
        });
      }
    })
    .catch(err => {
      console.warn('Failed to load coastline data, falling back to dot cloud', err);
      const boxes = [
        { latMin: 25, latMax: 70, lonMin: -140, lonMax: -55 },
        { latMin: -55, latMax: 10, lonMin: -80, lonMax: -35 },
        { latMin: 35, latMax: 70, lonMin: -10, lonMax: 40 },
        { latMin: -35, latMax: 35, lonMin: -18, lonMax: 50 },
        { latMin: 10, latMax: 70, lonMin: 60, lonMax: 180 },
        { latMin: -40, latMax: -12, lonMin: 112, lonMax: 155 },
      ];
      const verts = [];
      boxes.forEach(b => {
        for (let i = 0; i < 200; i++) {
          const v = latLonToVec3(rand(b.latMin, b.latMax), rand(b.lonMin, b.lonMax), GLOBE_R * 1.002);
          verts.push(v.x, v.y, v.z);
        }
      });
      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
      coastlineGroup.add(new THREE.Points(geom, new THREE.PointsMaterial({ color: 0x00ff41, size: 0.012, transparent: true, opacity: 0.6 })));
    });

  // --- Cities ---
  const cities = [
    { name: 'NYC', lat: 40.7, lon: -74, threat: false },
    { name: 'LON', lat: 51.5, lon: -0.1, threat: false },
    { name: 'TYO', lat: 35.7, lon: 139.7, threat: false },
    { name: 'MOS', lat: 55.8, lon: 37.6, threat: true },
    { name: 'BEJ', lat: 39.9, lon: 116.4, threat: true },
    { name: 'SYD', lat: -33.9, lon: 151.2, threat: false },
    { name: 'BER', lat: 52.5, lon: 13.4, threat: false },
    { name: 'SAO', lat: -23.5, lon: -46.6, threat: true },
    { name: 'SEL', lat: 37.6, lon: 127, threat: false },
    { name: 'DXB', lat: 25.2, lon: 55.3, threat: true },
    { name: 'SIN', lat: 1.3, lon: 103.8, threat: false },
    { name: 'LAX', lat: 34, lon: -118.2, threat: false },
    { name: 'PAR', lat: 48.9, lon: 2.35, threat: false },
    { name: 'MUM', lat: 19.1, lon: 72.9, threat: true },
    { name: 'JKT', lat: -6.2, lon: 106.8, threat: false },
    { name: 'LIM', lat: -12, lon: -77, threat: true },
  ];

  // City markers as small sphere meshes
  const cityMeshes = [];
  cities.forEach(c => {
    const pos = latLonToVec3(c.lat, c.lon, GLOBE_R * 1.01);
    const geom = new THREE.SphereGeometry(0.015, 8, 8);
    const mat = new THREE.MeshBasicMaterial({ color: c.threat ? 0xff0040 : 0x00ff41 });
    const mesh = new THREE.Mesh(geom, mat);
    mesh.position.copy(pos);
    mesh.userData = c;
    globeGroup.add(mesh);
    cityMeshes.push(mesh);

    // Pulsing ring
    const ringGeom = new THREE.RingGeometry(0.02, 0.03, 16);
    const ringMat = new THREE.MeshBasicMaterial({
      color: c.threat ? 0xff0040 : 0x00ff41,
      transparent: true, opacity: 0.4, side: THREE.DoubleSide
    });
    const ring = new THREE.Mesh(ringGeom, ringMat);
    ring.position.copy(pos);
    ring.lookAt(new THREE.Vector3(0, 0, 0));
    ring.userData.pulsePhase = rand(0, Math.PI * 2);
    ring.userData.baseScale = 1;
    globeGroup.add(ring);
    c._ring = ring;
    c._mesh = mesh;
    c._pos = pos;
  });

  // --- Vertical ping beams from cities ---
  cities.forEach(c => {
    const dir = c._pos.clone().normalize();
    const beamEnd = dir.clone().multiplyScalar(GLOBE_R * 1.15);
    const pts = [c._pos.clone(), beamEnd];
    const geom = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({
      color: c.threat ? 0xff0040 : 0x00ff41,
      transparent: true, opacity: 0.3
    });
    const beam = new THREE.Line(geom, mat);
    globeGroup.add(beam);
    c._beam = beam;
    c._beamMat = mat;
  });

  // --- Attack arcs ---
  const attacks = [];

  function createArcCurve(fromCity, toCity) {
    const from = latLonToVec3(fromCity.lat, fromCity.lon, GLOBE_R * 1.01);
    const to = latLonToVec3(toCity.lat, toCity.lon, GLOBE_R * 1.01);
    const mid = from.clone().add(to).multiplyScalar(0.5);
    const dist = from.distanceTo(to);
    // Lift control point above the globe surface
    mid.normalize().multiplyScalar(GLOBE_R + dist * 0.5);

    const curve = new THREE.QuadraticBezierCurve3(from, mid, to);
    const points = curve.getPoints(64);
    return { curve, points, from, to, mid };
  }

  function spawnAttack() {
    const threatCities = cities.filter(c => c.threat);
    const safeCities = cities.filter(c => !c.threat);
    const from = pick(threatCities);
    const to = pick(safeCities);
    if (!from || !to) return;

    const { curve, points } = createArcCurve(from, to);

    // Arc trail line
    const trailGeom = new THREE.BufferGeometry().setFromPoints(points);
    const trailMat = new THREE.LineBasicMaterial({
      color: 0xff0040, transparent: true, opacity: 0.6
    });
    const trail = new THREE.Line(trailGeom, trailMat);
    globeGroup.add(trail);

    // Projectile (bright dot)
    const projGeom = new THREE.SphereGeometry(0.012, 6, 6);
    const projMat = new THREE.MeshBasicMaterial({ color: 0xff4444 });
    const projectile = new THREE.Mesh(projGeom, projMat);
    globeGroup.add(projectile);

    // Glow around projectile
    const glowGeom = new THREE.SphereGeometry(0.025, 6, 6);
    const glowMat = new THREE.MeshBasicMaterial({ color: 0xff0040, transparent: true, opacity: 0.3 });
    const glow = new THREE.Mesh(glowGeom, glowMat);
    globeGroup.add(glow);

    attacks.push({
      from, to, curve, trail, trailGeom, trailMat,
      projectile, projMat, glow, glowMat,
      progress: 0,
      speed: rand(0.003, 0.012),
      alive: true
    });
  }

  // --- Impact explosions ---
  const impacts = [];
  function createImpact(position) {
    const ringGeom = new THREE.RingGeometry(0.01, 0.02, 24);
    const ringMat = new THREE.MeshBasicMaterial({
      color: 0xff0040, transparent: true, opacity: 0.9, side: THREE.DoubleSide
    });
    const ring = new THREE.Mesh(ringGeom, ringMat);
    ring.position.copy(position);
    ring.lookAt(new THREE.Vector3(0, 0, 0));
    globeGroup.add(ring);
    impacts.push({ ring, ringMat, scale: 1, life: 1.0 });
  }

  // --- Starfield background ---
  const starVerts = [];
  for (let i = 0; i < 1500; i++) {
    starVerts.push(rand(-50, 50), rand(-50, 50), rand(-50, 50));
  }
  const starGeom = new THREE.BufferGeometry();
  starGeom.setAttribute('position', new THREE.Float32BufferAttribute(starVerts, 3));
  const starMat = new THREE.PointsMaterial({ color: 0x004400, size: 0.15 });
  scene.add(new THREE.Points(starGeom, starMat));

  // --- Orbital ring (decoration) ---
  const orbitPts = [];
  for (let i = 0; i <= 128; i++) {
    const a = (i / 128) * Math.PI * 2;
    orbitPts.push(new THREE.Vector3(Math.cos(a) * 1.6, Math.sin(a) * 0.1, Math.sin(a) * 1.6));
  }
  const orbitGeom = new THREE.BufferGeometry().setFromPoints(orbitPts);
  const orbitMat = new THREE.LineBasicMaterial({ color: 0x003300, transparent: true, opacity: 0.3 });
  const orbitLine = new THREE.Line(orbitGeom, orbitMat);
  orbitLine.rotation.x = 0.3;
  scene.add(orbitLine);

  // Second orbit ring
  const orbit2 = orbitLine.clone();
  orbit2.rotation.x = -0.5;
  orbit2.rotation.z = 0.8;
  scene.add(orbit2);

  // --- Mouse interaction (drag to rotate) ---
  let isDragging = false;
  let prevMouse = { x: 0, y: 0 };
  let rotationVelocity = { x: 0, y: 0.003 }; // auto-rotate by default

  renderer.domElement.style.pointerEvents = 'auto';
  renderer.domElement.addEventListener('mousedown', e => {
    isDragging = true;
    prevMouse = { x: e.clientX, y: e.clientY };
  });
  renderer.domElement.addEventListener('mousemove', e => {
    if (!isDragging) return;
    const dx = e.clientX - prevMouse.x;
    const dy = e.clientY - prevMouse.y;
    rotationVelocity.y = dx * 0.003;
    rotationVelocity.x = dy * 0.002;
    prevMouse = { x: e.clientX, y: e.clientY };
  });
  renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });
  renderer.domElement.addEventListener('mouseleave', () => { isDragging = false; });

  // Scroll to zoom
  renderer.domElement.addEventListener('wheel', e => {
    e.preventDefault();
    camera.position.z = Math.max(1.8, Math.min(6, camera.position.z + e.deltaY * 0.002));
  }, { passive: false });

  // --- Animation loop ---
  let attackTimer = 0;
  let activeAttackCount = 0;

  function animate() {
    if (!document.body.contains(container)) return;
    requestAnimationFrame(animate);

    const w = container.clientWidth;
    const h = container.clientHeight;
    if (w === 0 || h === 0) return;

    renderer.setSize(w, h);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    hudCanvas.width = w;
    hudCanvas.height = h;

    const time = Date.now() / 1000;

    // Rotate globe
    if (!isDragging) {
      rotationVelocity.y += (0.003 - rotationVelocity.y) * 0.02; // ease back to auto-rotate
      rotationVelocity.x *= 0.95; // dampen vertical
    }
    globeGroup.rotation.y += rotationVelocity.y;
    globeGroup.rotation.x += rotationVelocity.x;
    // Clamp vertical rotation
    globeGroup.rotation.x = Math.max(-1.2, Math.min(1.2, globeGroup.rotation.x));
    if (!isDragging) rotationVelocity.y *= 0.99;

    // Pulse city rings
    cities.forEach(c => {
      if (c._ring) {
        const s = 1 + Math.sin(time * 3 + c._ring.userData.pulsePhase) * 0.5;
        c._ring.scale.set(s, s, s);
        c._ring.material.opacity = 0.2 + Math.sin(time * 3 + c._ring.userData.pulsePhase) * 0.2;
      }
      // Pulse beams
      if (c._beamMat) {
        c._beamMat.opacity = 0.15 + Math.sin(time * 4 + c.lon) * 0.15;
      }
    });

    // Spawn attacks
    attackTimer += 0.016;
    if (attackTimer > rand(0.8, 2.5) && attacks.filter(a => a.alive).length < 8) {
      spawnAttack();
      attackTimer = 0;
    }

    // Update attacks
    activeAttackCount = 0;
    for (let i = attacks.length - 1; i >= 0; i--) {
      const atk = attacks[i];
      if (!atk.alive) continue;
      activeAttackCount++;

      atk.progress += atk.speed;

      // Move projectile along curve
      const pt = atk.curve.getPoint(Math.min(atk.progress, 1));
      atk.projectile.position.copy(pt);
      atk.glow.position.copy(pt);
      atk.glow.scale.setScalar(1 + Math.sin(time * 20) * 0.3);

      // Fade trail with progress
      atk.trailMat.opacity = 0.5 * (1 - atk.progress * 0.5);

      // Partial trail drawing: show only the part behind the projectile
      const totalPts = 65;
      const visiblePts = Math.floor(atk.progress * totalPts);
      const positions = atk.trailGeom.attributes.position.array;
      // Fade will handle visual, keep full trail

      if (atk.progress >= 1) {
        atk.alive = false;
        // Impact!
        createImpact(atk.curve.getPoint(1));

        // Cleanup
        globeGroup.remove(atk.trail);
        globeGroup.remove(atk.projectile);
        globeGroup.remove(atk.glow);
        atk.trailGeom.dispose();
        atk.trailMat.dispose();
        atk.projMat.dispose();
        atk.glowMat.dispose();
        attacks.splice(i, 1);
      }
    }

    // Update impacts
    for (let i = impacts.length - 1; i >= 0; i--) {
      const imp = impacts[i];
      imp.scale += 0.08;
      imp.life -= 0.02;
      imp.ring.scale.set(imp.scale, imp.scale, imp.scale);
      imp.ringMat.opacity = Math.max(0, imp.life);
      if (imp.life <= 0) {
        globeGroup.remove(imp.ring);
        imp.ringMat.dispose();
        impacts.splice(i, 1);
      }
    }

    // Update depth-fade shader uniforms
    depthFadeUniforms.uCameraPos.value.copy(camera.position);

    // Render
    renderer.render(scene, camera);

    // --- HUD overlay ---
    const hctx = hudCanvas.getContext('2d');
    hctx.clearRect(0, 0, w, h);

    // Title
    hctx.font = '10px "Share Tech Mono"';
    hctx.fillStyle = 'rgba(0,255,255,0.7)';
    hctx.fillText('◆ GLOBAL THREAT MAP // 3D SIGINT', 6, 14);

    // Stats
    hctx.font = '9px "Share Tech Mono"';
    hctx.fillStyle = 'rgba(255,0,64,0.7)';
    hctx.fillText(`● ACTIVE ATTACKS: ${activeAttackCount}`, 6, h - 26);
    hctx.fillStyle = 'rgba(0,255,65,0.5)';
    hctx.fillText(`NODES: ${cities.length} | THREATS: ${cities.filter(c=>c.threat).length} | ROT: ${(globeGroup.rotation.y % (Math.PI*2)).toFixed(2)}rad`, 6, h - 12);

    // Project city labels to 2D
    cities.forEach(c => {
      const worldPos = c._pos.clone();
      worldPos.applyMatrix4(globeGroup.matrixWorld);

      // Check if on front side of globe (facing camera)
      const camDir = new THREE.Vector3();
      camera.getWorldDirection(camDir);
      const toCity = worldPos.clone().sub(camera.position).normalize();
      const dot = worldPos.clone().normalize().dot(camera.position.clone().normalize());

      if (dot > 0.1) { // front-facing
        const projected = worldPos.clone().project(camera);
        const sx = (projected.x * 0.5 + 0.5) * w;
        const sy = (-projected.y * 0.5 + 0.5) * h;

        if (sx > 0 && sx < w && sy > 0 && sy < h) {
          hctx.font = '8px "Share Tech Mono"';
          hctx.fillStyle = c.threat ? 'rgba(255,0,64,0.8)' : 'rgba(0,255,255,0.8)';
          hctx.fillText(c.name, sx + 6, sy - 4);

          // Tiny crosshair
          hctx.strokeStyle = c.threat ? 'rgba(255,0,64,0.4)' : 'rgba(0,255,65,0.4)';
          hctx.lineWidth = 0.5;
          hctx.beginPath();
          hctx.moveTo(sx - 4, sy); hctx.lineTo(sx + 4, sy);
          hctx.moveTo(sx, sy - 4); hctx.lineTo(sx, sy + 4);
          hctx.stroke();
        }
      }
    });

    // Corner decorations
    hctx.strokeStyle = 'rgba(0,255,65,0.2)';
    hctx.lineWidth = 1;
    const cs = 15;
    // Top-left
    hctx.beginPath(); hctx.moveTo(0, cs); hctx.lineTo(0, 0); hctx.lineTo(cs, 0); hctx.stroke();
    // Top-right
    hctx.beginPath(); hctx.moveTo(w-cs, 0); hctx.lineTo(w, 0); hctx.lineTo(w, cs); hctx.stroke();
    // Bottom-left
    hctx.beginPath(); hctx.moveTo(0, h-cs); hctx.lineTo(0, h); hctx.lineTo(cs, h); hctx.stroke();
    // Bottom-right
    hctx.beginPath(); hctx.moveTo(w-cs, h); hctx.lineTo(w, h); hctx.lineTo(w, h-cs); hctx.stroke();
  }

  animate();
}

// --- PROCESS LIST ---
function createProcessList(body) {
  const container = document.createElement('div');
  container.style.cssText = 'overflow-y:auto;height:100%;font-size:9px;';
  body.appendChild(container);

  const processes = [
    'quantum_decrypt', 'neural_scan', 'tor_relay', 'mesh_network', 'exploit_fw',
    'packet_sniff', 'brute_force', 'keylog_daemon', 'proxy_chain', 'dns_spoof',
    'ssl_strip', 'arp_poison', 'port_knock', 'entropy_gen', 'hash_crack',
    'payload_gen', 'rootkit_scan', 'vuln_assess', 'traffic_anal', 'crypto_mine',
    'darkweb_crawl', 'botnet_ctrl', 'zero_day_scan', 'firmware_dump', 'mem_inject',
  ];

  function update() {
    if (!document.body.contains(container)) return;
    let html = '<div style="color:var(--cyan);margin-bottom:4px;font-size:10px;">PID    CPU%  MEM%  STAT  COMMAND</div>';
    const shuffled = [...processes].sort(() => Math.random() - 0.5).slice(0, 18);
    shuffled.forEach(p => {
      const cpu = rand(0.1, 99.9).toFixed(1).padStart(5);
      const mem = rand(0.1, 30).toFixed(1).padStart(5);
      const stat = pick(['R', 'S', 'D', 'T', 'Z']);
      const pid = randInt(1000, 65535);
      const statColor = stat === 'R' ? 'var(--green)' : stat === 'Z' ? 'var(--red)' : 'var(--amber)';
      html += `<div style="cursor:pointer;" onmouseover="this.style.background='rgba(0,255,65,0.05)'" onmouseout="this.style.background=''">
        ${String(pid).padStart(5)}  ${cpu}  ${mem}  <span style="color:${statColor}">${stat}</span>     ${p}</div>`;
    });
    container.innerHTML = html;
    setTimeout(update, 1000);
  }
  update();
}

// --- CIRCULAR GAUGE ---
function createGauge(body, label, min, max) {
  const canvas = document.createElement('canvas');
  canvas.className = 'graph-canvas';
  body.appendChild(canvas);

  let value = rand(min, max);
  let targetValue = value;

  function draw() {
    if (!document.body.contains(canvas)) return;
    const w = canvas.parentElement.clientWidth;
    const h = canvas.parentElement.clientHeight;
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    const cx = w/2, cy = h/2;
    const r = Math.min(cx, cy) - 15;

    // Update target occasionally
    if (Math.random() > 0.98) targetValue = rand(min, max);
    value += (targetValue - value) * 0.05;

    const pct = (value - min) / (max - min);
    const startAngle = Math.PI * 0.75;
    const endAngle = Math.PI * 2.25;
    const currentAngle = startAngle + pct * (endAngle - startAngle);

    // Background arc
    ctx.beginPath();
    ctx.arc(cx, cy, r, startAngle, endAngle);
    ctx.strokeStyle = 'rgba(0,68,0,0.4)';
    ctx.lineWidth = 6;
    ctx.stroke();

    // Value arc
    const color = pct < 0.5 ? '#00ff41' : pct < 0.75 ? '#ffbf00' : '#ff0040';
    ctx.beginPath();
    ctx.arc(cx, cy, r, startAngle, currentAngle);
    ctx.strokeStyle = color;
    ctx.lineWidth = 6;
    ctx.lineCap = 'round';
    ctx.stroke();

    // Ticks
    for (let i = 0; i <= 10; i++) {
      const angle = startAngle + (i/10) * (endAngle - startAngle);
      const inner = r - 10;
      const outer = r + 3;
      ctx.beginPath();
      ctx.moveTo(cx + Math.cos(angle) * inner, cy + Math.sin(angle) * inner);
      ctx.lineTo(cx + Math.cos(angle) * outer, cy + Math.sin(angle) * outer);
      ctx.strokeStyle = 'rgba(0,255,65,0.3)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    // Needle
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(currentAngle) * (r - 15), cy + Math.sin(currentAngle) * (r - 15));
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Center dot
    ctx.beginPath();
    ctx.arc(cx, cy, 4, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();

    // Value text
    ctx.font = `${Math.max(14, r * 0.4)}px "Orbitron"`;
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.fillText(value.toFixed(1), cx, cy + r * 0.3);

    ctx.font = '9px "Share Tech Mono"';
    ctx.fillStyle = 'var(--cyan)';
    ctx.fillText(label, cx, cy + r * 0.55);
    ctx.textAlign = 'left';

    requestAnimationFrame(draw);
  }
  draw();
}

// --- INITIALIZE PANELS ---
function initAll() {
  const ws = $('#workspace');
  const ww = ws.offsetWidth;
  const wh = ws.offsetHeight;

  // Layout - tiled
  const layouts = [
    { id: 'p-terminal', title: '◆ TERMINAL // root@nexus', x: 0, y: 0, w: ww*0.3, h: wh*0.4, init: createTerminal, tabs: ['BASH', 'ZSH', 'PYTHON'] },
    { id: 'p-netgraph', title: '◆ NET TRAFFIC MONITOR', x: ww*0.3, y: 0, w: ww*0.35, h: wh*0.4, init: createNetworkGraph },
    { id: 'p-worldmap', title: '◆ GLOBAL THREAT MAP', x: ww*0.65, y: 0, w: ww*0.35, h: wh*0.4, init: createWorldMap },
    { id: 'p-logs', title: '◆ SYSTEM LOGS', x: 0, y: wh*0.4, w: ww*0.22, h: wh*0.3, init: createLogFeed },
    { id: 'p-eq', title: '◆ AUDIO INTERCEPT // EQ', x: ww*0.22, y: wh*0.4, w: ww*0.18, h: wh*0.15, init: createEQ },
    { id: 'p-waveform', title: '◆ SIGNAL ANALYSIS', x: ww*0.22, y: wh*0.55, w: ww*0.18, h: wh*0.15, init: createWaveform },
    { id: 'p-chart', title: '◆ TRAFFIC MONITOR', x: ww*0.4, y: wh*0.4, w: ww*0.3, h: wh*0.3, init: (b) => createLiveChart(b, {label1:'BANDWIDTH', label2:'PACKETS', label3:'DROPPED'}), tabs: ['REAL-TIME', 'HOUR', 'DAY'] },
    { id: 'p-video', title: '◆ SURVEILLANCE // CAM-7', x: ww*0.7, y: wh*0.4, w: ww*0.3, h: wh*0.3, init: (b) => createVideoFeed(b, 'SECTOR-7') },
    { id: 'p-hex', title: '◆ MEMORY DUMP // 0x7FFF0000', x: 0, y: wh*0.7, w: ww*0.22, h: wh*0.3, init: createHexDump },
    { id: 'p-datatable', title: '◆ PORT SCAN RESULTS', x: ww*0.22, y: wh*0.7, w: ww*0.25, h: wh*0.3, init: createDataTable },
    { id: 'p-radar', title: '◆ RADAR // SIGINT', x: ww*0.47, y: wh*0.7, w: ww*0.18, h: wh*0.3, init: createRadar },
    { id: 'p-donut', title: '◆ TRAFFIC CLASSIFICATION', x: ww*0.65, y: wh*0.7, w: ww*0.18, h: wh*0.15, init: createDonutChart },
    { id: 'p-spectrum', title: '◆ SPECTRUM WATERFALL', x: ww*0.65, y: wh*0.85, w: ww*0.18, h: wh*0.15, init: createSpectrum },
    { id: 'p-bars', title: '◆ PROTOCOL ANALYSIS', x: ww*0.83, y: wh*0.7, w: ww*0.17, h: wh*0.15, init: createBarChart },
    { id: 'p-procs', title: '◆ PROCESS MONITOR', x: ww*0.83, y: wh*0.85, w: ww*0.17, h: wh*0.15, init: createProcessList },
  ];

  layouts.forEach(l => {
    const p = createPanel(l);
    l.init(p.body);
  });

  initClock();
  initBottomBar();
  initContextMenu();
  initSelectionBox();
  initKeyboard();
  initMatrixSlider();
  startAutoNotifications();
}

function initMatrixSlider() {
  const densitySlider = document.getElementById('matrix-density');
  const densityVal = document.getElementById('matrix-density-val');
  const fontSlider = document.getElementById('matrix-fontscale');
  const fontVal = document.getElementById('matrix-fontscale-val');

  if (densitySlider) {
    densitySlider.addEventListener('input', () => {
      const v = parseInt(densitySlider.value);
      densityVal.textContent = v + '%';
      if (window.setMatrixDensity) window.setMatrixDensity(v / 100);
    });
  }
  if (fontSlider) {
    fontSlider.addEventListener('input', () => {
      const v = parseInt(fontSlider.value);
      fontVal.textContent = v + '%';
      if (window.setMatrixFontScale) window.setMatrixFontScale(v / 100);
    });
  }
}

// --- CLOCK ---
function initClock() {
  function updateClock() {
    const now = new Date();
    const utc = now.toUTCString().split(' ')[4];
    $('#clock').textContent = `${utc} UTC`;
    requestAnimationFrame(updateClock);
  }
  updateClock();

  // Uptime
  const start = Date.now();
  function updateUptime() {
    const elapsed = Math.floor((Date.now() - start) / 1000);
    const h = Math.floor(elapsed / 3600).toString().padStart(2, '0');
    const m = Math.floor((elapsed % 3600) / 60).toString().padStart(2, '0');
    const s = (elapsed % 60).toString().padStart(2, '0');
    $('#uptime').textContent = `${h}:${m}:${s}`;
    setTimeout(updateUptime, 1000);
  }
  updateUptime();
}

// --- BOTTOM BAR ---
function initBottomBar() {
  function update() {
    const cpu = rand(20, 95);
    const mem = rand(40, 85);
    $('#cpu-bar').style.width = cpu + '%';
    $('#cpu-bar').style.background = cpu > 80 ? 'var(--red)' : cpu > 60 ? 'var(--amber)' : 'var(--green)';
    $('#cpu-val').textContent = cpu.toFixed(0) + '%';
    $('#cpu-val').style.color = cpu > 80 ? 'var(--red)' : 'var(--green)';

    $('#mem-bar').style.width = mem + '%';
    $('#mem-bar').style.background = mem > 75 ? 'var(--amber)' : 'var(--green)';
    $('#mem-val').textContent = mem.toFixed(0) + '%';

    const up = rand(0.5, 50).toFixed(1);
    const down = rand(2, 200).toFixed(1);
    $('#net-val').textContent = `↑ ${up}MB/s ↓ ${down}MB/s`;
    $('#node-count').textContent = randInt(30, 80);
    $('#thread-count').textContent = randInt(128, 512);

    setTimeout(update, rand(500, 1500));
  }
  update();
}

// --- CONTEXT MENU ---
function initContextMenu() {
  const menu = $('#context-menu');

  document.addEventListener('contextmenu', e => {
    e.preventDefault();
    menu.style.display = 'block';
    menu.style.left = e.clientX + 'px';
    menu.style.top = e.clientY + 'px';
  });

  document.addEventListener('click', () => {
    menu.style.display = 'none';
  });
}

// --- SELECTION BOX ---
function initSelectionBox() {
  const box = $('#selection-box');
  let isSelecting = false, startX, startY;

  document.addEventListener('mousedown', e => {
    if (e.button !== 0) return;
    if (e.target.closest('.panel') || e.target.closest('#top-bar') || e.target.closest('#bottom-bar') || e.target.closest('.context-menu')) return;
    isSelecting = true;
    startX = e.clientX;
    startY = e.clientY;
    box.style.left = startX + 'px';
    box.style.top = startY + 'px';
    box.style.width = '0px';
    box.style.height = '0px';
    box.style.display = 'block';
  });

  document.addEventListener('mousemove', e => {
    if (!isSelecting) return;
    const x = Math.min(e.clientX, startX);
    const y = Math.min(e.clientY, startY);
    const w = Math.abs(e.clientX - startX);
    const h = Math.abs(e.clientY - startY);
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.style.width = w + 'px';
    box.style.height = h + 'px';
  });

  document.addEventListener('mouseup', () => {
    if (isSelecting) {
      const w = parseInt(box.style.width);
      const h = parseInt(box.style.height);
      if (w > 20 && h > 20) {
        notify(`Selection area: ${w}x${h}px — ${randInt(1,12)} targets identified`);
      }
    }
    isSelecting = false;
    box.style.display = 'none';
  });
}

// --- KEYBOARD SHORTCUTS ---
function closeAllPanels() {
  $$('.panel').forEach(p => {
    p.style.transition = 'opacity 0.3s, transform 0.3s';
    p.style.opacity = '0';
    p.style.transform = 'scale(0.9)';
    setTimeout(() => p.remove(), 300);
  });
  panels = [];
  notify('All panels closed — press [L] to restore', 'warn');
}

const HOTKEYS = [
  { key: '?',      label: '?',      desc: 'Toggle this help overlay' },
  { key: 'g',      label: 'G',      desc: 'Trigger glitch effect' },
  { key: 'n',      label: 'N',      desc: 'Toggle night vision mode' },
  { key: 't',      label: 'T',      desc: 'Spawn new floating terminal' },
  { key: 'h',      label: 'H',      desc: 'Hack The Gibson (full sequence)' },
  { key: 'r',      label: 'R',      desc: 'Run network scan' },
  { key: 'q',      label: 'Q',      desc: 'Close all panels (clear view)' },
  { key: 'l',      label: 'L',      desc: 'Restore default layout' },
  { key: 'Escape', label: 'ESC',    desc: 'Defocus all panels' },
];

let helpOverlayVisible = false;
let helpOverlayEl = null;

function toggleHelpOverlay() {
  if (helpOverlayEl) {
    helpOverlayEl.remove();
    helpOverlayEl = null;
    helpOverlayVisible = false;
    return;
  }
  helpOverlayVisible = true;
  helpOverlayEl = document.createElement('div');
  helpOverlayEl.style.cssText = `
    position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
    background:rgba(0,10,0,0.95); border:1px solid var(--green);
    padding:24px 32px; z-index:100001; min-width:360px;
    box-shadow: 0 0 40px rgba(0,255,65,0.3), 0 0 80px rgba(0,255,65,0.1);
    font-family:'Share Tech Mono',monospace;
  `;
  let html = `
    <div style="font-family:'Orbitron',sans-serif;font-size:14px;color:#00ffff;letter-spacing:3px;margin-bottom:16px;text-align:center;text-shadow:0 0 10px rgba(0,255,255,0.5);">
      ◆ KEYBOARD SHORTCUTS ◆
    </div>
    <div style="display:flex;flex-direction:column;gap:6px;">
  `;
  HOTKEYS.forEach(h => {
    html += `
      <div style="display:flex;align-items:center;gap:12px;font-size:12px;">
        <span style="
          display:inline-block;min-width:48px;text-align:center;
          padding:3px 8px;background:rgba(0,255,65,0.1);border:1px solid rgba(0,255,65,0.3);
          color:#00ff41;font-size:11px;letter-spacing:1px;
        ">${h.label}</span>
        <span style="color:#00ff41;opacity:0.8;">${h.desc}</span>
      </div>
    `;
  });
  html += `
    </div>
    <div style="margin-top:16px;text-align:center;font-size:9px;color:#004400;">
      Press <span style="color:#00ffff;">?</span> to close  ·  Right-click for context menu
    </div>
  `;
  helpOverlayEl.innerHTML = html;
  document.body.appendChild(helpOverlayEl);
}

function initKeyboard() {
  document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT') return;
    if (e.key === '?') toggleHelpOverlay();
    if (e.key === 'g') triggerGlitch();
    if (e.key === 'n') toggleNightVision();
    if (e.key === 't') spawnFloatingTerminal();
    if (e.key === 'h') hackTheGibson();
    if (e.key === 'r') runNetScan();
    if (e.key === 'q') closeAllPanels();
    if (e.key === 'l') resetLayout();
    if (e.key === 'Escape') {
      if (helpOverlayVisible) { toggleHelpOverlay(); return; }
      $$('.panel').forEach(p => p.classList.remove('focused'));
      notify('All panels defocused');
    }
  });
}

// --- NOTIFICATIONS ---
function notify(msg, type) {
  const el = document.createElement('div');
  el.className = 'notification' + (type === 'error' ? ' error' : type === 'warn' ? ' warn' : '');
  el.textContent = `[${timestamp()}] ${msg}`;

  // Stack notifications
  const existing = $$('.notification');
  el.style.top = (42 + existing.length * 36) + 'px';

  document.body.appendChild(el);
  setTimeout(() => el.remove(), 4000);
}

function startAutoNotifications() {
  const msgs = [
    () => `Encrypted tunnel ${randInt(1,99)} renegotiated`,
    () => `New node joined mesh: ${ipAddr()}`,
    () => `Blocked scan from ${ipAddr()}`,
    () => `Firewall rule updated: DROP ${ipAddr()}`,
    () => `Certificate pinning verified for *.${pick(['shadow','dark','ghost'])}.net`,
    () => `Tor circuit rebuilt: ${randInt(3,7)} hops`,
    () => `Quantum key exchange completed (${randInt(256,4096)} bits)`,
    () => `Intelligence feed updated: ${randInt(10,500)} new IOCs`,
    () => `Anomaly detected on port ${pick([22,80,443,8080])}`,
    () => `Decryption complete: ${randInt(1,50)}MB payload`,
  ];

  function autoNotify() {
    if (Math.random() > 0.6) {
      notify(pick(msgs)(), Math.random() > 0.85 ? 'warn' : undefined);
    }
    setTimeout(autoNotify, rand(5000, 15000));
  }
  setTimeout(autoNotify, 5000);
}

// --- SPECIAL ACTIONS ---
function triggerGlitch() {
  const container = $('#main-container');
  container.style.animation = 'none';
  void container.offsetHeight;
  container.style.animation = 'glitch 0.3s ease 3';
  setTimeout(() => { container.style.animation = 'flicker 4s infinite'; }, 1000);
  notify('GLITCH DETECTED — Recovering...', 'error');
}

function toggleNightVision() {
  document.body.style.filter = document.body.style.filter === 'hue-rotate(60deg) brightness(1.2)' ? '' : 'hue-rotate(60deg) brightness(1.2)';
  notify('Night vision ' + (document.body.style.filter ? 'ENABLED' : 'DISABLED'));
}

// --- MENU PANEL SPAWNERS ---
// Generic: spawn a hacker panel with streaming nonsense content
function spawnHackPanel(title, contentGen, opts = {}) {
  const w = opts.w || randInt(380, 520);
  const h = opts.h || randInt(240, 340);
  const p = createPanel({
    title: `◆ ${title}`,
    x: randInt(40, Math.max(60, window.innerWidth - w - 60)),
    y: randInt(40, Math.max(60, window.innerHeight - h - 100)),
    w, h,
  });
  p.el.classList.add('focused');
  p.el.style.zIndex = ++panelZIndex;

  const content = document.createElement('div');
  content.style.cssText = 'font-size:9px;line-height:1.6;color:var(--green);overflow-y:auto;height:100%;white-space:pre;font-family:"Share Tech Mono",monospace;';
  p.body.appendChild(content);

  let lines = 0;
  const maxLines = opts.maxLines || 80;
  const speed = opts.speed || 120;
  const iv = setInterval(() => {
    if (!document.body.contains(p.el) || lines >= maxLines) { clearInterval(iv); return; }
    const line = contentGen(lines);
    content.innerHTML += line + '\n';
    content.scrollTop = content.scrollHeight;
    lines++;
  }, speed);

  notify(title);
  return p;
}

// --- FILE menu ---
function openImportDataset() {
  const files = ['synapse_dump.ndb','cortex_map_v7.bin','neural_weights_2049.h5','axon_trace.pcap','memory_sector_0xFF.raw','quantum_state.qbt','genome_seq.fasta','dark_pool_tx.enc'];
  const statuses = ['<span style="color:#00ffff">LOADED</span>','<span style="color:#00ff41">PARSED</span>','<span style="color:#ffbf00">INDEXING</span>','<span style="color:#ff0040">CHECKSUM ERR</span>','<span style="color:#00ff41">OK</span>'];
  spawnHackPanel('DATASET IMPORT // NEURAL-NET v4.2', (i) => {
    if (i === 0) return '<span style="color:#00ffff">NEURAL DATASET IMPORTER v4.2.1</span>';
    if (i === 1) return 'Source: <span style="color:#ffbf00">/dev/brain/corpus_callosum</span>';
    if (i === 2) return '────────────────────────────────────';
    const f = files[randInt(0, files.length)];
    const sz = (Math.random() * 900 + 10).toFixed(1);
    const st = statuses[randInt(0, statuses.length)];
    return `[${timestamp()}] ${f.padEnd(28)} ${(sz + 'MB').padStart(9)} ${st}`;
  });
}

function openExportPayload() {
  spawnHackPanel('PAYLOAD EXPORT // AES-256-GCM', (i) => {
    if (i === 0) return '<span style="color:#ff0040">▓▓▓ ENCRYPTED PAYLOAD BUILDER ▓▓▓</span>';
    if (i === 1) return 'Cipher: AES-256-GCM | IV: ' + Array.from({length:12},()=>hex()).join('');
    if (i === 2) return 'HMAC:   SHA-512 | Salt: ' + Array.from({length:8},()=>hex()).join('');
    if (i === 3) return '────────────────────────────────────';
    const block = Array.from({length:8},()=>hexWord()).join(' ');
    const pct = Math.min(99, (i * 1.3)).toFixed(1);
    return `BLK ${(i-3).toString().padStart(4,'0')}  ${block}  <span style="color:#00ffff">${pct}%</span>`;
  }, { speed: 60 });
}

function openNewTunnel() {
  const protos = ['SSH','WireGuard','IPSec','OpenVPN','SOCKS5','Tor','I2P','Nebula'];
  const hops = [];
  for (let i = 0; i < randInt(4,8); i++) hops.push(ipAddr());
  spawnHackPanel('QUANTUM TUNNEL // MULTI-HOP', (i) => {
    if (i === 0) return '<span style="color:#bf00ff">◆ QUANTUM TUNNEL NEGOTIATION ◆</span>';
    if (i === 1) return 'Protocol: ' + pick(protos) + ' over ' + pick(protos);
    if (i === 2) return 'Hops: ' + hops.length + ' | Latency budget: ' + randInt(20,200) + 'ms';
    if (i === 3) return '────────────────────────────────────';
    if (i < 3 + hops.length) {
      const h = i - 3;
      return `HOP ${h+1}  ${hops[h].padEnd(16)} <span style="color:#00ffff">${pick(protos).padEnd(10)}</span> <span style="color:#00ff41">ESTABLISHED</span>  ${randInt(5,80)}ms`;
    }
    const ev = pick(['keepalive','rekey','data','heartbeat','ratchet','entropy-refill']);
    return `[${timestamp()}] tunnel.${ev}  seq=${randInt(1000,99999)}  bytes=${randInt(64,9000)}  <span style="color:#00ff41">OK</span>`;
  });
}

function openArchiveSession() {
  spawnHackPanel('SESSION ARCHIVE // /dev/null', (i) => {
    if (i === 0) return '<span style="color:#ffbf00">SESSION ARCHIVAL SERVICE v2.0</span>';
    if (i === 1) return 'Destination: <span style="color:#ff0040">/dev/null</span> (maximum security)';
    if (i === 2) return '────────────────────────────────────';
    const items = ['keystrokes','mouse_events','screen_caps','packet_log','audio_buf','clipboard','env_vars','proc_tree','mem_pages','gpu_state'];
    const item = pick(items);
    const sz = (Math.random() * 50 + 0.1).toFixed(2);
    return `[${timestamp()}] archiving ${item.padEnd(14)} ${(sz+'MB').padStart(9)} → <span style="color:#ff0040">/dev/null</span> <span style="color:#00ff41">SHREDDED</span>`;
  });
}

// --- SCAN menu ---
function openVulnScanner() {
  const cves = ['CVE-2024-31337','CVE-2025-0001','CVE-2023-44271','CVE-2024-21762','CVE-2025-13370','CVE-2024-9999','CVE-2023-XXXX'];
  const sevs = ['<span style="color:#ff0040">CRITICAL</span>','<span style="color:#ff0040">HIGH</span>','<span style="color:#ffbf00">MEDIUM</span>','<span style="color:#00ff41">LOW</span>','<span style="color:#00ffff">INFO</span>'];
  const services = ['OpenSSH 8.9','nginx 1.21','Apache 2.4.51','MySQL 8.0','Redis 7.0','Docker 24.0','kubelet 1.28','etcd 3.5','Postfix 3.7'];
  spawnHackPanel('VULN SCANNER // NESSUS++', (i) => {
    if (i === 0) return '<span style="color:#ff0040">◆ VULNERABILITY SCANNER v6.6.6 ◆</span>';
    if (i === 1) return 'Target: ' + ipAddr() + '/24 | Plugins: 98,412 loaded';
    if (i === 2) return '────────────────────────────────────';
    const svc = pick(services);
    const sev = sevs[randInt(0, sevs.length)];
    const cve = cves[randInt(0, cves.length)];
    const port = pick([22,80,443,3306,5432,6379,8080,8443,9200,27017]);
    return `[${timestamp()}] :${(port+'').padEnd(5)} ${svc.padEnd(18)} ${cve}  ${sev}`;
  }, { speed: 200 });
}

function openPortEnum() {
  let port = 0;
  spawnHackPanel('PORT ENUM // 0-65535', (i) => {
    if (i === 0) return '<span style="color:#00ffff">PORT ENUMERATION ENGINE</span>';
    if (i === 1) return 'Target: ' + ipAddr() + ' | Mode: SYN stealth scan';
    if (i === 2) return '────────────────────────────────────';
    const batch = randInt(80, 400);
    port += batch;
    if (port > 65535) port = 65535;
    const found = Math.random() > 0.7;
    if (found) {
      const p = pick([21,22,25,53,80,110,143,443,993,995,3306,3389,5432,5900,6379,8080,8443,9200,27017]);
      const state = pick(['<span style="color:#00ff41">OPEN</span>','<span style="color:#ffbf00">FILTERED</span>']);
      const svc = pick(['ftp','ssh','smtp','dns','http','pop3','imap','https','mysql','rdp','postgres','vnc','redis','proxy']);
      return `PORT ${(p+'').padStart(5)} ${state}  ${svc.padEnd(10)} banner="${hex()}${hex()}${hex()}"`;
    }
    return `<span style="color:#666">scanning ${port-batch}..${Math.min(port,65535)} (${Math.min(100,(port/655.35).toFixed(1))}%)</span>`;
  }, { speed: 80 });
}

function openDNSRecon() {
  const types = ['A','AAAA','MX','NS','CNAME','TXT','SOA','PTR','SRV','DNSKEY'];
  const domains = ['shadow.corp','n3xus.io','darkpool.net','gibson.hack','z3r0.day','flux.mesh','ghost.onion','void.link'];
  spawnHackPanel('DNS RECON // DEEP ENUM', (i) => {
    if (i === 0) return '<span style="color:#00ffff">DNS RECONNAISSANCE MODULE</span>';
    if (i === 1) return 'Resolvers: 8.8.8.8, 1.1.1.1, 9.9.9.9 | DNSSEC: verify';
    if (i === 2) return '────────────────────────────────────';
    const dom = pick(domains);
    const sub = pick(['','www.','api.','mail.','ns1.','vpn.','git.','ci.','dev.','staging.','prod.','db.','cache.','auth.']);
    const type = pick(types);
    const ttl = randInt(60, 86400);
    let val = ipAddr();
    if (type === 'MX') val = `${randInt(1,50)} mail.${dom}`;
    if (type === 'TXT') val = `"v=spf1 include:${dom} ~all"`;
    if (type === 'NS') val = `ns${randInt(1,4)}.${dom}`;
    if (type === 'CNAME') val = `${pick(['cdn','lb','proxy'])}.${dom}`;
    return `${(sub+dom).padEnd(28)} ${type.padEnd(6)} TTL:${(ttl+'').padEnd(6)} ${val}`;
  }, { speed: 150 });
}

// --- TOOLS menu ---
function openPacketSniffer() {
  const protos = ['TCP','UDP','ICMP','DNS','TLS','HTTP','SSH','ARP','MQTT','gRPC'];
  const flags = ['SYN','ACK','FIN','PSH','RST','SYN-ACK','FIN-ACK','URG'];
  spawnHackPanel('PACKET SNIFFER // eth0 PROMISC', (i) => {
    if (i === 0) return '<span style="color:#ff0040">◆ LIVE PACKET CAPTURE — eth0 ◆</span>';
    if (i === 1) return 'Mode: PROMISCUOUS | Filter: none | Snap: 65535';
    if (i === 2) return '────────────────────────────────────';
    const proto = pick(protos);
    const src = ipAddr() + ':' + randInt(1024,65535);
    const dst = ipAddr() + ':' + pick([22,80,443,8080,3306,53,5432]);
    const sz = randInt(40, 1500);
    const flag = proto === 'TCP' ? ' [' + pick(flags) + ']' : '';
    return `<span style="color:#666">${(i-2).toString().padStart(5)}</span> ${proto.padEnd(5)} ${src.padEnd(22)} → ${dst.padEnd(22)} ${(sz+'B').padStart(6)}${flag}`;
  }, { speed: 50, maxLines: 200 });
}

function openHashCracker() {
  const algos = ['MD5','SHA-1','SHA-256','SHA-512','bcrypt','scrypt','Argon2','NTLM','WPA2-PBKDF2'];
  const wordlists = ['rockyou.txt','darkweb2017.lst','hashcat-rules.rl','crackstation-human.txt','probable-v2.txt'];
  spawnHackPanel('HASH CRACKER // GPU MODE', (i) => {
    if (i === 0) return '<span style="color:#ffbf00">◆ DISTRIBUTED HASH CRACKER ◆</span>';
    if (i === 1) return 'Algorithm: ' + pick(algos) + ' | Wordlist: ' + pick(wordlists);
    if (i === 2) return 'GPUs: 4x RTX 5090 | Hashrate: ' + (Math.random()*800+200).toFixed(1) + ' GH/s';
    if (i === 3) return '────────────────────────────────────';
    const hash = Array.from({length:16},()=>hex()).join('');
    const cracked = Math.random() > 0.6;
    if (cracked) {
      const words = ['password123','admin','letmein','hunter2','correcthorsebatterystaple','guest','root','123456','qwerty','dragon'];
      return `${hash}  <span style="color:#00ff41">CRACKED → "${pick(words)}"</span>`;
    }
    return `${hash}  <span style="color:#666">testing... ${(Math.random()*100).toFixed(1)}%</span>`;
  }, { speed: 100 });
}

function openDecompiler() {
  const regs = ['rax','rbx','rcx','rdx','rsi','rdi','rsp','rbp','r8','r9','r10','r11','r12','r13','r14','r15'];
  const ops = ['mov','push','pop','call','jmp','je','jne','cmp','test','lea','xor','add','sub','imul','shr','shl','ret','nop','int3','syscall'];
  spawnHackPanel('DECOMPILER // x86_64', (i) => {
    if (i === 0) return '<span style="color:#bf00ff">◆ BINARY DECOMPILER v3.1 ◆</span>';
    if (i === 1) return 'Binary: /usr/bin/target | Format: ELF64 | Stripped: yes';
    if (i === 2) return '────────────────────────────────────';
    const addr = (0x400000 + i * randInt(1,8)).toString(16);
    const op = pick(ops);
    let operands = '';
    if (op === 'ret' || op === 'nop' || op === 'syscall' || op === 'int3') {
      operands = '';
    } else if (op === 'push' || op === 'pop' || op === 'call' || op === 'jmp' || op === 'je' || op === 'jne') {
      operands = op.startsWith('j') || op === 'call' ? '0x' + (0x400000 + randInt(0,0x10000)).toString(16) : pick(regs);
    } else {
      operands = pick(regs) + ', ' + (Math.random()>0.5 ? pick(regs) : '0x'+hex()+hex());
    }
    const bytes = Array.from({length:randInt(1,6)},()=>hex()).join(' ');
    return `<span style="color:#666">0x${addr}</span>  ${bytes.padEnd(18)} <span style="color:#00ffff">${op.padEnd(8)}</span> ${operands}`;
  }, { speed: 40, maxLines: 200 });
}

// --- VIEW menu ---
function openWireframe() {
  notify('Wireframe overlay active');
  // Toggle a CSS wireframe effect on all panels
  const existing = document.getElementById('wireframe-style');
  if (existing) { existing.remove(); notify('Wireframe DISABLED'); return; }
  const style = document.createElement('style');
  style.id = 'wireframe-style';
  style.textContent = `.panel { background: rgba(0,20,0,0.3) !important; } .panel-body { border: 1px dashed rgba(0,255,65,0.2) !important; }`;
  document.head.appendChild(style);
}

// --- HACK menu ---
function openBypassAuth() {
  const methods = ['Kerberoast','Golden Ticket','Pass-the-Hash','LDAP Injection','OAuth Redirect','JWT None-alg','SAML Forgery','Cookie Replay'];
  spawnHackPanel('AUTH BYPASS // PRIV ESCALATION', (i) => {
    if (i === 0) return '<span style="color:#ff0040">▓▓▓ AUTHENTICATION BYPASS ENGINE ▓▓▓</span>';
    if (i === 1) return 'Target: ' + ipAddr() + ' | Method: ' + pick(methods);
    if (i === 2) return '────────────────────────────────────';
    const actions = [
      'Enumerating users... ' + randInt(50,500) + ' found',
      'Extracting ticket: krbtgt/' + pick(['CORP','DOMAIN','ADMIN','DC01']) + ' <span style="color:#ffbf00">OK</span>',
      'Forging token: <span style="color:#00ffff">' + Array.from({length:8},()=>hex()).join('') + '</span>',
      'Testing creds: admin/' + pick(['P@ssw0rd','Summer2025!','admin','changeme','Welcome1']) + ' <span style="color:#00ff41">VALID</span>',
      'Escalating: user → <span style="color:#ff0040">root</span>',
      'Dumping SAM: ' + Array.from({length:16},()=>hex()).join(''),
      'Lateral move → ' + ipAddr() + ' <span style="color:#00ff41">SUCCESS</span>',
      'Installing backdoor on port ' + randInt(40000,65000) + '...',
      '<span style="color:#ffbf00">ALERT: Honeypot detected at ' + ipAddr() + ' — evading</span>',
      'Session established: <span style="color:#00ff41">NT AUTHORITY\\SYSTEM</span>',
    ];
    return `[${timestamp()}] ${pick(actions)}`;
  }, { speed: 180 });
}

function openInjectPayload() {
  spawnHackPanel('PAYLOAD INJECTION // SHELLCODE', (i) => {
    if (i === 0) return '<span style="color:#ff0040">◆ SHELLCODE INJECTION ENGINE ◆</span>';
    if (i === 1) return 'Target PID: ' + randInt(1000,65000) + ' | Arch: x86_64 | ASLR: bypass';
    if (i === 2) return '────────────────────────────────────';
    if (i < 6) {
      const stages = ['Allocating RWX region...','Writing stage-1 loader...','Resolving kernel32.dll...','Patching AMSI...','Injecting shellcode...'];
      if (i - 3 < stages.length) return `<span style="color:#ffbf00">[STAGE ${i-2}]</span> ${stages[i-3]} <span style="color:#00ff41">OK</span>`;
    }
    // Show shellcode hex dump
    const addr = (0x7ff000000000 + (i-6) * 16);
    const bytes = Array.from({length:16},()=>hex()).join(' ');
    return `<span style="color:#666">${addr.toString(16).padStart(12,'0')}</span>  ${bytes}`;
  }, { speed: 50, maxLines: 150 });
}

function openDropFirewall() {
  const chains = ['INPUT','OUTPUT','FORWARD','PREROUTING','POSTROUTING','DOCKER','KUBE-PROXY'];
  const actions = ['ACCEPT','DROP','REJECT','LOG','MASQUERADE','DNAT','SNAT','REDIRECT'];
  spawnHackPanel('FIREWALL CTRL // iptables', (i) => {
    if (i === 0) return '<span style="color:#ff0040">◆ FIREWALL RULE MANIPULATION ◆</span>';
    if (i === 1) return '# iptables -L -n -v --line-numbers';
    if (i === 2) return '────────────────────────────────────';
    const chain = pick(chains);
    const action = pick(actions);
    const src = Math.random() > 0.3 ? ipAddr()+'/'+pick([8,16,24,32]) : '0.0.0.0/0';
    const dst = Math.random() > 0.3 ? ipAddr()+'/'+pick([8,16,24,32]) : '0.0.0.0/0';
    const proto = pick(['tcp','udp','icmp','all']);
    const port = proto !== 'icmp' ? ' dpt:'+pick([22,80,443,3306,8080]) : '';
    const pkts = randInt(0, 999999);
    return `<span style="color:#ffbf00">${chain.padEnd(14)}</span> ${action.padEnd(12)} ${proto.padEnd(5)} ${src.padEnd(20)} ${dst.padEnd(20)}${port} <span style="color:#666">${pkts} pkts</span>`;
  }, { speed: 100 });
}

function openSignalTuner() {
  const w = 440, h = 380;
  const p = createPanel({
    title: '◆ SIGINT BURST CONFIGURATOR // rf0',
    x: randInt(40, Math.max(60, window.innerWidth - w - 60)),
    y: randInt(40, Math.max(60, window.innerHeight - h - 100)),
    w, h,
  });
  p.el.classList.add('focused');
  p.el.style.zIndex = ++panelZIndex;

  const sliderCSS = '-webkit-appearance:none;width:100%;height:3px;border-radius:2px;outline:none;cursor:pointer;background:linear-gradient(90deg,#001a00,#00ff41);margin:4px 0 0 0;';

  const params = [
    { id:'bf-pktfrag', label:'PKT FRAGMENT WINDOW', unit:'ms', obj:'burstNoteDur',
      min:0.005, max:0.3, valMin:'min', valMax:'max', toDisplay:v=>(v*1000).toFixed(1), fromSlider:(v)=>v },
    { id:'bf-cipherblk', label:'CIPHER BLOCK DEPTH', unit:'', obj:'burstNoteCount',
      min:1, max:12, valMin:'min', valMax:'max', toDisplay:v=>Math.round(v), fromSlider:(v)=>Math.round(v), isInt:true },
    { id:'bf-acklatency', label:'ACK LATENCY OFFSET', unit:'ms', obj:'burstNoteGap',
      min:0.002, max:0.15, valMin:'min', valMax:'max', toDisplay:v=>(v*1000).toFixed(1), fromSlider:(v)=>v },
    { id:'bf-syncinterval', label:'SYNC INTERVAL', unit:'ms', obj:'burstInterval',
      min:200, max:15000, valMin:'min', valMax:'max', toDisplay:v=>Math.round(v), fromSlider:(v)=>v },
  ];

  let html = `<div style="padding:8px 12px;font-family:'Share Tech Mono',monospace;color:var(--green);font-size:9px;line-height:1.5;overflow-y:auto;height:100%;">`;
  html += `<div style="color:#ff0040;font-size:10px;letter-spacing:2px;margin-bottom:4px;">◆ RF SIGNAL INTELLIGENCE TOOLKIT v4.2.1</div>`;
  html += `<div style="color:#666;margin-bottom:6px;">Module: BURST_PATTERN_CONFIGURATOR // Classification: TS//SCI</div>`;
  html += `<div style="border:1px solid #003300;padding:6px 8px;margin-bottom:8px;background:rgba(0,20,0,0.4);">`;
  html += `<span style="color:#00ffff;">STATUS:</span> <span style="color:#00ff41;">ACTIVE</span> — Intercepting burst transmissions on RF0<br>`;
  html += `<span style="color:#00ffff;">TARGET:</span> <span style="color:#ffbf00;">UNKNOWN EMITTER</span> // Band: 600Hz ± 6 semitones</div>`;

  params.forEach((pm, idx) => {
    const objRef = pm.obj;
    const curMin = window[objRef].min;
    const curMax = window[objRef].max;
    // Two sliders per param: min and max of the randomization range
    html += `<div style="border-bottom:1px solid #001a00;padding:6px 0;${idx===0?'':''}">`;
    html += `<div style="color:#00ffff;letter-spacing:1px;font-size:10px;margin-bottom:2px;">${pm.label}</div>`;
    // Min slider
    html += `<div style="display:flex;align-items:center;gap:6px;">`;
    html += `<span style="color:#666;min-width:32px;font-size:8px;">FLOOR</span>`;
    html += `<input type="range" id="${pm.id}-min" min="${pm.min}" max="${pm.max}" value="${curMin}" step="${pm.isInt ? 1 : (pm.max-pm.min)/200}" style="${sliderCSS}">`;
    html += `<span id="${pm.id}-min-val" style="color:#00ff41;min-width:44px;text-align:right;font-size:9px;">${pm.toDisplay(curMin)}${pm.unit}</span>`;
    html += `</div>`;
    // Max slider
    html += `<div style="display:flex;align-items:center;gap:6px;margin-top:2px;">`;
    html += `<span style="color:#666;min-width:32px;font-size:8px;">CEIL</span>`;
    html += `<input type="range" id="${pm.id}-max" min="${pm.min}" max="${pm.max}" value="${curMax}" step="${pm.isInt ? 1 : (pm.max-pm.min)/200}" style="${sliderCSS}">`;
    html += `<span id="${pm.id}-max-val" style="color:#00ff41;min-width:44px;text-align:right;font-size:9px;">${pm.toDisplay(curMax)}${pm.unit}</span>`;
    html += `</div>`;
    html += `</div>`;
  });

  // Visual readout section
  html += `<div style="margin-top:8px;border:1px solid #003300;padding:6px 8px;background:rgba(0,20,0,0.3);">`;
  html += `<div style="color:#ffbf00;font-size:8px;letter-spacing:1px;margin-bottom:4px;">BURST WAVEFORM ANALYSIS</div>`;
  html += `<canvas id="bf-waveform" width="390" height="40" style="width:100%;height:40px;border:1px solid #002200;background:#000800;"></canvas>`;
  html += `</div>`;

  html += `<div style="margin-top:6px;color:#333;font-size:7px;text-align:center;">AUTHORIZED PERSONNEL ONLY — SIGINT DIVISION — REF: NSA/CSS-PM-2024-0451</div>`;
  html += `</div>`;

  p.body.innerHTML = html;

  // Wire up sliders
  params.forEach(pm => {
    const objRef = pm.obj;
    const minSlider = p.body.querySelector(`#${pm.id}-min`);
    const maxSlider = p.body.querySelector(`#${pm.id}-max`);
    const minVal = p.body.querySelector(`#${pm.id}-min-val`);
    const maxVal = p.body.querySelector(`#${pm.id}-max-val`);

    const update = () => {
      let lo = pm.fromSlider(parseFloat(minSlider.value));
      let hi = pm.fromSlider(parseFloat(maxSlider.value));
      if (lo > hi) { const tmp = lo; lo = hi; hi = tmp; }
      window[objRef].min = lo;
      window[objRef].max = hi;
      minVal.textContent = pm.toDisplay(lo) + pm.unit;
      maxVal.textContent = pm.toDisplay(hi) + pm.unit;
    };

    minSlider.addEventListener('input', update);
    maxSlider.addEventListener('input', update);
    // Prevent panel drag when using sliders
    [minSlider, maxSlider].forEach(s => {
      s.addEventListener('mousedown', e => e.stopPropagation());
      s.addEventListener('touchstart', e => e.stopPropagation());
    });
  });

  // Waveform visualizer
  const wfCanvas = p.body.querySelector('#bf-waveform');
  if (wfCanvas) {
    const wfCtx = wfCanvas.getContext('2d');
    let wfFrame = 0;
    const drawWaveform = () => {
      if (!document.body.contains(p.el)) return;
      wfCtx.fillStyle = 'rgba(0,8,0,0.3)';
      wfCtx.fillRect(0, 0, 390, 40);
      wfCtx.strokeStyle = '#00ff41';
      wfCtx.lineWidth = 1;
      wfCtx.beginPath();
      for (let x = 0; x < 390; x++) {
        const noteW = burstNoteDur.min * 400;
        const gapW = burstNoteGap.min * 400;
        const period = noteW + gapW;
        const inNote = (x % Math.max(1, period)) < noteW;
        const freq = 0.1 + (burstNoteCount.max - burstNoteCount.min) * 0.05;
        const y = inNote
          ? 20 + Math.sin((x + wfFrame) * freq) * 14 * (0.5 + Math.sin(x * 0.02 + wfFrame * 0.1) * 0.5)
          : 20 + (Math.random() - 0.5) * 3;
        x === 0 ? wfCtx.moveTo(x, y) : wfCtx.lineTo(x, y);
      }
      wfCtx.stroke();
      // Scan line
      const scanX = (wfFrame * 2) % 390;
      wfCtx.strokeStyle = 'rgba(0,255,65,0.3)';
      wfCtx.beginPath();
      wfCtx.moveTo(scanX, 0);
      wfCtx.lineTo(scanX, 40);
      wfCtx.stroke();
      wfFrame++;
      requestAnimationFrame(drawWaveform);
    };
    drawWaveform();
  }

  notify('SIGINT BURST CONFIGURATOR');
}

function playVictoryMelody() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;

  // Bloopy triumph melody — ascending arpeggiated phrase with a flourish
  // Notes as semitones from C5 (523.25 Hz)
  const c5 = 523.25;
  const melody = [
    // phrase 1: ascending major arpeggio
    { st: 0,  dur: 0.10, delay: 0.00 },  // C
    { st: 4,  dur: 0.10, delay: 0.12 },  // E
    { st: 7,  dur: 0.10, delay: 0.24 },  // G
    { st: 12, dur: 0.15, delay: 0.36 },  // C (octave)
    // phrase 2: quick descending run
    { st: 11, dur: 0.06, delay: 0.56 },  // B
    { st: 9,  dur: 0.06, delay: 0.63 },  // A
    { st: 7,  dur: 0.06, delay: 0.70 },  // G
    // phrase 3: triumphant finish — leap up
    { st: 12, dur: 0.10, delay: 0.82 },  // C
    { st: 16, dur: 0.10, delay: 0.94 },  // E (high)
    { st: 19, dur: 0.25, delay: 1.06 },  // G (high) — held
    // final sparkle
    { st: 24, dur: 0.08, delay: 1.36 },  // C (2 octaves up)
    { st: 19, dur: 0.08, delay: 1.46 },  // G
    { st: 24, dur: 0.35, delay: 1.56 },  // C (2 octaves up) — ring out
  ];

  // Master gain for the melody
  const masterGain = audioCtx.createGain();
  masterGain.gain.setValueAtTime(0.04, now);
  masterGain.connect(audioCtx.destination);

  melody.forEach(note => {
    const t = now + note.delay;
    const freq = c5 * Math.pow(2, note.st / 12);

    // Main oscillator — square for that bloopy bite
    const osc = audioCtx.createOscillator();
    const noteGain = audioCtx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(freq, t);

    // Punchy attack, sustain, then taper
    noteGain.gain.setValueAtTime(0, t);
    noteGain.gain.linearRampToValueAtTime(0.7, t + 0.008);
    noteGain.gain.setValueAtTime(0.6, t + note.dur * 0.6);
    noteGain.gain.exponentialRampToValueAtTime(0.001, t + note.dur + 0.05);

    osc.connect(noteGain);
    noteGain.connect(masterGain);
    osc.start(t);
    osc.stop(t + note.dur + 0.06);

    // Octave sparkle layer — sawtooth, quieter
    const osc2 = audioCtx.createOscillator();
    const noteGain2 = audioCtx.createGain();
    osc2.type = 'sawtooth';
    osc2.frequency.setValueAtTime(freq * 2, t);

    noteGain2.gain.setValueAtTime(0, t);
    noteGain2.gain.linearRampToValueAtTime(0.15, t + 0.008);
    noteGain2.gain.exponentialRampToValueAtTime(0.001, t + note.dur * 0.7);

    osc2.connect(noteGain2);
    noteGain2.connect(masterGain);
    osc2.start(t);
    osc2.stop(t + note.dur + 0.06);
  });

  // Fade master out at the end
  const endTime = now + 2.0;
  masterGain.gain.setValueAtTime(0.04, endTime);
  masterGain.gain.exponentialRampToValueAtTime(0.001, endTime + 0.5);
}

function hackTheGibson() {
  notify('HACK THE PLANET!', 'warn');
  triggerGlitch();
  setTimeout(() => notify('ACCESS GRANTED — Welcome to The Gibson', 'warn'), 1500);
  setTimeout(() => notify('Downloading garbage file...', 'error'), 3000);
  setTimeout(() => {
    // Spawn a big dramatic overlay briefly
    const overlay = document.createElement('div');
    overlay.style.cssText = `
      position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:99999;
      display:flex;align-items:center;justify-content:center;
      background:rgba(0,0,0,0.9);
      font-family:'Orbitron',sans-serif;font-size:60px;color:#00ff41;
      text-shadow:0 0 30px #00ff41, 0 0 60px #00ff41;
      letter-spacing:10px;
    `;
    overlay.textContent = 'ACCESS GRANTED';
    document.body.appendChild(overlay);
    // Victory melody!
    playVictoryMelody();
    setTimeout(() => {
      overlay.style.transition = 'opacity 1s';
      overlay.style.opacity = '0';
      setTimeout(() => overlay.remove(), 1000);
    }, 2000);
  }, 4000);
}

function runNetScan() {
  notify('Network sweep initiated...', 'warn');
  let count = 0;
  const interval = setInterval(() => {
    notify(`Found: ${ipAddr()} [${pick(['OPEN','FILTERED','CLOSED'])}]`);
    count++;
    if (count >= 5) {
      clearInterval(interval);
      notify(`Sweep complete: ${randInt(10,50)} hosts discovered`, 'warn');
    }
  }, 800);
}

function spawnFloatingTerminal() {
  const p = createPanel({
    title: `◆ TERMINAL // PID:${randInt(1000,9999)}`,
    x: randInt(50, 400),
    y: randInt(50, 300),
    w: 450,
    h: 280,
  });
  createTerminal(p.body);
  p.el.classList.add('focused');
  p.el.style.zIndex = ++panelZIndex;
  notify('New terminal spawned');
}

function resetLayout() {
  $$('.panel').forEach(p => p.remove());
  panels = [];
  initAll();
  notify('Layout reset');
}

// --- AUDIO CONTEXT (initialized by access overlay) ---
let audioCtx;
// Audio burst parameters (exposed for slider control — var for window[] access)
var burstNoteDur = { min: 0.03, max: 0.11 };   // note duration range (seconds)
var burstNoteCount = { min: 3, max: 6 };         // notes per burst
var burstNoteGap = { min: 0.01, max: 0.05 };     // gap between notes (seconds)
var burstInterval = { min: 1500, max: 8000 };     // pause between bursts (ms)
function initAudio() {
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // --- Low quiet background hum (mains hum feel) ---
    const hum = audioCtx.createOscillator();
    const humGain = audioCtx.createGain();
    hum.type = 'sine';
    hum.frequency.value = 40;      // sub-bass hum
    humGain.gain.value = 0.008;
    hum.connect(humGain);

    // Add a second harmonic for warmth
    const hum2 = audioCtx.createOscillator();
    const hum2Gain = audioCtx.createGain();
    hum2.type = 'sine';
    hum2.frequency.value = 80;     // first harmonic
    hum2Gain.gain.value = 0.004;
    hum2.connect(hum2Gain);

    // Filtered noise floor (hiss)
    const noiseLen = audioCtx.sampleRate * 2;
    const noiseBuf = audioCtx.createBuffer(1, noiseLen, audioCtx.sampleRate);
    const noiseData = noiseBuf.getChannelData(0);
    for (let i = 0; i < noiseLen; i++) noiseData[i] = Math.random() * 2 - 1;
    const noise = audioCtx.createBufferSource();
    noise.buffer = noiseBuf;
    noise.loop = true;
    const noiseFilter = audioCtx.createBiquadFilter();
    noiseFilter.type = 'bandpass';
    noiseFilter.frequency.value = 800;
    noiseFilter.Q.value = 0.5;
    const noiseGain = audioCtx.createGain();
    noiseGain.gain.value = 0.003;
    noise.connect(noiseFilter);
    noiseFilter.connect(noiseGain);

    humGain.connect(audioCtx.destination);
    hum2Gain.connect(audioCtx.destination);
    noiseGain.connect(audioCtx.destination);
    hum.start();
    hum2.start();
    noise.start();

    // --- Digital radio intercom bursts ---
    // Random chirps/bleeps within a 6 semitone range, at random intervals
    const baseNote = 600; // base frequency for bursts (Hz)
    // 6 semitones = range from baseNote to baseNote * 2^(6/12) ≈ baseNote * 1.414

    function scheduleRadioBurst() {
      if (!audioCtx || audioCtx.state === 'closed') return;
      const now = audioCtx.currentTime;

      // Random burst: variable quick notes
      const noteCount = Math.floor(Math.random() * (burstNoteCount.max - burstNoteCount.min + 1)) + burstNoteCount.min;
      let t = now;

      // Build the semitone sequence:
      // - no repeated notes
      // - non-monotonic (must change direction at least once)
      const semitones = [];
      let prev = Math.floor(Math.random() * 7) - 3; // -3 to +3
      semitones.push(prev);

      // Pick second note: different from first
      let second;
      do { second = Math.floor(Math.random() * 7) - 3; } while (second === prev);
      semitones.push(second);
      let lastDir = second > prev ? 1 : -1; // current direction
      let flipped = false;

      for (let i = 2; i < noteCount; i++) {
        let next;
        // Force at least one direction change by the 3rd note if not yet flipped
        if (!flipped && i === 2) {
          // Must go opposite direction
          do {
            next = Math.floor(Math.random() * 7) - 3;
          } while (next === semitones[i - 1] || (lastDir > 0 ? next >= semitones[i - 1] : next <= semitones[i - 1]));
          flipped = true;
        } else {
          // Free choice but no repeats
          do {
            next = Math.floor(Math.random() * 7) - 3;
          } while (next === semitones[i - 1]);
        }
        if ((next > semitones[i - 1]) !== (lastDir > 0)) flipped = true;
        lastDir = next > semitones[i - 1] ? 1 : -1;
        semitones.push(next);
      }

      // Burst envelope
      const burstGain = audioCtx.createGain();
      burstGain.gain.value = 0;
      burstGain.connect(audioCtx.destination);
      burstGain.gain.setValueAtTime(0, t);
      burstGain.gain.linearRampToValueAtTime(0.018, t + 0.01);

      for (let i = 0; i < noteCount; i++) {
        const freq = baseNote * Math.pow(2, semitones[i] / 12);
        const dur = burstNoteDur.min + Math.random() * (burstNoteDur.max - burstNoteDur.min);
        const gap = burstNoteGap.min + Math.random() * (burstNoteGap.max - burstNoteGap.min);

        const osc = audioCtx.createOscillator();
        const noteGain = audioCtx.createGain();
        osc.type = Math.random() > 0.5 ? 'square' : 'sawtooth';
        osc.frequency.setValueAtTime(freq, t);

        noteGain.gain.setValueAtTime(0, t);
        noteGain.gain.linearRampToValueAtTime(0.6, t + 0.005);
        noteGain.gain.setValueAtTime(0.6, t + dur - 0.005);
        noteGain.gain.linearRampToValueAtTime(0, t + dur);

        osc.connect(noteGain);
        noteGain.connect(burstGain);
        osc.start(t);
        osc.stop(t + dur + 0.01);

        t += dur + gap;
      }

      // Fade out
      burstGain.gain.setValueAtTime(0.018, t);
      burstGain.gain.linearRampToValueAtTime(0, t + 0.05);

      // Next burst: variable delay
      const nextDelay = burstInterval.min + Math.random() * (burstInterval.max - burstInterval.min);
      setTimeout(scheduleRadioBurst, nextDelay);
    }

    // Start bursts after a short delay
    setTimeout(scheduleRadioBurst, 2000);

  } catch(e) {}
}

// --- SOUND EFFECTS ---
function beep(freq = 800, duration = 50) {
  if (!audioCtx) return;
  try {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'square';
    osc.frequency.value = freq;
    gain.gain.value = 0.03;
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration/1000);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration/1000);
  } catch(e) {}
}

// Beep on notifications
const origNotify = notify;
// Override to add sound
const _notify = notify;
notify = function(msg, type) {
  _notify(msg, type);
  beep(type === 'error' ? 200 : type === 'warn' ? 400 : 800);
};

// --- ACCESS OVERLAY ---
function showAccessOverlay() {
  return new Promise(resolve => {
    const overlay = document.createElement('div');
    overlay.id = 'access-overlay';
    overlay.style.cssText = `
      position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:999999;
      background:#000;display:flex;flex-direction:column;align-items:center;justify-content:center;
      font-family:'Share Tech Mono',monospace;cursor:crosshair;
      overflow:hidden;
    `;

    overlay.innerHTML = `
      <div style="position:absolute;top:0;left:0;width:100%;height:100%;
        background:repeating-linear-gradient(0deg,rgba(0,255,65,0.03) 0px,rgba(0,255,65,0.03) 1px,transparent 1px,transparent 3px);
        pointer-events:none;"></div>
      <div style="position:absolute;top:0;left:0;width:100%;height:100%;
        background:radial-gradient(ellipse at center,transparent 50%,rgba(0,0,0,0.6) 100%);
        pointer-events:none;"></div>
      <div style="color:#003300;font-size:10px;letter-spacing:4px;margin-bottom:30px;
        font-family:'Share Tech Mono',monospace;">N3XUS CORP // SECURE TERMINAL v3.31337</div>
      <div style="color:#00ff41;font-size:14px;letter-spacing:6px;margin-bottom:8px;
        text-shadow:0 0 10px rgba(0,255,65,0.5),0 0 30px rgba(0,255,65,0.2);
        font-family:'Orbitron',sans-serif;font-weight:700;">◆ ACCESS REQUIRED ◆</div>
      <div style="color:#004400;font-size:9px;letter-spacing:3px;margin-bottom:40px;">
        AUTHORIZATION LEVEL: <span style="color:#ff0040;">CLASSIFIED</span></div>
      <div id="access-prompt" style="color:#00ff41;font-size:11px;letter-spacing:3px;
        animation:blink 1.2s step-end infinite;
        text-shadow:0 0 8px rgba(0,255,65,0.4);">[ PRESS ANY KEY OR CLICK TO AUTHENTICATE ]</div>
      <div style="color:#002200;font-size:8px;margin-top:50px;letter-spacing:2px;">
        UNAUTHORIZED ACCESS WILL BE PROSECUTED UNDER FEDERAL LAW 18 U.S.C. § 1030</div>
      <style>
        @keyframes blink { 50% { opacity: 0.3; } }
        #access-overlay .glyph-rain {
          position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;overflow:hidden;
        }
      </style>
    `;

    // Sparse falling glyphs
    const rain = document.createElement('div');
    rain.className = 'glyph-rain';
    overlay.appendChild(rain);

    const glyphs = 'アイウエオカキクケコサシスセソ0123456789ABCDEF';
    for (let i = 0; i < 30; i++) {
      const col = document.createElement('div');
      col.style.cssText = `
        position:absolute;top:${-Math.random()*100}%;left:${Math.random()*100}%;
        color:rgba(0,255,65,0.08);font-size:12px;line-height:16px;
        font-family:'Share Tech Mono',monospace;white-space:pre;
        animation:fall ${8+Math.random()*12}s linear infinite;
        animation-delay:${-Math.random()*10}s;
      `;
      let text = '';
      for (let j = 0; j < 30; j++) text += glyphs[Math.floor(Math.random()*glyphs.length)] + '\n';
      col.textContent = text;
      rain.appendChild(col);
    }

    const fallStyle = document.createElement('style');
    fallStyle.textContent = '@keyframes fall { from { transform:translateY(-100%); } to { transform:translateY(100vh); } }';
    overlay.appendChild(fallStyle);

    document.body.appendChild(overlay);

    function engage() {
      overlay.removeEventListener('click', engage);
      document.removeEventListener('keydown', engage);

      // Dramatic dismiss
      const prompt = overlay.querySelector('#access-prompt');
      prompt.style.animation = 'none';
      prompt.textContent = '[ ACCESS GRANTED ]';
      prompt.style.color = '#00ff41';
      prompt.style.textShadow = '0 0 20px #00ff41, 0 0 40px #00ff41';

      setTimeout(() => {
        overlay.style.transition = 'opacity 0.6s ease';
        overlay.style.opacity = '0';
        setTimeout(() => {
          overlay.remove();
          resolve();
        }, 600);
      }, 500);
    }

    overlay.addEventListener('click', engage);
    document.addEventListener('keydown', engage);
  });
}

// --- START ---
const skipIntro = new URLSearchParams(window.location.search).has('nointro');
if (skipIntro) {
  // Hide the intro canvas, skip straight to access overlay → boot
  document.getElementById('intro-canvas').style.display = 'none';
  (async () => {
    await showAccessOverlay();
    bootSequence();
  })();
} else {
  // Full experience: matrix intro → access overlay → boot
  initMatrix();
  (async () => {
    await matrixIntro();
    await showAccessOverlay();
    bootSequence();
  })();
}
</script>
</body>
</html>
